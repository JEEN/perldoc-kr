
=encoding utf8

=head1 NAME

=begin original

perlipc - Perl interprocess communication (signals, fifos, pipes, safe subprocesses, sockets, and semaphores)

=end original

perlipc - Perl 의 프로세스간 통신(시그널, fifo, 파이프, 안전한 서브프로세스, 소켓, 세마포어)

=head1 DESCRIPTION

=begin original

The basic IPC facilities of Perl are built out of the good old Unix
signals, named pipes, pipe opens, the Berkeley socket routines, and SysV
IPC calls.  Each is used in slightly different situations.

=end original

Perl 의 기본적인 IPC 기능은 옛날 좋은 UNIX 시그널, 이름붙은 파이프, 파이프 오픈,
Berkeley 소켓루틴, SysV IPC 콜로 구성되어 있습니다.
이 구성요소들은 각각 다른 상황에 맡게 제대로 이용됩니다.

=head1 Signals

(시그널)

=begin original

Perl uses a simple signal handling model: the %SIG hash contains names
or references of user-installed signal handlers.  These handlers will
be called with an argument which is the name of the signal that
triggered it.  A signal may be generated intentionally from a
particular keyboard sequence like control-C or control-Z, sent to you
from another process, or triggered automatically by the kernel when
special events transpire, like a child process exiting, your process
running out of stack space, or hitting file size limit.

=end original

Perl 은 간단한 시그널 핸들링 모델을 사용하고 있습니다: %SIG 라는 
해쉬는 유저가 인스톨한 시그널핸들러의 이름,
혹은 핸들러에 대한 리퍼런스를 가집니다.
이 핸들러들은 기동한 시그널의 이름을 인수로 호출됩니다.
시그널은 control-C 나 control-Z 같은 특정 키보트 시퀀스로 의식적으로 
생성할 수 있고, 다른 프로세스가 시그널을 보낼 수도 있습니다.
혹은 자식 프로세스가 종료했다거나, 프로세스가 스택을 모조리 써버리거나,
파일 사이즈 제한에 걸렸거나 하는 특수한 이벤트가 발생한 때에 
커널이 자동적으로 시그널을 발생시킬 수도 있습니다.

=begin original

For example, to trap an interrupt signal, set up a handler like this:

=end original

예를들어, 인터럽트 시그널을 트랩하기 위해서는,
아래의 예제처럼 핸들러를 설정합니다:

    sub catch_zap {
	my $signame = shift;
	$shucks++;
	die "Somebody sent me a SIG$signame";
    }
    $SIG{INT} = 'catch_zap';  # could fail in modules
    $SIG{INT} = \&catch_zap;  # best strategy

=begin original

Prior to Perl 5.7.3 it was necessary to do as little as you possibly
could in your handler; notice how all we do is set a global variable
and then raise an exception.  That's because on most systems,
libraries are not re-entrant; particularly, memory allocation and I/O
routines are not.  That meant that doing nearly I<anything> in your
handler could in theory trigger a memory fault and subsequent core
dump - see L</Deferred Signals (Safe Signals)> below.

=end original

Perl 5.7.3 이전에서는 자신의 핸들러 안을 사용할 수 있습니다.
우리들이 인식하고 있는 것은, 글로벌 변수로 설정한 다음에 예외를 
발생시키는 것뿐이라는 것에 주의해주세요.
이것은 대부분의 시스템상에서는 라이브러리, 특히 메모리 할당이나 
입출ㄹ력에 관한 것은 재입력이 불가능하기 때문입니다.
이것은 당신의 핸들러 안의 대부분의 I<모든 상황>이 이론적으로는 
메모리 폴트나 그에 이은 코어덤프를 일으ㅡ킬 가능성이 있다는 겁니다.
-아래의 L</Deferred Signals (Safe Signals)> 을 참조해주세요.

=begin original

The names of the signals are the ones listed out by C<kill -l> on your
system, or you can retrieve them from the Config module.  Set up an
@signame list indexed by number to get the name and a %signo table
indexed by name to get the number:

=end original

당신이 사용하는 시스템에서 시그널의 명칭은  C<kill -l>에 의해 
리스트업됩니다.
혹은 컨피그 모듈에서 얻을 수도 있습니다.
이름을 얻기 위한 번호에 의해 첨자가 붙은 @signame 이라는 리스트와 
번호를 얻기 위한 이름에 의해 첨자가 붙은 %signo 라는 테이블을 
셋업합니다.

    use Config;
    defined $Config{sig_name} || die "No sigs?";
    foreach $name (split(' ', $Config{sig_name})) {
	$signo{$name} = $i;
	$signame[$i] = $name;
	$i++;
    }

=begin original

So to check whether signal 17 and SIGALRM were the same, do just this:

=end original

그래서, 17 번의 시그널과 SIGALRM 이 동일한지 어떤지는 아래처럼 해서 체크할 수 있습니다:

    print "signal #17 = $signame[17]\n";
    if ($signo{ALRM}) {
	print "SIGALRM is $signo{ALRM}\n";
    }

=begin original

You may also choose to assign the strings C<'IGNORE'> or C<'DEFAULT'> as
the handler, in which case Perl will try to discard the signal or do the
default thing.

=end original

핸들러로써 C<'IGNORE'> 나 C<'DEFAULT'> 같은 문자열을 대입하는 것도 선택할 수 있습니다.
이 핸들러들은 perl 이 시그널을 파괴시키도록 하거나, 기본 동작을 수행하도록 할 수 있습니다.

=begin original

On most Unix platforms, the C<CHLD> (sometimes also known as C<CLD>) signal
has special behavior with respect to a value of C<'IGNORE'>.
Setting C<$SIG{CHLD}> to C<'IGNORE'> on such a platform has the effect of
not creating zombie processes when the parent process fails to C<wait()>
on its child processes (i.e. child processes are automatically reaped).
Calling C<wait()> with C<$SIG{CHLD}> set to C<'IGNORE'> usually returns
C<-1> on such platforms.

=end original

대부분의 UNIX 플랫폼에서는 C<CHLD>(C<CLD> 인 경우도 있음) 시그널은 
 C<'IGNORE'> 의 값에 대응하는 특별한 행동을 합니다.
 그런 플랫폼에서는  C<'IGNORE'> 에 C<$SIG{CHLD}> 를 
설정하는 것에 의해, 부모 프로세스가 C<wait()> 에 실패한 때에 
좀비 프로세스가 되는 것을 방지합니다(자식 프로세스는 자동적으로 없어집니다).
C<$SIG{CHLD}> 를 C<'IGNORE'> 를 설정해서 C<wait()> 를 호출함에 의해
이런 플랫폼에서는 C<-1> 를 통상적으로 반환합니다.

=begin original

Some signals can be neither trapped nor ignored, such as
the KILL and STOP (but not the TSTP) signals.  One strategy for
temporarily ignoring signals is to use a local() statement, which will be
automatically restored once your block is exited.  (Remember that local()
values are "inherited" by functions called from within that block.)

=end original

KILL 시그널이나 STOP 시그널(TSTP 가 아닌) 같은 몇가지의 시그널은 
트랩하는 것도 무시할 수 없습니다.
일시적으로 시그널을 무시하기 위한 전략은 local() 문을 사용하는 것입니다.
이것은 그 local() 문을 감싼 블록에서 나갔을 때에, 자동적으로 원래의 상태로 
복귀합니다.
(local() 에 의한 값은 블록의 안쪽에서 호출된 함수에 "상속되는" 것을 잊지 말아주세요)

    sub precious {
	local $SIG{INT} = 'IGNORE';
	&more_functions;
    }
    sub more_functions {
	# interrupts still ignored, for now...
    }

=begin original

Sending a signal to a negative process ID means that you send the signal
to the entire Unix process-group.  This code sends a hang-up signal to all
processes in the current process group (and sets $SIG{HUP} to IGNORE so
it doesn't kill itself):

=end original

음수의 프로세스 ID 에 대해서 시그널을 보내는 것은 UNIX 프로세스 루프 전체에 
시그널을 보내는 것이 됩니다.
아래의 코드는 최근의 프로세스 그룹에 속한 모든 프로세스에 hang-up 시그널을 
송출합니다(그리고 $SIG{HUP} 에 IGNORE 를 설정하기 때문에 자기 자신을 kill 할 수는
없습니다).

    {
	local $SIG{HUP} = 'IGNORE';
	kill HUP => -$$;
	# snazzy writing of: kill('HUP', -$$)
    }

=begin original

Another interesting signal to send is signal number zero.  This doesn't
actually affect a child process, but instead checks whether it's alive
or has changed its UID.

=end original

다른 흥미깊은 시그널은 시그널 번호 0입니다.
이것은 실제로는 자식 프로세스에 영향을 끼치는 일은 없지만, UID 가 
생기거나, 혹은 변경되는 가 하는 체크를 ㅜ행합니다.

    unless (kill 0 => $kid_pid) {
	warn "something wicked happened to $kid_pid";
    }

=begin original

When directed at a process whose UID is not identical to that
of the sending process, signal number zero may fail because
you lack permission to send the signal, even though the process is alive.
You may be able to determine the cause of failure using C<%!>.

=end original

보낼 곳의 프로세스의 UID 가 보내는 곳과 같지 않은 경우, 예를들어 프로세스가 
생겨도 시그널을 보내는 권한이 없기 때문에 시그널 번호 0 은 실패합니다.
실패의 원인은 C<%!> 을 사용해서 결정할 수 있습니다.

    unless (kill 0 => $pid or $!{EPERM}) {
	warn "$pid looks dead";
    }

=begin original

You might also want to employ anonymous functions for simple signal
handlers:

=end original

단순한 시그널 핸들러에는 이름없는 함수를 사용하려고 할지도 모르겠죠:

    $SIG{INT} = sub { die "\nOutta here!\n" };

=begin original

But that will be problematic for the more complicated handlers that need
to reinstall themselves.  Because Perl's signal mechanism is currently
based on the signal(3) function from the C library, you may sometimes be so
unfortunate as to run on systems where that function is "broken", that
is, it behaves in the old unreliable SysV way rather than the newer, more
reasonable BSD and POSIX fashion.  So you'll see defensive people writing
signal handlers like this:

=end original

그러나 이것은 자기 자신을 재인스톨할 필요가 있는 더욱 복잡한 핸들러에 대해서는 
문제가 될 가능성이 있습니다.
Perl 의 시그널 기구는 현재 C 라이브러리의 signal(3) 함수에 기반한 것이기에 
함수가 "망가졌다" 같은 즉, 보다 새롭고 신뢰성있는 BSD 형식이나 POSIX 형식이 아닌 
낡고 신용할 수 없는 SysV 방식의 행동을 하는 시스템에서 실행하려는 것은 불운한 
입장에 놓여질지도 모릅니다.
그 때문에, 아래처럼 시그널 핸들러를 써서 사람을 구하는 것을 보겠죠:

    sub REAPER {
	$waitedpid = wait;
	# loathe sysV: it makes us not only reinstate
	# the handler, but place it after the wait
	$SIG{CHLD} = \&REAPER;
    }
    $SIG{CHLD} = \&REAPER;
    # now do something that forks...

=begin original

or better still:

=end original

혹은 더욱 제대로:

    use POSIX ":sys_wait_h";
    sub REAPER {
	my $child;
	# If a second child dies while in the signal handler caused by the
	# first death, we won't get another signal. So must loop here else
	# we will leave the unreaped child as a zombie. And the next time
	# two children die we get another zombie. And so on.
        while (($child = waitpid(-1,WNOHANG)) > 0) {
	    $Kid_Status{$child} = $?;
	}
	$SIG{CHLD} = \&REAPER;  # still loathe sysV
    }
    $SIG{CHLD} = \&REAPER;
    # do something that forks...

=begin original

Signal handling is also used for timeouts in Unix,   While safely
protected within an C<eval{}> block, you set a signal handler to trap
alarm signals and then schedule to have one delivered to you in some
number of seconds.  Then try your blocking operation, clearing the alarm
when it's done but not before you've exited your C<eval{}> block.  If it
goes off, you'll use die() to jump out of the block, much as you might
using longjmp() or throw() in other languages.

=end original

UNIX 에서는 시그널 핸들러는 타임아웃을 위해서도 사용됩니다.
C<eval {}> 블록 안에서는 안전하게 보호되는 사이에, alarm 시그널을 
트랩하기 위해 시그널핸들러를 설정해서, 그 뒤에 해방되는 초수를 스케쥴링합니다.
그리고 블록킹 조작을 시험해서, 그것이 완료하면 C<eval{}> 블록을 빼기 전에 
alarm 을 클리어합니다.
설정한 시간이 지난 경우에는 다른 언어에 의해 longjmp()나 throw() 를 
사용한 때와 같은 블록을 빼기 위해 die 를 사용합니다.

=begin original

Here's an example:

=end original

例を挙げましょう:

    eval {
        local $SIG{ALRM} = sub { die "alarm clock restart" };
        alarm 10;
        flock(FH, 2);   # blocking write lock
        alarm 0;
    };
    if ($@ and $@ !~ /alarm clock restart/) { die }

=begin original

If the operation being timed out is system() or qx(), this technique
is liable to generate zombies.    If this matters to you, you'll
need to do your own fork() and exec(), and kill the errant child process.

=end original

타임아웃을 일으킨 조작이 system() 이나 qx() 라면, 이 테크닉은 좀비를 생성하는 경향이 있습니다.
만약 그것이 문제라면, 스스로 ㄹork() 나 exec() 를 사용해서 에러를 일으킨 
자식프로세스를 kill 할 필요가 있을 겁니다.

=begin original

For more complex signal handling, you might see the standard POSIX
module.  Lamentably, this is almost entirely undocumented, but
the F<t/lib/posix.t> file from the Perl source distribution has some
examples in it.

=end original

보다 복잡한 시그널 처리를 위해서는 표준 POSIX 모듈을 정하면 좋을 지도 모릅니다.
이것은 거의 대부분 문서화되지 않은 상태이지만, Perl 소스배포키트인 
 F<t/lib/posix.t> 라는 파일에는 몇가지 샘플이 있습니다.

=head2 Handling the SIGHUP Signal in Daemons

(데몬으로 SIGHUP 시그널을 다루기)

=begin original

A process that usually starts when the system boots and shuts down
when the system is shut down is called a daemon (Disk And Execution
MONitor). If a daemon process has a configuration file which is
modified after the process has been started, there should be a way to
tell that process to re-read its configuration file, without stopping
the process. Many daemons provide this mechanism using the C<SIGHUP>
signal handler. When you want to tell the daemon to re-read the file
you simply send it the C<SIGHUP> signal.

=end original

보통 시스템 부트시 시에 가동하고, 시스템 셧다운 시에 종료하는 프로세스를 
데몬(daemon: Disk And Execution MONitor) 라고 부릅니다.
만약 데몬 프로세스에 설정파일이 있고, 그것이 프로세스를 시작하고나서 
갱신된 경우, 프로세스를 멈추는 것이 아니라, 프로세스에 설정파일을 
다시 읽어들이는 것을 알리는 방법이 있어야 합니다.
많은 데몬은 이 기능을 C<SIGHUP> 시그널 핸들러를 사용해서 제공하고 있습니다.
데몬에 알람을 다시 읽어야할 경우, 단순히 데몬에 C<SIGHUP> 시그널을 보냅니다.

=begin original

Not all platforms automatically reinstall their (native) signal
handlers after a signal delivery.  This means that the handler works
only the first time the signal is sent. The solution to this problem
is to use C<POSIX> signal handlers if available, their behaviour
is well-defined.

=end original

모든 플랫폼에 있어서 시그널 송신 뒤 자동적으로(네이티브한) 시그널핸들러를 
재설정하는 것은 아닙니다.
이것은 핸들러는 최초에 시그널이 보내진 때에만 동작하는 것을 의미합니다.
이 문제의 해결책은, 만약 이용가능하다면 행동이 명확하고 C<POSIX> 
시그널 핸들러를 사용하는 것입니다.

=begin original

The following example implements a simple daemon, which restarts
itself every time the C<SIGHUP> signal is received. The actual code is
located in the subroutine C<code()>, which simply prints some debug
info to show that it works and should be replaced with the real code.

=end original

아래의 예제는 C<SIGHUP> 을 얻을 때마다 재기동하는 단순한 데몬을 구성하고 있습니다.
시렞의 코드는 서브루틴 C<code()> 에 놓여있고, 어떻게 동작하는 가를 나타내고,
실제의 코드와 바뀌도록 단순히 디버그 정보를 출력합니다.

  #!/usr/bin/perl -w

  use POSIX ();
  use FindBin ();
  use File::Basename ();
  use File::Spec::Functions;

  $|=1;

  # make the daemon cross-platform, so exec always calls the script
  # itself with the right path, no matter how the script was invoked.
  my $script = File::Basename::basename($0);
  my $SELF = catfile $FindBin::Bin, $script;

  # POSIX unmasks the sigprocmask properly
  my $sigset = POSIX::SigSet->new();
  my $action = POSIX::SigAction->new('sigHUP_handler',
                                     $sigset,
                                     &POSIX::SA_NODEFER);
  POSIX::sigaction(&POSIX::SIGHUP, $action);

  sub sigHUP_handler {
      print "got SIGHUP\n";
      exec($SELF, @ARGV) or die "Couldn't restart: $!\n";
  }

  code();

  sub code {
      print "PID: $$\n";
      print "ARGV: @ARGV\n";
      my $c = 0;
      while (++$c) {
          sleep 2;
          print "$c\n";
      }
  }
  __END__


=head1 Named Pipes

(이름붙은 파이프)

=begin original

A named pipe (often referred to as a FIFO) is an old Unix IPC
mechanism for processes communicating on the same machine.  It works
just like a regular, connected anonymous pipes, except that the
processes rendezvous using a filename and don't have to be related.

=end original

이름붙은 파이프(간혹 FIFO 로 참조됩니다)는 같은 머신상의 프로세스간 통신을 위한
낡은 UNIX PC 구조입니다.
이것은 보통의 이름없는 파이프의 접속처럼 동작하지만, 파일이름을 사용해서 
프로세스의 랑데뷰가 수행되고, 관련지을 필요가 없다는 점이 다릅니다.

=begin original

To create a named pipe, use the C<POSIX::mkfifo()> function.

=end original

이름붙은 파이프를 생성하기 위해선 C<POSIX::mkfifo()> 함수를 사용해주세요.

    use POSIX qw(mkfifo);
    mkfifo($path, 0700) or die "mkfifo $path failed: $!";

=begin original

You can also use the Unix command mknod(1) or on some
systems, mkfifo(1).  These may not be in your normal path.

=end original

일부의 시스템에서는 Unix 커맨드 mknod(1) 이나, 시스템에 따라서는 
mkfifo(1) 를 사용할 수 있습니다.
이것들은 당신의 통상경로(normal path)에 놓을 수는 없습니다.

    # system return val is backwards, so && not ||
    #
    $ENV{PATH} .= ":/etc:/usr/etc";
    if  (      system('mknod',  $path, 'p')
	    && system('mkfifo', $path) )
    {
	die "mk{nod,fifo} $path failed";
    }


=begin original

A fifo is convenient when you want to connect a process to an unrelated
one.  When you open a fifo, the program will block until there's something
on the other end.

=end original

fifo 는 어느 프로세스를 그것과는 관계없는 별도의 프로세스에 접속하고 싶을 때에 
편리합니다.
fifo 를 오픈한 때, 프로그램은 다른 쪽에 뭔가가 놓이기까지 블록됩니다.

=begin original

For example, let's say you'd like to have your F<.signature> file be a
named pipe that has a Perl program on the other end.  Now every time any
program (like a mailer, news reader, finger program, etc.) tries to read
from that file, the reading program will block and your program will
supply the new signature.  We'll use the pipe-checking file test B<-p>
to find out whether anyone (or anything) has accidentally removed our fifo.

=end original

예를들어 F<.signature> 라는 파일을 다른 쪽에 Perl 프로그램이 놓여있는 
이름붙은 파이프에 접속하고 싶다고 합시다.
이 때, 임의의 프로그램이 임의의 시점에서(메일러, 뉴스리더, finger 프로그램등과 같이) 
그 파일을 읽어내려고 하지만, 읽어내는 프로그램은 블록을 하고나서 당신의 
프로그램이 새로운 시그니쳐를 제공하도록 하지 않으면 안됩니다.
누군가(혹은 뭔가)가 잘못해서 자신들의 fifo 를 삭제하지는 않는지를 
감시하기 위해 B<-p> 같은 pipe-checking 파일테스트를 사용합니다.

    chdir; # go home
    $FIFO = '.signature';

    while (1) {
	unless (-p $FIFO) {
	    unlink $FIFO;
	    require POSIX;
	    POSIX::mkfifo($FIFO, 0700)
		or die "can't mkfifo $FIFO: $!";
	}

	# next line blocks until there's a reader
	open (FIFO, "> $FIFO") || die "can't write $FIFO: $!";
	print FIFO "John Smith (smith\@host.org)\n", `fortune -s`;
	close FIFO;
	sleep 2;    # to avoid dup signals
    }

=head2 Deferred Signals (Safe Signals)

(보류시그널(안전한 시그널))

=begin original

In Perls before Perl 5.7.3 by installing Perl code to deal with
signals, you were exposing yourself to danger from two things.  First,
few system library functions are re-entrant.  If the signal interrupts
while Perl is executing one function (like malloc(3) or printf(3)),
and your signal handler then calls the same function again, you could
get unpredictable behavior--often, a core dump.  Second, Perl isn't
itself re-entrant at the lowest levels.  If the signal interrupts Perl
while Perl is changing its own internal data structures, similarly
unpredictable behaviour may result.

=end original

Perl 5.7.3 이전의 Perl 에서는 시그널을 다루는 Perl 프로그램을 인스톨 하는 것에 의해
당신은 두가지 위험성에 직면하게 됩니다.
첫번째는 재입력가능한 라이브러리 함수를 준비한 시스템은 적다는 것.
Perl 이 어느함수(malloc(3) 나 printf(3)등)을 실행중에 시그널 인터럽트가 
있다고 하면, 당신의 시그널 핸들러는 가틍ㄴ 함수를 다시 읽고, 결과로써 예측이 불가능한 
동작이 될 가능성이 있습니다.
두번째로, Perl 자신도 최저 레벨에 있어서는 재입력가능하게 되지 않는다는 것입니다.
Perl 이 자신의 내부구조를 조작하고 있을 때에 시그널 인터럽트가 있다고 하면,
이것도 또한 예측할 수 없는 동작이 되겠죠.

=begin original

There were two things you could do, knowing this: be paranoid or be
pragmatic.  The paranoid approach was to do as little as possible in your
signal handler.  Set an existing integer variable that already has a
value, and return.  This doesn't help you if you're in a slow system call,
which will just restart.  That means you have to C<die> to longjmp(3) out
of the handler.  Even this is a little cavalier for the true paranoiac,
who avoids C<die> in a handler because the system I<is> out to get you.
The pragmatic approach was to say "I know the risks, but prefer the
convenience", and to do anything you wanted in your signal handler,
and be prepared to clean up core dumps now and again.

=end original

당신이 할 수 있는 수단은 두가지가 있었습니다:
편집광적이 되거나 현실적이 되거나 입니다.
편집광적인 접근은, 당신의 시그널 핸들러 안에서 할 수 있는 만큼 작은 일을 수행하는 것입니다.
이미 값을 가지고 존재하는 정수변수에 값을 설정해서 리턴합니다.
이것은 단순히 리스타트하는 느린 시스템 호출의 안에 있을 때에는 도움이 안됩니다.
이것은 즉, 핸들러의 바깥쪽 longjmp(3) 하기 위해서는 C<die> 할 필요가 있다는 것입니다.
이것은 정말 편집광적이라는 것에는 조금 무리가 있지만, 핸들러 안에서 C<die> 를 배제합니다.
현실적인 접근은 "리스크가 있는 것은 알지만, 편리하다면 좋지않아?"라는 것으로,
시그널 핸들러 안에서 수행하고 싶은 것을 모두 수행해서, 코어덤프를 제거하는 준비를 
하고나서 다시 수행하는 것이었습니다.

=begin original

In Perl 5.7.3 and later to avoid these problems signals are
"deferred"-- that is when the signal is delivered to the process by
the system (to the C code that implements Perl) a flag is set, and the
handler returns immediately. Then at strategic "safe" points in the
Perl interpreter (e.g. when it is about to execute a new opcode) the
flags are checked and the Perl level handler from %SIG is
executed. The "deferred" scheme allows much more flexibility in the
coding of signal handler as we know Perl interpreter is in a safe
state, and that we are not in a system library function when the
handler is called.  However the implementation does differ from
previous Perls in the following ways:

=end original

Perl 5.7.3 이후에서는 이 문제를 피하기 위해서 시그널은 "보류" 됩니다 --
이거은 시스템에 따라 시그널이 (Perl 을 구성하는 C 코드에) 송신되면, 
플래그를 설정하고, 핸들러는 즉시 반환합니다.
그리고 Perl 인터프리터의 전략적으로 "안전한" 지점(예를들어, 새로운 
OPCODE 를 실행하려고 하는 시점)에서, 플래그를 체크하고 %SIG 의 Perl 
레벨 핸들러를 실행합니다.
"보류" 스킴은 Perl 인터프리터가 안전한 상태이고, 핸들러가 호출될 때에 
시스템 라이브러리 안이 아닌 것을 알 고 있기 때문에, 
시그널 핸들러의 코딩이 유연하게 됩니다.
그러나, 구성하기에는 아래의 방향으로 이전의 Perl 과는 다릅니다:

=over 4

=item Long-running opcodes

(장시간 실행되는 OPCODES)

=begin original

As the Perl interpreter only looks at the signal flags when it is about
to execute a new opcode, a signal that arrives during a long-running
opcode (e.g. a regular expression operation on a very large string) will
not be seen until the current opcode completes.

=end original

Perl 인터프리터는 만약 장시간 실행되는 OPCODE( 예를들어 매우 긴 문자열에서의 정규표현조작)의 
도중에 시그널이 도착하면, 새로운 OPCODE 를 실행하려고 할 때에만 시그널 플래그를 보기때문에
시그널은 현재의 OPCODE 가 완료하기 까지 나타나지 않습니다.

=begin original

N.B. If a signal of any given type fires multiple times during an opcode 
(such as from a fine-grained timer), the handler for that signal will
only be called once after the opcode completes, and all the other
instances will be discarded.  Furthermore, if your system's signal queue
gets flooded to the point that there are signals that have been raised
but not yet caught (and thus not deferred) at the time an opcode
completes, those signals may well be caught and deferred during
subsequent opcodes, with sometimes surprising results.  For example, you
may see alarms delivered even after calling C<alarm(0)> as the latter
stops the raising of alarms but does not cancel the delivery of alarms
raised but not yet caught.  Do not depend on the behaviors described in
this paragraph as they are side effects of the current implementation and
may change in future versions of Perl.

=end original

주의: 만약 어떤 종류의 시그널에서도(예를들어 높은 정밀성의 타이머에서)
하나의 OPCODE 사에에 여러번 발생한 경우, 그 시그널의 핸들러는 
OPCODE 의 완료뒤 한번만 호출되지 않고, 그 외의 실체는 파괴됩니다.
거기에 시스템의 시그널 큐가 채워지기 때문에 어떤 OPCODE 가 완료할 때에
발생하지 않지만 아직 충분하지 않은(따라서 아직 보류되지 않은) 시그널이 
있으면 이 시그널들이 이어서 OPCODE 사이의 보충 및 보류되고, 때때로 
놀랄만한 결과가 될 수 있습니다.
예를들어 C<alarm(0)> 은 알람 발생을 멈추지만, 
발생했지만 아직 충분하지 않은 알람의 배달이 캔슬하지 않았기 때문에,
C<alarm(0)> 를 호출한 뒤에도 알람이 송신될 수 있습니다.
이것은 현재의 구성의 부작용이고, 장래의 Perl 버젼에서는 
갱신될지도 모르기 때문에, 이 단락에서 기술되는 행동에 의존해서는 안됩니다.

=item Interrupting IO

(I/O 인터럽트)

=begin original

When a signal is delivered (e.g. INT control-C) the operating system
breaks into IO operations like C<read> (used to implement Perls
E<lt>E<gt> operator). On older Perls the handler was called
immediately (and as C<read> is not "unsafe" this worked well). With
the "deferred" scheme the handler is not called immediately, and if
Perl is using system's C<stdio> library that library may re-start the
C<read> without returning to Perl and giving it a chance to call the
%SIG handler. If this happens on your system the solution is to use
C<:perlio> layer to do IO - at least on those handles which you want
to be able to break into with signals. (The C<:perlio> layer checks
the signal flags and calls %SIG handlers before resuming IO operation.)

=end original

(INT control-C 등에서) 시그널이 배송되면, 
OS 는 (Perl E<lt>E<gt> 연산자의 구축에서 사용되는) C<read> 같은 
I/O 조작을 중단합니다.
옛 Perl 에서는 핸드러를 당장 호출합니다
(그리고 C<read> 는 잘 움직이기 때문에 "안전하지 않은" 것은 아닙니다).
"보류" 스킴에서는 핸들러는 곧장 호출되지 않고,
만약 Perl 이 시스템의 C<stdio> 라이브러리를 사용하면 라이브러리는 
Perl 에 반환해서 %SIG 핸들러를 호출하는 기회없이 C<read> 를 재기동합니다.
만약 이것이 발생한 경우, 해결법은 I/O 를 수행할 때에 -- 적어도 시그널에서 
중단할 수 있도록 한 핸들러에서 - C<:perlio> 층을 사용하는 것입니다
(C<:perlio> 층은 시그널 플래그를 체크해서 I/O 조작을 속행하기 전에 
%SIG 핸들러를 호출합니다).

=begin original

Note that the default in Perl 5.7.3 and later is to automatically use
the C<:perlio> layer.

=end original

Perl 5.7.3 이후에는 기본으로 자동적으로 C<:perlio> 층이 사용되는 것에 주의해주세요.

=begin original

Note that some networking library functions like gethostbyname() are
known to have their own implementations of timeouts which may conflict
with your timeouts.  If you are having problems with such functions,
you can try using the POSIX sigaction() function, which bypasses the
Perl safe signals (note that this means subjecting yourself to
possible memory corruption, as described above).  Instead of setting
C<$SIG{ALRM}>:

=end original

gethostbyname() 같은 네트워크 라이브러리 함수는 독자적인 타임아웃 구성을 가지고 있는
것이 알려졌기 때문에, 당신의 타임아웃과 경쟁할지도 모르는 것에 주의해주세요.
만약 이런 함수에서 문제가 발생한 경우는, Perl 의 안전한 시그널을 회피하는 
POSIX sigaction() 함수를 시험할 수 있습니다
(이것은 위에서 언급한 메모리의 파괴 가능성이 있다라는 것에 주의해주세요).
C<$SIG{ALRM}> 을 설정하는 대신에:

   local $SIG{ALRM} = sub { die "alarm" };

=begin original

try something like the following:

=end original

아래와 같은 것을 시험해주세요:

    use POSIX qw(SIGALRM);
    POSIX::sigaction(SIGALRM,
                     POSIX::SigAction->new(sub { die "alarm" }))
          or die "Error setting SIGALRM handler: $!\n";

=begin original

Another way to disable the safe signal behavior locally is to use
the C<Perl::Unsafe::Signals> module from CPAN (which will affect
all signals).

=end original

안전한 시그널의 행동을 국소적으로 무효화하는 다른 하나의 방법은
CPAN 의 C<Perl::Unsafe::Signals> 모듈을 사용하는 것입니다
(모든 시그널에 영향을 줍니다).

=item Restartable system calls

(재기동가능한 시스템 콜)

=begin original

On systems that supported it, older versions of Perl used the
SA_RESTART flag when installing %SIG handlers.  This meant that
restartable system calls would continue rather than returning when
a signal arrived.  In order to deliver deferred signals promptly,
Perl 5.7.3 and later do I<not> use SA_RESTART.  Consequently, 
restartable system calls can fail (with $! set to C<EINTR>) in places
where they previously would have succeeded.

=end original

이것을 지원하는 시스템에서는 보다 옛 버젼의 Perl 에서는 %SIG 
핸들러를 설정할 때에 SA_RESTART 플래그를 사용합니다.
이것은 재기동가능한 시스템콜에서는 시그널이 송신된 때에 
돌아오는 것이 아니라 속행하는 것을 의미합니다.
보류 시그널을 빨리 송신하기 위해서
Perl 5.7.3 이후에서는 SA_RESTART 를 I<사용하지 않습니다>.
결과로써 재기동가능한 시스템 호출은 아직까지 성공하던 곳에도
($! 에 C<EINTR> 을 설정해서) 실패할 수 있습니다.

=begin original

Note that the default C<:perlio> layer will retry C<read>, C<write>
and C<close> as described above and that interrupted C<wait> and 
C<waitpid> calls will always be retried.

=end original

기본 C<:perlio> 층에서는  C<read>, C<write>, C<close> 는 위에서 말했듯이
다시 시행해서, 중단된 C<wait> 와 C<waitpid> 의 호출은 항상 
다시 시행되는 것에 주의해주세요.

=item Signals as "faults"

(「장해」로써의 시그널)

=begin original

Certain signals, e.g. SEGV, ILL, and BUS, are generated as a result of
virtual memory or other "faults". These are normally fatal and there is
little a Perl-level handler can do with them, so Perl now delivers them
immediately rather than attempting to defer them.

=end original

SEGV, ILL, BUS 같은 시그널은 가상 메모리나 그 외의 "장해"의 결과로
생성됩니다.
이것들은 보통 치명적이고, Perl 레벨의 핸들러가 할 수 있는 일은 
거의 없기에, 이것들을 보류하려고하지 않고 즉시 송신합니다.

=item Signals triggered by operating system state

(OS 상태에 의해 발생하는 시그널)

=begin original

On some operating systems certain signal handlers are supposed to "do
something" before returning. One example can be CHLD or CLD which
indicates a child process has completed. On some operating systems the
signal handler is expected to C<wait> for the completed child
process. On such systems the deferred signal scheme will not work for
those signals (it does not do the C<wait>). Again the failure will
look like a loop as the operating system will re-issue the signal as
there are un-waited-for completed child processes.

=end original

OS 에 따라서는 어떤 종류의 시그널 핸들러는 반환하기 전에 "무엇을 한다" 라는 것이 
되어 있는 것도 있습니다.
하나의 예로써는 CHLD 나 CLD 는 자식 프로세스가 완료한 것을 나타냅니다.
OS 에 따라서는 시그널 핸들은 완료한 자식 프로세스를 위해 
C<wait> 하는 것을 상정하는 것도 있습니다.
이런 시스템에서는 보류 시그널 스킴은 이 시그널들에서는 
동작하지 않습니다(C<wait> 하지않습니다).
다시, 문제는 wait 하지 않는 완료한 자식 프로세스가 있는 가 처럼 시그널이 
다시 발생하는 것으로 루프처럼 보입니다.

=back

=begin original

If you want the old signal behaviour back regardless of possible
memory corruption, set the environment variable C<PERL_SIGNALS> to
C<"unsafe"> (a new feature since Perl 5.8.1).

=end original

만약 메모리 파괴의 가능성에도 불구하고, 낡은 시그널의 행동을 원한다면, 
환경변수 C<PERL_SIGNALS> 를 C<"unsafe"> 를 설정해주세요
(Perl 5.8.1에서의 새로운 기능입니다).

=head1 Using open() for IPC

(IPC 를 위해 open() 을 사용하기)

=begin original

Perl's basic open() statement can also be used for unidirectional
interprocess communication by either appending or prepending a pipe
symbol to the second argument to open().  Here's how to start
something up in a child process you intend to write to:

=end original

Perl 의 open() 문은 그 두번째 인수에서 파이프 심볼을 전치하든가 끝단에 
부가하는 가에 따라서 한방향의 프로세스간 통신을 위해 사용할 수 있습니다.
아래의 예제는 쓰기를 수행하는 자식 프로세스를 재기동 시키는 방법입니다:

    open(SPOOLER, "| cat -v | lpr -h 2>/dev/null")
		    || die "can't fork: $!";
    local $SIG{PIPE} = sub { die "spooler pipe broke" };
    print SPOOLER "stuff\n";
    close SPOOLER || die "bad spool: $! $?";

=begin original

And here's how to start up a child process you intend to read from:

=end original

그리고 아래의 예제는 그후의 읽기를 수행하고 싶은 자식 프로세스를 기동하는 방법입니다:

    open(STATUS, "netstat -an 2>&1 |")
		    || die "can't fork: $!";
    while (<STATUS>) {
	next if /^(tcp|udp)/;
	print;
    }
    close STATUS || die "bad netstat: $! $?";

=begin original

If one can be sure that a particular program is a Perl script that is
expecting filenames in @ARGV, the clever programmer can write something
like this:

=end original

특정의 프로그램의 하나가 @ARGV 에 있는 파이이름을 기대하는 Perl 스크립트여도 좋다면
현명한 프로그래머는 아래처럼 쓸 수도 있습니다:

    % program f1 "cmd1|" - f2 "cmd2|" f3 < tmpfile

=begin original

and irrespective of which shell it's called from, the Perl program will
read from the file F<f1>, the process F<cmd1>, standard input (F<tmpfile>
in this case), the F<f2> file, the F<cmd2> command, and finally the F<f3>
file.  Pretty nifty, eh?

=end original

그리고 그것을 호출한 셸에는 관계없이 이 Perl 프로그램은 F<f1> 이라는 파일,
F<cmd1> 이라는 프로세스, 표준입력(이 예제에서는 F<tmpfile>),
F<f2> 라는 파일, F<cmd2> 라는 커맨드, F<f3> 라는 파일에서 
읽기를 수행합니다. 대단하죠?

=begin original

You might notice that you could use backticks for much the
same effect as opening a pipe for reading:

=end original

읽기를 위한 파이프를 열기 위해 역따옴표를 사용해서 같은 일을 
수행할 수 있는 것을 알고 있겠죠:

    print grep { !/^(tcp|udp)/ } `netstat -an 2>&1`;
    die "bad netstat" if $?;

=begin original

While this is true on the surface, it's much more efficient to process the
file one line or record at a time because then you don't have to read the
whole thing into memory at once.  It also gives you finer control of the
whole process, letting you to kill off the child process early if you'd
like.

=end original

그 추측은 표면적으로는 바르게 보이겠지만, 하넙ㄴ에 메모리에 모든 것을 읽을 
필요가 없기 때문에, 한번에 파일의 한줄이나 하나의 레코드를 처리하기 위해서는
(최초의 예제 쪽이) 보다 효율적입니다.
마찬가지로 프로세스 전체의 제어를 주기 때문에, 당신이 원한다면 이른 시기에 
자식 프로세스를 kill 할 수가 있습니다.

=begin original

Be careful to check both the open() and the close() return values.  If
you're I<writing> to a pipe, you should also trap SIGPIPE.  Otherwise,
think of what happens when you start up a pipe to a command that doesn't
exist: the open() will in all likelihood succeed (it only reflects the
fork()'s success), but then your output will fail--spectacularly.  Perl
can't know whether the command worked because your command is actually
running in a separate process whose exec() might have failed.  Therefore,
while readers of bogus commands return just a quick end of file, writers
to bogus command will trigger a signal they'd better be prepared to
handle.  Consider:

=end original

open() 과 close() 의 반환값을 체크할 때는 주의해주세요.
파이프에 대해서 B<쓰기> 를 한 것이라면 SIGPIPE 를 트랩해야합니다.
그렇지 않으면, 존재하지 않으면 커맨드에 대한 파이프를 기동한 때에 
일어나는 것에 대해서 생각할 겁니다: open() 은 대부분의 경우 
성공한다고 생각할지 모르지만(이것은 fork() 의 성공만을 반영합니다),
당신의 출력은 그 뒤에 실패할 겁니다.
커맨드는 실제로는 exec() 가 실패한 다른 프로세스로 실행되기 때문에 
Perl 은 커맨드가 잘 움직이는지 어떤지를 알 수 는 없습니다.
따라서 거짓 커맨드(bugus command)를 읽는 이는 즉시 end of file 을 
받아서 거짓 커맨드에 대해 쓰는 쪽은 사전에 다뤄둬야할 시그널을 발생시킬 겁니다.
아래의 예제를 생각해보죠:

    open(FH, "|bogus")	or die "can't fork: $!";
    print FH "bang\n"	or die "can't write: $!";
    close FH		or die "can't close: $!";

=begin original

That won't blow up until the close, and it will blow up with a SIGPIPE.
To catch it, you could use this:

=end original

이것은 클로즈하기 까지 폭발하지 않고 폭발하면 SIGPIPE 를 생성하게 합니다.
이것을 포착하기 위해서는 아래처럼 합니다:

    $SIG{PIPE} = 'IGNORE';
    open(FH, "|bogus")  or die "can't fork: $!";
    print FH "bang\n"   or die "can't write: $!";
    close FH            or die "can't close: status=$?";

=head2 Filehandles

(파일 핸들)

=begin original

Both the main process and any child processes it forks share the same
STDIN, STDOUT, and STDERR filehandles.  If both processes try to access
them at once, strange things can happen.  You may also want to close
or reopen the filehandles for the child.  You can get around this by
opening your pipe with open(), but on some systems this means that the
child process cannot outlive the parent.

=end original

메인 프로세스와 자식 프로세스에서 같은 파일핸들 STDIN, STDOUT, STDERR 을 공유합니다.
양쪽의 프로세스가 동시에 그 핸들들에 접근하려고 한 경우, 
이상한 일이 발생할 가능성이 있습니다.
당신은 자식 프로세스를 위해 파일핸들의 클로즈와 다시 열고 싶다고 생각할지 모르겠습니다.
이것은 open() 을 사용해서 파이프를 오픈하는 것에 의해 대처할 수 있지만, 
일부의 시스템에서는 자식 프로세스는 그 부모프로세스에서도 생성할 수는 없습니다.

=head2 Background Processes

(백그라운드 프로세스)

=begin original

You can run a command in the background with:

=end original

아래처럼 해서 커맨드를 백그라운드에서 실행할 수 있습니다:

    system("cmd &");

=begin original

The command's STDOUT and STDERR (and possibly STDIN, depending on your
shell) will be the same as the parent's.  You won't need to catch
SIGCHLD because of the double-fork taking place (see below for more
details).

=end original

커맨드의 STDOUT 과 STDERR (과 당신이 사용하는 셸에 따라서는 STDIN 도)은 
그 부모 프로세스의 것과 동일하게 됩니다.
double-fork 의 실행에 의해 SIGCHLD 를 포착할 필요는 없습니다
(자세한 내용은 나중에 언급하겠습니다).

=head2 Complete Dissociation of Child from Parent

(자식의 부모로부터의 완전한 분리)

=begin original

In some cases (starting server processes, for instance) you'll want to
completely dissociate the child process from the parent.  This is
often called daemonization.  A well behaved daemon will also chdir()
to the root directory (so it doesn't prevent unmounting the filesystem
containing the directory from which it was launched) and redirect its
standard file descriptors from and to F</dev/null> (so that random
output doesn't wind up on the user's terminal).

=end original

일부의 경우(예를들어 서버 프로세스의 스타트), 부모 프로세스와 자식 프로세스를 완전히 
무관계한 것으로 할 수 있겠죠.
이것은 때때로 데몬화라고 불립니다.
예의 바른 데몬은 루트 디렉토리에 chdir() (그때문에 실행파일이 있는 디렉토리를 
포함한 파일 시스템의 마운트를 방해하는 일이 없습니다)하고, 그 표준 파일 기술자를 
F</dev/null> 에 리다이렉트합니다.

    use POSIX 'setsid';

    sub daemonize {
	chdir '/'		or die "Can't chdir to /: $!";
	open STDIN, '/dev/null' or die "Can't read /dev/null: $!";
	open STDOUT, '>/dev/null'
				or die "Can't write to /dev/null: $!";
	defined(my $pid = fork)	or die "Can't fork: $!";
	exit if $pid;
	setsid			or die "Can't start a new session: $!";
	open STDERR, '>&STDOUT'	or die "Can't dup stdout: $!";
    }

=begin original

The fork() has to come before the setsid() to ensure that you aren't a
process group leader (the setsid() will fail if you are).  If your
system doesn't have the setsid() function, open F</dev/tty> and use the
C<TIOCNOTTY> ioctl() on it instead.  See tty(4) for details.

=end original

fork() 는 프로세스 그룹 리더(만약 그렇다면 setsid() 는 실패할겁니다)가 아닌 것을 
보증하기 위해서 setsid() 앞이 아니면 안됩니다.
당신이 사용하는 시스템이 setsid() 함수를 가지고 있지 않다면,
F</dev/tty> 를 오픈해서 C<TIONCNOTTY> ioctl() 를 대신에 사용합니다.
자세한 내용은 tty(4) 를 참조해주세요.

=begin original

Non-Unix users should check their Your_OS::Process module for other
solutions.

=end original

비 UNIX 유저는 당신의 OS 의 Process 모듈을 체크해서 다른 해결책을 찾아보세요.

=head2 Safe Pipe Opens

(안전한 파이프 오픈)

=begin original

Another interesting approach to IPC is making your single program go
multiprocess and communicate between (or even amongst) yourselves.  The
open() function will accept a file argument of either C<"-|"> or C<"|-">
to do a very interesting thing: it forks a child connected to the
filehandle you've opened.  The child is running the same program as the
parent.  This is useful for safely opening a file when running under an
assumed UID or GID, for example.  If you open a pipe I<to> minus, you can
write to the filehandle you opened and your kid will find it in his
STDIN.  If you open a pipe I<from> minus, you can read from the filehandle
you opened whatever your kid writes to his STDOUT.

=end original

또 다른 IPC 를 위한 흥미깊은 접근은 멀티 프로세스가 되어서
각각의 프로세스 사이에서 통신을 수행하는 단일 프로그램을 만드는 것입니다.
open()함수는 C<"-|"> 나  C<"|-"> 같은 파일인수를 상당하게 
재미있는 일을 위해 받습니다: 이것은 당신이 오픈한 파일 핸들을 위한 자식 프로세스를 
fork() 하는 것입니다.
이 자식 프로세스는 부모 프로세스와 같은 프로그램을 실행합니다.
이것은 예를들어, 가정된 UID 나 GID 에서 실행할 때에 안전하게 파일을 오픈하는 것에 
편리합니다.
마이너스에 B<대한> 파이프를 오픈하면, 당신은 오픈한 파일핸들에 쓸 수 있고,
자식 프로세스는 그것을 자신의 STDIN 으로 봅니다.
마이너스 B<로부터의> 파이프를 오픈한 경우에는 자식 프로세스가 그 STDOUT 
에 써낸 것이 오픈한 파일핸들에서 읽어들일 수가 있는 것입니다.

    use English '-no_match_vars';
    my $sleep_count = 0;

    do {
	$pid = open(KID_TO_WRITE, "|-");
	unless (defined $pid) {
	    warn "cannot fork: $!";
	    die "bailing out" if $sleep_count++ > 6;
	    sleep 10;
	}
    } until defined $pid;

    if ($pid) {  # parent
	print KID_TO_WRITE @some_data;
	close(KID_TO_WRITE) || warn "kid exited $?";
    } else {     # child
	($EUID, $EGID) = ($UID, $GID); # suid progs only
	open (FILE, "> /safe/file")
	    || die "can't open /safe/file: $!";
	while (<STDIN>) {
	    print FILE; # child's STDIN is parent's KID
	}
	exit;  # don't forget this
    }

=begin original

Another common use for this construct is when you need to execute
something without the shell's interference.  With system(), it's
straightforward, but you can't use a pipe open or backticks safely.
That's because there's no way to stop the shell from getting its hands on
your arguments.   Instead, use lower-level control to call exec() directly.

=end original

이 방법을 하는 다른 하나의 일반적인 예제는 셸의 인터페이스를 빼고, 
뭔가를 실행할 필요가 있을 때일겁니다.
system() 을 사용하면 그것은 직접적인 것이지만, 파이프의 오픈이나 
역따옴표를 안전하게 사용할 수가 없습니다.
이것은 셸이 당신의 인수를 건드리는 것을 방지하는 방법이 없기 때문입니다.
대신에, exec() 를 직접 호출하는 로우레벨 같은 제어를 사용합니다.

=begin original

Here's a safe backtick or pipe open for read:

=end original

아래의 예제는 읽기용의 안전한 역따옴표나 파이프오픈의 예제입니다:

    # add error processing as above
    $pid = open(KID_TO_READ, "-|");

    if ($pid) {   # parent
	while (<KID_TO_READ>) {
	    # do something interesting
	}
	close(KID_TO_READ) || warn "kid exited $?";

    } else {      # child
	($EUID, $EGID) = ($UID, $GID); # suid only
	exec($program, @options, @args)
	    || die "can't exec program: $!";
	# NOTREACHED
    }


=begin original

And here's a safe pipe open for writing:

=end original

그리고 아래의 예제는 쓰기용의 안전한 역따옴표나 파이프 오픈의 예제입니다:

    # add error processing as above
    $pid = open(KID_TO_WRITE, "|-");
    $SIG{PIPE} = sub { die "whoops, $program pipe broke" };

    if ($pid) {  # parent
	for (@data) {
	    print KID_TO_WRITE;
	}
	close(KID_TO_WRITE) || warn "kid exited $?";

    } else {     # child
	($EUID, $EGID) = ($UID, $GID);
	exec($program, @options, @args)
	    || die "can't exec program: $!";
	# NOTREACHED
    }

=begin original

Since Perl 5.8.0, you can also use the list form of C<open> for pipes :
the syntax

=end original

Perl 5.8.0 부터 파이프를 위해 C<open> 의 리스트 형식을 사용할 수 있습니다;
아래와 같은 방법으로:

    open KID_PS, "-|", "ps", "aux" or die $!;

=begin original

forks the ps(1) command (without spawning a shell, as there are more than
three arguments to open()), and reads its standard output via the
C<KID_PS> filehandle.  The corresponding syntax to write to command
pipes (with C<"|-"> in place of C<"-|">) is also implemented.

=end original

ps(1) 커맨드를 fork 해서(3 이상의 인수의 open() 처럼 셸을 기동하지 않고),
C<KID_PS> 파일핸들 경유로 표준출력을 읽어들입니다.
커맨드 파이프오 쓰기 위한 방법 (C<"-|"> 대신에 C<"|-">) 도 구성할 수 있습니다.

=begin original

Note that these operations are full Unix forks, which means they may not be
correctly implemented on alien systems.  Additionally, these are not true
multithreading.  If you'd like to learn more about threading, see the
F<modules> file mentioned below in the SEE ALSO section.

=end original

이 조작들은 UNIX 의 fork 로 충분하고, 그 fork 가 다른 시스템에서는 
적절하게 구성되지 않을 가능성이 있다고 하는 것에 주의해주세요.
그에 더해서, 이 방법들은 진짜 멀티스레드가 아닌ㅂ니다.
스레드에 대해서 좀 더 배우고 싶다고 생각하신다면, 나중에 기술할 SEE ALSO 장에서 
언급할 F<modules> 파일을 참조해주세요.

=head2 Bidirectional Communication with Another Process

(다른 프로세스와의 쌍방향통신)

=begin original

While this works reasonably well for unidirectional communication, what
about bidirectional communication?  The obvious thing you'd like to do
doesn't actually work:

=end original

이것은 단방향통신에 대해서 잘 움직입니다.
그럼 쌍방향 통신은?
당신이 하고싶다고 생각하는 것은 실제로 잘 움직이지 않습니다:

    open(PROG_FOR_READING_AND_WRITING, "| some program |")

=begin original

and if you forget to use the C<use warnings> pragma or the B<-w> flag,
then you'll miss out entirely on the diagnostic message:

=end original

이 상태에서 C<use warnings> 프라그마나 B<-w> 플래그를 사용하는 것을 잊어버리면,
아래처럼 진단 메시지를 얻을 기회를 잃어버리게 되겠죠.

    Can't do bidirectional pipe at -e line 1.

=begin original

If you really want to, you can use the standard open2() library function
to catch both ends.  There's also an open3() for tridirectional I/O so you
can also catch your child's STDERR, but doing so would then require an
awkward select() loop and wouldn't allow you to use normal Perl input
operations.

=end original

정말로 이런 일을 하고 싶다면, 표준의 open2() 라는 라이브러리를 사용하는 것으로,
파이프의 양쪽을 얻을 수 있습니다.
세방향의 입출력을 위한 open3() 도 있기 때문에, 자식 프로세스의 
STDERR 을 포착하는 것도 가능하지만, 그를 위해서는 꺼림직한 
select() 루프가 필요하고, Perl 의 통상 입력조작을 수행할 수 없습니다.

=begin original

If you look at its source, you'll see that open2() uses low-level
primitives like Unix pipe() and exec() calls to create all the connections.
While it might have been slightly more efficient by using socketpair(), it
would have then been even less portable than it already is.  The open2()
and open3() functions are  unlikely to work anywhere except on a Unix
system or some other one purporting to be POSIX compliant.

=end original

open2() 소스를 보면, 그것이 모든 접속을 생성하기 위해서 UNIX 에서의 pipe() 와 
exec() 같은 저수준의 프리미티브를 사용하는 것을 알 수 있을 겁니다.
이것은  socketpair() 을 사용하는 것보다 효율이 좋지만, 이식성이라는 면에서는 
좋지 않습니다.
open2() 와 open3() 는 UNIX 시스템이나 그 외의 POSIX 에 따른 시스템을 
빼고는 아마 움직이지 않을 겁니다.

=begin original

Here's an example of using open2():

=end original

아래는 open2() 를 사용한 예제입니다:

    use FileHandle;
    use IPC::Open2;
    $pid = open2(*Reader, *Writer, "cat -u -n" );
    print Writer "stuff\n";
    $got = <Reader>;

=begin original

The problem with this is that Unix buffering is really going to
ruin your day.  Even though your C<Writer> filehandle is auto-flushed,
and the process on the other end will get your data in a timely manner,
you can't usually do anything to force it to give it back to you
in a similarly quick fashion.  In this case, we could, because we
gave I<cat> a B<-u> flag to make it unbuffered.  But very few Unix
commands are designed to operate over pipes, so this seldom works
unless you yourself wrote the program on the other end of the
double-ended pipe.

=end original

이에 관한 문제는 UNIX 의 버퍼링이 실제로 어느 시점에 달하기 까지 쌓이는 가 하는 것에 
있습니다. 파일 핸들 C<Writer> 를 자동플러쉬했다고 해도, 다른 한 쪽에 있는 
프로세스는 보내진 데이터를 적당한 타이밍으로 받게 됩니다; 일반적으로 
모든 것에 관해 즉시 대응하도록 강제할 수는 없습니다.
위의 예제에서는 버퍼링을 하지 않도록 하기 위해 B<-u> 플래그를 
I<cat> 에 줄 수 있었기 때문에 그것이 가능했습니다.
파이프넘어 사용되는 일을 상정해서 설계된 UNIX 커맨드는 매우 소수이기 때문에 
이 예제와 같은 일은 양쪽이 있는 파이프의 다른 한쪽에 있는 
프로그램을 자기 자신이 쓸 수 없는 한 거의 불가능한 것입니다.

=begin original

A solution to this is the nonstandard F<Comm.pl> library.  It uses
pseudo-ttys to make your program behave more reasonably:

=end original

이 해결책은 비표준의 F<Comm.pl> 라이브러리입니다.
이것은 당신의 프로긂을 보다 신뢰성있게 하기 위한 유사 TTY 를 사용합니다:

    require 'Comm.pl';
    $ph = open_proc('cat -n');
    for (1..10) {
	print $ph "a line\n";
	print "got back ", scalar <$ph>;
    }

=begin original

This way you don't have to have control over the source code of the
program you're using.  The F<Comm> library also has expect()
and interact() functions.  Find the library (and we hope its
successor F<IPC::Chat>) at your nearest CPAN archive as detailed
in the SEE ALSO section below.

=end original

이 방법에서는 당신이 사용하려고 하는 프로그램의 소스코드를 수없이 건드릴 필요는 없습니다.
F<Comm> 라이브러리에는 이외에도 expect() 나 interact() 같은 함수도 있습니다.
나중에 적을 SEE ALSO 장에 있는 설명문의 CPAN 에서, 이 라이브러리(와 
그 후계자로 기대되는 F<IPC::Chat>) 를 봐주세요.

=begin original

The newer Expect.pm module from CPAN also addresses this kind of thing.
This module requires two other modules from CPAN: IO::Pty and IO::Stty.
It sets up a pseudo-terminal to interact with programs that insist on
using talking to the terminal device driver.  If your system is
amongst those supported, this may be your best bet.

=end original

CPAN 에 있는 보다 새로운 모듈 Expect.pm 은 이 문제에 대처한 것입니다.
이 모듈은 이 외에도 IO::Pty, IO::Stty 라는 두가지 CPAN 모듈을 필요로 합니다.
이 모듈은 터미널 디바이스드라이버로 대답하도록 프로그램과 대화하기 위해 
유사단말을 설정합니다. 만약 당신이 사용하고 있는 시스템이 이런 것을 지원하고 있다면,
그쪽을 사용하는 편이 좋겠죠.

=head2 Bidirectional Communication with Yourself

(자기 자신이 쌍방향통신을 하기)

=begin original

If you want, you may make low-level pipe() and fork()
to stitch this together by hand.  This example only
talks to itself, but you could reopen the appropriate
handles to STDIN and STDOUT and call other processes.

=end original

원한다면, 저레벨 시스템 콜 pipe() 나 fork() 를 수작업으로 
수행하기 위해 사용할 수 있습니다.
아래의 예제는 단순히 설명을 위한 것이지만, STDIN 이나 STDOUT 에 대한 
적절한 핸들을 다시 오픈할 수 있고, 거기에 다른 별도의 프로세스를 
호출할 수 있습니다.

    #!/usr/bin/perl -w
    # pipe1 - bidirectional communication using two pipe pairs
    #         designed for the socketpair-challenged
    use IO::Handle;	# thousands of lines just for autoflush :-(
    pipe(PARENT_RDR, CHILD_WTR);		# XXX: failure?
    pipe(CHILD_RDR,  PARENT_WTR);		# XXX: failure?
    CHILD_WTR->autoflush(1);
    PARENT_WTR->autoflush(1);

    if ($pid = fork) {
	close PARENT_RDR; close PARENT_WTR;
	print CHILD_WTR "Parent Pid $$ is sending this\n";
	chomp($line = <CHILD_RDR>);
	print "Parent Pid $$ just read this: `$line'\n";
	close CHILD_RDR; close CHILD_WTR;
	waitpid($pid,0);
    } else {
	die "cannot fork: $!" unless defined $pid;
	close CHILD_RDR; close CHILD_WTR;
	chomp($line = <PARENT_RDR>);
	print "Child Pid $$ just read this: `$line'\n";
	print PARENT_WTR "Child Pid $$ is sending this\n";
	close PARENT_RDR; close PARENT_WTR;
	exit;
    }

=begin original

But you don't actually have to make two pipe calls.  If you
have the socketpair() system call, it will do this all for you.

=end original

그러나 실제 두가지 pipe 의 호출을 수행할 필요는 없습니다.
당신이 사용하는 시스템이 socketpair() 시스템 콜을 지원하고 있다면,
그것이 당신 대신에 작업을 수행해줍니다.

    #!/usr/bin/perl -w
    # pipe2 - bidirectional communication using socketpair
    #   "the best ones always go both ways"

    use Socket;
    use IO::Handle;	# thousands of lines just for autoflush :-(
    # We say AF_UNIX because although *_LOCAL is the
    # POSIX 1003.1g form of the constant, many machines
    # still don't have it.
    socketpair(CHILD, PARENT, AF_UNIX, SOCK_STREAM, PF_UNSPEC)
				or  die "socketpair: $!";

    CHILD->autoflush(1);
    PARENT->autoflush(1);

    if ($pid = fork) {
	close PARENT;
	print CHILD "Parent Pid $$ is sending this\n";
	chomp($line = <CHILD>);
	print "Parent Pid $$ just read this: `$line'\n";
	close CHILD;
	waitpid($pid,0);
    } else {
	die "cannot fork: $!" unless defined $pid;
	close CHILD;
	chomp($line = <PARENT>);
	print "Child Pid $$ just read this: `$line'\n";
	print PARENT "Child Pid $$ is sending this\n";
	close PARENT;
	exit;
    }

=head1 Sockets: Client/Server Communication

(소켓: 클라이언트/서버 통신)

=begin original

While not limited to Unix-derived operating systems (e.g., WinSock on PCs
provides socket support, as do some VMS libraries), you may not have
sockets on your system, in which case this section probably isn't going to do
you much good.  With sockets, you can do both virtual circuits (i.e., TCP
streams) and datagrams (i.e., UDP packets).  You may be able to do even more
depending on your system.

=end original

UNIX 에서 파생한 OS 에 한정하지 않음 
(예를들어 PC 에서는 WinSock 이(몇가지의 VMS 라이브러리처럼) 
에도 상관없이, 당신이 사용하는 시스템에서는 
소켓을 사용할 수 없을 지도 모릅니다.
그 경우, 그 항에 쓰여있는 일은 당신에게 도움이 되지 않겠죠.
소켓을 사용하면 가상회로(즉 TCP 스트림)이나 데이터그램(UDP 패킷)의 양쪽이 가능하게 됩니다.
사용하는 시스템에 보다 한층 의존하게 될지 모릅니다.

=begin original

The Perl function calls for dealing with sockets have the same names as
the corresponding system calls in C, but their arguments tend to differ
for two reasons: first, Perl filehandles work differently than C file
descriptors.  Second, Perl already knows the length of its strings, so you
don't need to pass that information.

=end original

소켓을 사용하기 위한 Perl 의 함수호출은 대응하는 C 에서의 시스템 호출과 같은 이름을 
가지고 있습니다.
그러나, 인수에 과냏서는 두가지 이유에 의해 다른 것으로 되어 있습니다:
첫번째로 Perl 의 파일핸들은 C 의 파일 기술자와는 다른 움직임을 한다는 것입니다.
두번째로, Perl 은 이미 문자열의 길이를 알고 있기 때문에, 그 정보를 건넬 
필요가 없다는 것입니다.

=begin original

One of the major problems with old socket code in Perl was that it used
hard-coded values for some of the constants, which severely hurt
portability.  If you ever see code that does anything like explicitly
setting C<$AF_INET = 2>, you know you're in for big trouble:  An
immeasurably superior approach is to use the C<Socket> module, which more
reliably grants access to various constants and functions you'll need.

=end original

Perl 에 있어서 옛 소켓 프로그램에 관한 큰 문제란, 일부의 정수의 값으로써(낮은 이식성을 손해보더라도)
하드코드된 것이 사용되었다는 것입니다.
C<$AF_INET = 2> 처럼 뭔가 설정하는 프로그램을 본 일이 있다면, 
당신은 그것이 큰 문제가 될거라는 것을 알고 계시겠죠:
보다 우수한 방법은 C<Socket> 모듈을 사용하는 것입니다.
이것은 당신이 필요로 할 여러가지 정수나 함수에 대한 보다 신뢰있는 접근을 제공합니다.

=begin original

If you're not writing a server/client for an existing protocol like
NNTP or SMTP, you should give some thought to how your server will
know when the client has finished talking, and vice-versa.  Most
protocols are based on one-line messages and responses (so one party
knows the other has finished when a "\n" is received) or multi-line
messages and responses that end with a period on an empty line
("\n.\n" terminates a message/response).

=end original

NNTP 나 SMTP 처럼 이미 존재하는 프로토콜을 위해 서버/클라이언트를 쓰는 것이 아니라면, 
당신이 만드는 서버가 어떻게해서 클라이언트가 통화를 끝낼 때를 알거나, 그 반응을 아는 가 
하는 것을 생각해봐야할 겁니다.
대부분의 프로토콜은 한줄의 메시지와 응답(단방향 프로세스는 "¥n" 을 받는 때에도 
다른 하나의 프로세스에서의 처리가 끝난 것을 압니다)이나, 빈줄에 놓인 빌리어드로 
종단되는("¥n.¥n" 이 메시지/응답을 종단하는) 몇줄의 메시지와 응답에 기반합니다.

=head2 Internet Line Terminators

(인터넷의 행단말자)

=begin original

The Internet line terminator is "\015\012".  Under ASCII variants of
Unix, that could usually be written as "\r\n", but under other systems,
"\r\n" might at times be "\015\015\012", "\012\012\015", or something
completely different.  The standards specify writing "\015\012" to be
conformant (be strict in what you provide), but they also recommend
accepting a lone "\012" on input (but be lenient in what you require).
We haven't always been very good about that in the code in this manpage,
but unless you're on a Mac, you'll probably be ok.

=end original

인터넷에서의 행종단자는 "¥015¥012" 입니다. 
UNIX 에서 사용되는 ASCII 의 배리에이션에서는 보통은 "¥r¥n"처럼  기술하지만,
다른 시스템에서는 "¥r¥n" 은 "¥015¥015¥012" 거니, 
"¥012¥012¥015" 이거나 혹은 전혀 다른 것이거나 합니다.
"¥015¥012"는 표준적인 쓰기방법(당신이 쓴대로 입니다)이지만, 
입력중에 어느 독립한  "¥012"를 받는 것도 추천됩니다.
이 매뉴얼 페이지에 있는 프로그램에 대해서, 항상 최선의 것을 
사용하고 있지는 않지만, 당신이 Mac 을 사용하고 있지 않다면 
신경쓸 일은 없을 겁니다.

=head2 Internet TCP Clients and Servers

(인터넷의 TCP 클라이언트와 서버)

=begin original

Use Internet-domain sockets when you want to do client-server
communication that might extend to machines outside of your own system.

=end original

자신이 사용하는 시스템의 바깥쪽에 있는 머신에게 클라이언트-서버 통신을 
넓히고 싶은 경우에는 Internet-domain 소켓을 사용합니다.

=begin original

Here's a sample TCP client using Internet-domain sockets:

=end original

아래의 프로그램은 Internet-domain 소켓을 사용한 TCP 클라이언트의 예제입니다:

    #!/usr/bin/perl -w
    use strict;
    use Socket;
    my ($remote,$port, $iaddr, $paddr, $proto, $line);

    $remote  = shift || 'localhost';
    $port    = shift || 2345;  # random port
    if ($port =~ /\D/) { $port = getservbyname($port, 'tcp') }
    die "No port" unless $port;
    $iaddr   = inet_aton($remote) 		|| die "no host: $remote";
    $paddr   = sockaddr_in($port, $iaddr);

    $proto   = getprotobyname('tcp');
    socket(SOCK, PF_INET, SOCK_STREAM, $proto)	|| die "socket: $!";
    connect(SOCK, $paddr)    || die "connect: $!";
    while (defined($line = <SOCK>)) {
	print $line;
    }

    close (SOCK)	    || die "close: $!";
    exit;

=begin original

And here's a corresponding server to go along with it.  We'll
leave the address as INADDR_ANY so that the kernel can choose
the appropriate interface on multihomed hosts.  If you want sit
on a particular interface (like the external side of a gateway
or firewall machine), you should fill this in with your real address
instead.

=end original

그리고 아래에 예를 든 것이 위의 클라이언트와 대응하는 서버입니다.
여기에서는 주소를 INADDR_ANY 라고 하고 있기 때문에, 커널은 multihomed hosts 
상의 적절한 인터페이스를 선택할 수 있습니다.
(방화벽이나 게이트웨이의 바깥쪽처럼) 특정의 인터페이스를 사용하고 싶다면, 
이 부분을 자신이 사용하고 싶은 진짜 주소로 채워넣어야 합니다.

    #!/usr/bin/perl -Tw
    use strict;
    BEGIN { $ENV{PATH} = '/usr/ucb:/bin' }
    use Socket;
    use Carp;
    my $EOL = "\015\012";

    sub logmsg { print "$0 $$: @_ at ", scalar localtime, "\n" }

    my $port = shift || 2345;
    my $proto = getprotobyname('tcp');

    ($port) = $port =~ /^(\d+)$/                        or die "invalid port";

    socket(Server, PF_INET, SOCK_STREAM, $proto)	|| die "socket: $!";
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR,
					pack("l", 1)) 	|| die "setsockopt: $!";
    bind(Server, sockaddr_in($port, INADDR_ANY))	|| die "bind: $!";
    listen(Server,SOMAXCONN) 				|| die "listen: $!";

    logmsg "server started on port $port";

    my $paddr;

    $SIG{CHLD} = \&REAPER;

    for ( ; $paddr = accept(Client,Server); close Client) {
	my($port,$iaddr) = sockaddr_in($paddr);
	my $name = gethostbyaddr($iaddr,AF_INET);

	logmsg "connection from $name [",
		inet_ntoa($iaddr), "]
		at port $port";

	print Client "Hello there, $name, it's now ",
			scalar localtime, $EOL;
    }

=begin original

And here's a multithreaded version.  It's multithreaded in that
like most typical servers, it spawns (forks) a slave server to
handle the client request so that the master server can quickly
go back to service a new client.

=end original

아래의 예제는 멀티스레드 버젼입니다.
이것은 대부분의 전형적인 서버가 그렇듯이 멀티스레드가 되고, 
클라이언트의 리퀘스트를 처리하기 위해 슬레이브서버를 spawn(fork) 합니다.
이 때문에, 마스터 서버는 새로운 클라이언트에 대해서 서비스하기 위해 
즉시 복귀할 수 있습니다.

    #!/usr/bin/perl -Tw
    use strict;
    BEGIN { $ENV{PATH} = '/usr/ucb:/bin' }
    use Socket;
    use Carp;
    my $EOL = "\015\012";

    sub spawn;  # forward declaration
    sub logmsg { print "$0 $$: @_ at ", scalar localtime, "\n" }

    my $port = shift || 2345;
    my $proto = getprotobyname('tcp');

    ($port) = $port =~ /^(\d+)$/                        or die "invalid port";

    socket(Server, PF_INET, SOCK_STREAM, $proto)	|| die "socket: $!";
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR,
					pack("l", 1)) 	|| die "setsockopt: $!";
    bind(Server, sockaddr_in($port, INADDR_ANY))	|| die "bind: $!";
    listen(Server,SOMAXCONN) 				|| die "listen: $!";

    logmsg "server started on port $port";

    my $waitedpid = 0;
    my $paddr;

    use POSIX ":sys_wait_h";
    use Errno;

    sub REAPER {
        local $!;   # don't let waitpid() overwrite current error
        while ((my $pid = waitpid(-1,WNOHANG)) > 0 && WIFEXITED($?)) {
            logmsg "reaped $waitedpid" . ($? ? " with exit $?" : '');
        }
        $SIG{CHLD} = \&REAPER;  # loathe sysV
    }

    $SIG{CHLD} = \&REAPER;

    while(1) {
        $paddr = accept(Client, Server) || do {
            # try again if accept() returned because a signal was received
            next if $!{EINTR};
            die "accept: $!";
        };
        my ($port, $iaddr) = sockaddr_in($paddr);
        my $name = gethostbyaddr($iaddr, AF_INET);

        logmsg "connection from $name [",
               inet_ntoa($iaddr),
               "] at port $port";

        spawn sub {
            $|=1;
            print "Hello there, $name, it's now ", scalar localtime, $EOL;
            exec '/usr/games/fortune'       # XXX: `wrong' line terminators
                or confess "can't exec fortune: $!";
        };
        close Client;
    }

    sub spawn {
        my $coderef = shift;

        unless (@_ == 0 && $coderef && ref($coderef) eq 'CODE') {
            confess "usage: spawn CODEREF";
        }

        my $pid;
        if (! defined($pid = fork)) {
            logmsg "cannot fork: $!";
            return;
        } 
        elsif ($pid) {
            logmsg "begat $pid";
            return; # I'm the parent
        }
        # else I'm the child -- go spawn

        open(STDIN,  "<&Client")   || die "can't dup client to stdin";
        open(STDOUT, ">&Client")   || die "can't dup client to stdout";
        ## open(STDERR, ">&STDOUT") || die "can't dup stdout to stderr";
        exit &$coderef();
    }

=begin original

This server takes the trouble to clone off a child version via fork()
for each incoming request.  That way it can handle many requests at
once, which you might not always want.  Even if you don't fork(), the
listen() will allow that many pending connections.  Forking servers
have to be particularly careful about cleaning up their dead children
(called "zombies" in Unix parlance), because otherwise you'll quickly
fill up your process table.  The REAPER subroutine is used here to
call waitpid() for any child processes that have finished, thereby
ensuring that they terminate cleanly and don't join the ranks of the
living dead.

=end original

이 서버는 리퀘스트가 올 때마다 fork() 를 사용해서 자식 버젼의 복제를 수행하기 때문에,
문제를 제외합니다.
이 방법은, 당신이 항상 원하는 것이 아닐지도 모르겠지만, 한번에 많은 
리퀘스트를 처리할 수 있습니다.
fork() 를 사용하지 않았다고 해도, listen() 은 많은 일시정지한 커넥션(
pending connections) 를 다룹니다.
서버를 fork 하기 때문에, 죽은 자식(UNIX 세계에서는 좀비라고 부르는 것)의 
뒷처리에 관해서 주의깊게 대할 필요가 있습니다.
왜냐면 그렇게 하지 않으면 프로세스 테이블이 즉시 채워지기때문입니다.
여기에서 REAPER 서브루틴은 종료한 모든 자식 프로세스를 위해서 
waitpid() 를 호출하기 위해 사용되고, 따라서 자식 프로ㅔ쓰가 깔끔하게 종료하고
좀비 집단에 참가하지 않는 다는 것을 확실하게 합니다.

=begin original

Within the while loop we call accept() and check to see if it returns
a false value.  This would normally indicate a system error that needs
to be reported.  However the introduction of safe signals (see
L</Deferred Signals (Safe Signals)> above) in Perl 5.7.3 means that
accept() may also be interrupted when the process receives a signal.
This typically happens when one of the forked sub-processes exits and
notifies the parent process with a CHLD signal.  

=end original

while 루프 안에서 accept() 를 호출해서, 거짓 값을 반환하는 지 어떤지를 체크합니다.
이것은 보통 보고하는 필요가 있는 시스템 에러를 나타냅니다.
그러나, Perl 5.7.3 에서 도입된 안전한 시그널(위의 
L</Deferred Signals (Safe Signals)> 을 참조해주세요)의 도입은, 
프로세스가 시그널을 수신한 경우에도 accept() 가 중단되는 것을 의미합니다.
이것은 전형적으로는 fork 한 자식 프로세스의 하나가 종료해서, 부모 프로세스에 
CHLD 시그널에 통지한  경우에 일어납니다.

=begin original

If accept() is interrupted by a signal then $! will be set to EINTR.
If this happens then we can safely continue to the next iteration of
the loop and another call to accept().  It is important that your
signal handling code doesn't modify the value of $! or this test will
most likely fail.  In the REAPER subroutine we create a local version
of $! before calling waitpid().  When waitpid() sets $! to ECHILD (as
it inevitably does when it has no more children waiting), it will
update the local copy leaving the original unchanged.

=end original

만약 accept() 가 시그널에서 중단되면, $! 에 EINTR 이 정의됩니다.
이것이 일어난 경우, 다음의 반복과 다음의 accept() 의 호출을 안전하게 속행할 수 있습니다.
시그널핸들러 코드가 $! 을 변경하지 않도록 하면, 이 테스트가 거의 확실하게 
실패한다는 것은 중요합니다.
REAPER 서브루틴에서는 waitpid() 를 호출하기 전에 로컬 판의 $! 을 작성하고 있습니다.
waitpid() 가 $! 에 ECHILD 를 설정하면(이것은 어느 프로세스도 가지고 있지 않을 때에 
필연적으로 발생합니다), 이것은 원래의 값을 변경하지 않고, 로컬한 복사를 갱신합니다.

=begin original

We suggest that you use the B<-T> flag to use taint checking (see L<perlsec>)
even if we aren't running setuid or setgid.  This is always a good idea
for servers and other programs run on behalf of someone else (like CGI
scripts), because it lessens the chances that people from the outside will
be able to compromise your system.

=end original

setuid 나 setgid 되지 않은 상태에서 실행된다고 해도, 오염검사 
(L<perlsec> 를 참조)를 하기 위해 B<-T> 플래그를 사용하는 것을 추천합니다.
이것은 서버나 그 외의 다른 누군가를 위해 실행되는 (CGI 스크립트 같은)
프로그램에 대해서는 항상 좋은 방안이 됩니다.
왜냐면 그렇게 함에 따라 외부사람이 당신의 시스템에 들어올 수 있는 가능성을 
줄일 수 있기 때문입니다.

=begin original

Let's look at another TCP client.  This one connects to the TCP "time"
service on a number of different machines and shows how far their clocks
differ from the system on which it's being run:

=end original

다른 하나의 TCP 클라이언트를 보도록 합니다.
이것은 복수의 다른 머신 상의 TCP 의 "time" 서비스에 접속해서 클라이언트가 
달리는 시스템과 시계가 어느정도 다른 가를 출력합니다:

    #!/usr/bin/perl  -w
    use strict;
    use Socket;

    my $SECS_of_70_YEARS = 2208988800;
    sub ctime { scalar localtime(shift) }

    my $iaddr = gethostbyname('localhost');
    my $proto = getprotobyname('tcp');
    my $port = getservbyname('time', 'tcp');
    my $paddr = sockaddr_in(0, $iaddr);
    my($host);

    $| = 1;
    printf "%-24s %8s %s\n",  "localhost", 0, ctime(time());

    foreach $host (@ARGV) {
	printf "%-24s ", $host;
	my $hisiaddr = inet_aton($host)     || die "unknown host";
	my $hispaddr = sockaddr_in($port, $hisiaddr);
	socket(SOCKET, PF_INET, SOCK_STREAM, $proto)   || die "socket: $!";
	connect(SOCKET, $hispaddr)          || die "bind: $!";
	my $rtime = '    ';
	read(SOCKET, $rtime, 4);
	close(SOCKET);
	my $histime = unpack("N", $rtime) - $SECS_of_70_YEARS;
	printf "%8d %s\n", $histime - time, ctime($histime);
    }

=head2 Unix-Domain TCP Clients and Servers

(UNIX ドメインの TCP クライアントとサーバー)

=begin original

That's fine for Internet-domain clients and servers, but what about local
communications?  While you can use the same setup, sometimes you don't
want to.  Unix-domain sockets are local to the current host, and are often
used internally to implement pipes.  Unlike Internet domain sockets, Unix
domain sockets can show up in the file system with an ls(1) listing.

=end original

Internet-domain 의 서버와 클라이언트는 좋은 것이지만, 로컬 커뮤니케이션에 관해서는 
어떨까요?
마찬가지로 셋업할 수 있지만, 이처럼 통신을 수행할 수는 없습니다.
UNIX 도메인 소켓은 커런트 호스트에 로컬에서 가끔 하이픈을 굿ㅇ하기 위해 
내부적으로 사용됩니다.
Internet 도메인 소켓과는 다르게 UNIX 도메인 소켓은 ls(1) 를 사용해서 
파일시스템 안에서 발견할 수 있습니다.

    % ls -l /dev/log
    srw-rw-rw-  1 root            0 Oct 31 07:23 /dev/log

=begin original

You can test for these with Perl's B<-S> file test:

=end original

이것을  Perl 의 파일테스트 B<-S> 를 사용해서 수행할 수 있습니다:

    unless ( -S '/dev/log' ) {
	die "something's wicked with the log system";
    }

=begin original

Here's a sample Unix-domain client:

=end original

UNIX 도메인 클라이언트의 예제입니다:

    #!/usr/bin/perl -w
    use Socket;
    use strict;
    my ($rendezvous, $line);

    $rendezvous = shift || 'catsock';
    socket(SOCK, PF_UNIX, SOCK_STREAM, 0)	|| die "socket: $!";
    connect(SOCK, sockaddr_un($rendezvous))	|| die "connect: $!";
    while (defined($line = <SOCK>)) {
	print $line;
    }
    exit;

=begin original

And here's a corresponding server.  You don't have to worry about silly
network terminators here because Unix domain sockets are guaranteed
to be on the localhost, and thus everything works right.

=end original

그리고 대응하는 서버입니다.
여기에서 당신은 걱정될 네트워크 종단자에 대해서 생각할 필요는 없습니다.
왜냐면, UNIX 의 도메인 소켓은 로컬 호스트에 대해서 완전하게 
만족된 것이어서, 그 때문에 모든 것은 잘 되는 것입니다.

    #!/usr/bin/perl -Tw
    use strict;
    use Socket;
    use Carp;

    BEGIN { $ENV{PATH} = '/usr/ucb:/bin' }
    sub spawn;  # forward declaration
    sub logmsg { print "$0 $$: @_ at ", scalar localtime, "\n" }

    my $NAME = 'catsock';
    my $uaddr = sockaddr_un($NAME);
    my $proto = getprotobyname('tcp');

    socket(Server,PF_UNIX,SOCK_STREAM,0) 	|| die "socket: $!";
    unlink($NAME);
    bind  (Server, $uaddr) 			|| die "bind: $!";
    listen(Server,SOMAXCONN)			|| die "listen: $!";

    logmsg "server started on $NAME";

    my $waitedpid;

    use POSIX ":sys_wait_h";
    sub REAPER {
	my $child;
        while (($waitedpid = waitpid(-1,WNOHANG)) > 0) {
	    logmsg "reaped $waitedpid" . ($? ? " with exit $?" : '');
	}
	$SIG{CHLD} = \&REAPER;  # loathe sysV
    }

    $SIG{CHLD} = \&REAPER;


    for ( $waitedpid = 0;
	  accept(Client,Server) || $waitedpid;
	  $waitedpid = 0, close Client)
    {
	next if $waitedpid;
	logmsg "connection on $NAME";
	spawn sub {
	    print "Hello there, it's now ", scalar localtime, "\n";
	    exec '/usr/games/fortune' or die "can't exec fortune: $!";
	};
    }

    sub spawn {
	my $coderef = shift;

	unless (@_ == 0 && $coderef && ref($coderef) eq 'CODE') {
	    confess "usage: spawn CODEREF";
	}

	my $pid;
	if (!defined($pid = fork)) {
	    logmsg "cannot fork: $!";
	    return;
	} elsif ($pid) {
	    logmsg "begat $pid";
	    return; # I'm the parent
	}
	# else I'm the child -- go spawn

	open(STDIN,  "<&Client")   || die "can't dup client to stdin";
	open(STDOUT, ">&Client")   || die "can't dup client to stdout";
	## open(STDERR, ">&STDOUT") || die "can't dup stdout to stderr";
	exit &$coderef();
    }

=begin original

As you see, it's remarkably similar to the Internet domain TCP server, so
much so, in fact, that we've omitted several duplicate functions--spawn(),
logmsg(), ctime(), and REAPER()--which are exactly the same as in the
other server.

=end original

보면 알듯이, Internet domain TCP 서버와 대부분 같습니다.
실제로는 전혀 바뀌지 않은 몇가지의 중복한 함수 spawn(), 
logmsg(), ctime(), REAPER() 를 빼고 있습니다.

=begin original

So why would you ever want to use a Unix domain socket instead of a
simpler named pipe?  Because a named pipe doesn't give you sessions.  You
can't tell one process's data from another's.  With socket programming,
you get a separate session for each client: that's why accept() takes two
arguments.

=end original

그럼 왜, 단순한 이름붙은 파이프가 아닌 UNIX 도메인 소켓을 사용하고 싶어하는 걸까요?
그 이유는 이름붙은 파이프가 당신에게 세션을 주지 않기 때문입니다.
당신은 어느 프로세스에서 온 데이터와 그것과는 다른 별도의 프로세스에서 온 데이터를 
구별할 수 없습니다.
소켓 프로그래밍을 수행하는 것으로 클라이언트 마다 별도의 세션을 가지게 할 수 있습니다: 이것은 
accept() 가 두가지의 인수를 취하는 이유입니다.

=begin original

For example, let's say that you have a long running database server daemon
that you want folks from the World Wide Web to be able to access, but only
if they go through a CGI interface.  You'd have a small, simple CGI
program that does whatever checks and logging you feel like, and then acts
as a Unix-domain client and connects to your private server.

=end original

예를들면, CGI 인터페이스를 통해서만 World Wide Web 에서 접근하면, 
장시간 실행되는 데이터베이스 서버 데몬을 가지고 있다고 합니다.
이 경우, 당신이 좋을대로 체크나 로그를 기록을 실행하는 작고 단순한 CGI 프로그램을 가지고, 
UNIX 도메인 클라이언트로써 행동하는 프라이베이트한 서버에 접속하게 하는 것이 
가능하겠죠.

=head1 TCP Clients with IO::Socket

(IO::Socket 을 사용한 TCP 클라이언트)

=begin original

For those preferring a higher-level interface to socket programming, the
IO::Socket module provides an object-oriented approach.  IO::Socket is
included as part of the standard Perl distribution as of the 5.004
release.  If you're running an earlier version of Perl, just fetch
IO::Socket from CPAN, where you'll also find modules providing easy
interfaces to the following systems: DNS, FTP, Ident (RFC 931), NIS and
NISPlus, NNTP, Ping, POP3, SMTP, SNMP, SSLeay, Telnet, and Time--just
to name a few.

=end original

소켓 프로그래밍에 대해서 고수준의 인터페이스를 위해서 IO::Socket 모듈은 
오브젝트 지향을 제공합니다.
IO::Socket 모듈은 릴리즈 5.004 의 표준 Perl 배포키트의 일부로써 포함되어 있습니다.
당신이 이전의 버젼의 Perl 을 가지고 있다면, CPAN 에서 IO::Socket 을 입수합니다.
거기에서 아래에 예를 든 것같은 시스템에 대한 단순한 인터페이스를 제공하는 
시스템을 발견할 수 있을 겁니다: DNS, FTP, Ident (RFC 931),
NIS, NISPlus, NNTP, Ping, POP3, SMTP, SNMP, SSLeay, Telnet, Time 등..

=head2 A Simple Client

(단순한 클라이언트)

=begin original

Here's a client that creates a TCP connection to the "daytime"
service at port 13 of the host name "localhost" and prints out everything
that the server there cares to provide.

=end original

아래의 예제는 "localhost" 라는 호스트이름의 13번 포트인 "dyatime" 서비스에 대한 
TCP 커넥션을 작성하는 클라이언트로 그 서버가 제공하는 데이터를 모두 출력합니다.

    #!/usr/bin/perl -w
    use IO::Socket;
    $remote = IO::Socket::INET->new(
			Proto    => "tcp",
			PeerAddr => "localhost",
			PeerPort => "daytime(13)",
		    )
		  or die "cannot connect to daytime port at localhost";
    while ( <$remote> ) { print }

=begin original

When you run this program, you should get something back that
looks like this:

=end original

이 프로그램을 실행하면, 아래처럼 답장이 돌아올 겁니다:

    Wed May 14 08:40:46 MDT 1997

=begin original

Here are what those parameters to the C<new> constructor mean:

=end original

C<new> 생성자에 대한 파라메터의 의미를 설명합니다:

=over 4

=item C<Proto>

=begin original

This is which protocol to use.  In this case, the socket handle returned
will be connected to a TCP socket, because we want a stream-oriented
connection, that is, one that acts pretty much like a plain old file.
Not all sockets are this of this type.  For example, the UDP protocol
can be used to make a datagram socket, used for message-passing.

=end original

이것은 사용하는 프로토콜입니다.
이 예제에서는 우리들은 스트림 지향 연결, 즉, 보통의 파일처럼 행동하는 것을 사용하고 
싶기 때문에, 소켓은 TCP 소켓에 접속된 것을 다룹니다.
소켓에는 이 이외의 타이프도 있다는 것에 주의해주세요.
예를들어, UDP 프로토콜은 (메시지 송신에 사용되는 ) 데이터그램 소켓을 
작성하기 위해 사용할 수 있습니다.

=item C<PeerAddr>

=begin original

This is the name or Internet address of the remote host the server is
running on.  We could have specified a longer name like C<"www.perl.com">,
or an address like C<"204.148.40.9">.  For demonstration purposes, we've
used the special hostname C<"localhost">, which should always mean the
current machine you're running on.  The corresponding Internet address
for localhost is C<"127.1">, if you'd rather use that.

=end original

이것은 서버가 실행되는 리모트 호스트의, 인터넷 주소 혹은 이름입니다.
이것을  C<"www.perl.com"> 처럼 긴 이름으로 지정하는 것도 
C<"204.148.40.9"> 같은 주소로 지정할 수도 있습니다.
앞의 예제에서 사용한 C<"localhost"> 는 항상 자신이 사용하는 현재의 머신을 
의미하는 특별한 호스트이름입니다.
로컬호스트에 대한 인터넷 주소는 C<"127.1"> 에서 이쪽을 사용할 수도 있습니다.

=item C<PeerPort>

=begin original

This is the service name or port number we'd like to connect to.
We could have gotten away with using just C<"daytime"> on systems with a
well-configured system services file,[FOOTNOTE: The system services file
is in I</etc/services> under Unix] but just in case, we've specified the
port number (13) in parentheses.  Using just the number would also have
worked, but constant numbers make careful programmers nervous.

=end original

이것은 접속하고 싶은 서비스의 명칭, 혹은 포트번호입니다.
우리들은 앞의 예제에서 제대로 설정된 시스템 서비스를 사용하는 시스템이라면 
C<"daytime"> 을 사용할 수도 있었습니다
[FOOTNOTE: UNIX에서는 I</etc/services> 에 시스템 서비스 파일이 있습니다].
그러나, 실제로는 괄호로 감싸서 (13) 이라는 포트번호의 지정을 수행했습니다.
단순히 번호를 사용해도 마찬가지로 동작하지만, 정수는 주의깊은 프로그래머를 
신경질나게 해버립니다.

=back

=begin original

Notice how the return value from the C<new> constructor is used as
a filehandle in the C<while> loop?  That's what's called an indirect
filehandle, a scalar variable containing a filehandle.  You can use
it the same way you would a normal filehandle.  For example, you
can read one line from it this way:

=end original

생성자 C<new> 의 반환값이 C<while> 루프의 안의 파일 핸들로써 
어떻게 사용되는 가 하는 것을 아시겠ㄴ요?
이것은 간접 파일핸들이라고 부르는 것으로, 파일핸들을 가지고 있는 스칼라 변수입니다.
이것은 통상의 파일핸들과 마찬가지 방법으로 사용할 수 있습니다.
예를들어, 아래처럼 하면 한줄을 읽을 수 있습니다:

    $line = <$handle>;

=begin original

all remaining lines from is this way:

=end original

남은 모든 줄을 읽으려면 다음처럼 합니다:

    @lines = <$handle>;

=begin original

and send a line of data to it this way:

=end original

데이터를 한줄 보내기위해서는 아래처럼 합니다:

    print $handle "some data\n";

=head2 A Webget Client

(Webget 클라이언트)

=begin original

Here's a simple client that takes a remote host to fetch a document
from, and then a list of documents to get from that host.  This is a
more interesting client than the previous one because it first sends
something to the server before fetching the server's response.

=end original

아래의 예제는 문서를 거기에서 얻는 리모트 호스트와, 그 호스트에서 얻는 문서의 리스트를 
인수로 취하는 단순한 클라이언트입니다.
이것은 앞의 예제보다도 흥미 깊은 부분입니다.
왜냐면, 이 예제에 있어서는 서버의 반응을 fetch 하기 전에 최초에 뭔가를 서버에 
송신하기 때문입니다.

    #!/usr/bin/perl -w
    use IO::Socket;
    unless (@ARGV > 1) { die "usage: $0 host document ..." }
    $host = shift(@ARGV);
    $EOL = "\015\012";
    $BLANK = $EOL x 2;
    foreach $document ( @ARGV ) {
	$remote = IO::Socket::INET->new( Proto     => "tcp",
					 PeerAddr  => $host,
					 PeerPort  => "http(80)",
				        );
	unless ($remote) { die "cannot connect to http daemon on $host" }
	$remote->autoflush(1);
	print $remote "GET $document HTTP/1.0" . $BLANK;
	while ( <$remote> ) { print }
	close $remote;
    }

=begin original

The web server handing the "http" service, which is assumed to be at
its standard port, number 80.  If the web server you're trying to
connect to is at a different port (like 1080 or 8080), you should specify
as the named-parameter pair, C<< PeerPort => 8080 >>.  The C<autoflush>
method is used on the socket because otherwise the system would buffer
up the output we sent it.  (If you're on a Mac, you'll also need to
change every C<"\n"> in your code that sends data over the network to
be a C<"\015\012"> instead.)

=end original

여기에서는 "http" 서비스를 제공하는 web 서버가 그 표준 포트인 80번 포트를 사용한다고 
가정하고 있습니다.
당신이 사용하는 web 서버가 다른포트(예를들어 1080 이라든가 8080 이라든가) 를 사용하고 
있다면, 이름붙은 파라메터 페어에 대해서 C<< PeerPort => 8080 >> 처럼 
형식으로 지정해야할 겁니다.
C<autoflush> 메소드가 소켓에 대해서 사용됩니다.
그렇지 않으면, 시스템은 우리들이 송신한 출력을 버퍼링해버리겠죠.
(당신이 Mac 을 사용하고 있다면, 네트워크 넘어에 데이터를 보내는 프로그램안에 
있는 모든 C<"¥n"> 를 C<"¥015¥012"> 로 변경할 필요도 있습니다)

=begin original

Connecting to the server is only the first part of the process: once you
have the connection, you have to use the server's language.  Each server
on the network has its own little command language that it expects as
input.  The string that we send to the server starting with "GET" is in
HTTP syntax.  In this case, we simply request each specified document.
Yes, we really are making a new connection for each document, even though
it's the same host.  That's the way you always used to have to speak HTTP.
Recent versions of web browsers may request that the remote server leave
the connection open a little while, but the server doesn't have to honor
such a request.

=end original

서버로의 접속은 이 프로세스의 최초의 일부뿐입니다:
한번 접속되어버리면, 서버의 언어를 사용해야합니다.
네트워크 상의 각 서버는 입력으로써 기대하고 있는 각각의 작은 커맨드 언어를 가지고 있습니다.
HTTP 구문에 있어서 최초로 서버에 송신하는 것은 "GET" 입니다.
이 경우, 단순히 지정된 문서의 각각을 리퀘스트합니다.
우리들은 실제로는 예를들어, 같은 호스트에 있다고 해도 문서마다 
새로운 커넥션을 작성하고 있습니다.
이것이 HTTP 를 사용할 때에 항상 그렇게 하지 않으면 안되는 방법입니다.
최근의 Web 브라우저에서는 커넥션을 연상태로 조금 리모트 서버를 떠나는 
리퀘스트를 할 수 있지만, 서버는 그런 리퀘스트를 처리하지 않으면 안되는 것은 아닙니다.

=begin original

Here's an example of running that program, which we'll call I<webget>:

=end original

아래에 든 예제는, 우리들이 I<webget> 이라고 부르는 프로그램을 실행한 예제입니다.

    % webget www.perl.com /guanaco.html
    HTTP/1.1 404 File Not Found
    Date: Thu, 08 May 1997 18:02:32 GMT
    Server: Apache/1.2b6
    Connection: close
    Content-type: text/html

    <HEAD><TITLE>404 File Not Found</TITLE></HEAD>
    <BODY><H1>File Not Found</H1>
    The requested URL /guanaco.html was not found on this server.<P>
    </BODY>

=begin original

Ok, so that's not very interesting, because it didn't find that
particular document.  But a long response wouldn't have fit on this page.

=end original

이것은 특정의 문서를 찾지 못했다고 하는 것이기 때문에 그리 재미있는 것도 아닙니다.
그러나 긴 응답을 여기에 적는 것도 아니겠죠.

=begin original

For a more fully-featured version of this program, you should look to
the I<lwp-request> program included with the LWP modules from CPAN.

=end original

이 프로그램의 모든 기능을 사용할 수 있는 버젼은 CPAN 에 있는 
LWP 모둘 안의 I<lwp-request> 라는 프로그램을 보면 좋습니다.

=head2 Interactive Client with IO::Socket

(IO::Socket 을 사용한 대화적 클라이언트)

=begin original

Well, that's all fine if you want to send one command and get one answer,
but what about setting up something fully interactive, somewhat like
the way I<telnet> works?  That way you can type a line, get the answer,
type a line, get the answer, etc.

=end original

하나의 커맨드를 송신해서, 하나의 응답을 얻는다고 하면 모든 것은 좋겠지만, 
완전하게 대화적인 무엇인가를 설정하고 I<telnet> 처럼 동작하는 것은 어떨까요?
여기에서 할 수 있는 것은 ,어떤 한줄을 타이프해서 답을 얻어서, 별도의 줄을 타이프해서 
그것에 대한 답을 얻는... 이런 방법입니다.

=begin original

This client is more complicated than the two we've done so far, but if
you're on a system that supports the powerful C<fork> call, the solution
isn't that rough.  Once you've made the connection to whatever service
you'd like to chat with, call C<fork> to clone your process.  Each of
these two identical process has a very simple job to do: the parent
copies everything from the socket to standard output, while the child
simultaneously copies everything from standard input to the socket.
To accomplish the same thing using just one process would be I<much>
harder, because it's easier to code two processes to do one thing than it
is to code one process to do two things.  (This keep-it-simple principle
a cornerstones of the Unix philosophy, and good software engineering as
well, which is probably why it's spread to other systems.)

=end original

이 클라이언트는 이미 나온 두가지 예제부터 복잡하지만, 당신이 강력한 
C<fork> 호출을 지원하는 시스템을 사용하고 있다면, 해결책은 거친 것도 아닙니다.
손신하고 싶은 어떤 서비스에 대해서 커넥션을 만들어 버리면, 프로세스의 
복제를 만들기 위해서 C<fork> 를 호출합니다.
그에 의해 두가지 프로세스는 각각, 매우 단순한 잡을 수행합니다:
부모 프로세스는 소켓에서 입력된 모든 것을 표준출력으로 복사해서, 자식 프로세스는 
표준입력을 소켓에 똑같이 복제합니다.
단 하나의 프로세스를 사용한 때에 같은 일을 하는 것은 B<매우> 어렵겠죠.
왜냐면, 두가지 일을 하는 하나의 프로세스를 위한 프로그램보다도 하나의 일을 
수행하는 두가지 프로세스를 위한 프로그램이 간단하기 때문입니다(이 
keep-it-simple 법칙은 UNIX 문화의 주요한 것으로, 좋은 소프트웨어 
엔지니어가 사용하듯, (UNIX 가) 다른 시스템보다도 널리 사용되는 이유일 겁니다).

=begin original

Here's the code:

=end original

프로그램의 예제입니다:

    #!/usr/bin/perl -w
    use strict;
    use IO::Socket;
    my ($host, $port, $kidpid, $handle, $line);

    unless (@ARGV == 2) { die "usage: $0 host port" }
    ($host, $port) = @ARGV;

    # create a tcp connection to the specified host and port
    $handle = IO::Socket::INET->new(Proto     => "tcp",
				    PeerAddr  => $host,
				    PeerPort  => $port)
	   or die "can't connect to port $port on $host: $!";

    $handle->autoflush(1);		# so output gets there right away
    print STDERR "[Connected to $host:$port]\n";

    # split the program into two processes, identical twins
    die "can't fork: $!" unless defined($kidpid = fork());

    # the if{} block runs only in the parent process
    if ($kidpid) {
	# copy the socket to standard output
	while (defined ($line = <$handle>)) {
	    print STDOUT $line;
	}
	kill("TERM", $kidpid);  		# send SIGTERM to child
    }
    # the else{} block runs only in the child process
    else {
	# copy standard input to the socket
	while (defined ($line = <STDIN>)) {
	    print $handle $line;
	}
    }

=begin original

The C<kill> function in the parent's C<if> block is there to send a
signal to our child process (current running in the C<else> block)
as soon as the remote server has closed its end of the connection.

=end original

부모 프로세스의 C<if> 블록에 있는 C<kill> 함수는 리모트 서버가 커넥션을 종료해서 
클로즈해서 곧장 자식 프로세스(C<else> 블록을 실행하고 있습니다) 에 시그널을 
보내기 위한 것입니다.

=begin original

If the remote server sends data a byte at time, and you need that
data immediately without waiting for a newline (which might not happen),
you may wish to replace the C<while> loop in the parent with the
following:

=end original

리모트 서버가 한번에 1바이트 보내고, 당신이 개행을 기다리는 일 없이 
즉시 데이터를 필요로 한다면 C<while> 루프를 아래와 같은 것으로 
바꾸고 싶겠죠:

    my $byte;
    while (sysread($handle, $byte, 1) == 1) {
	print STDOUT $byte;
    }

=begin original

Making a system call for each byte you want to read is not very efficient
(to put it mildly) but is the simplest to explain and works reasonably
well.

=end original

읽어내기 위해서 1바이트마다 시스템 콜을 수행하는 것은 비효율적입니다만, 
설명하기 간단하게 우선은 움직이는 것입니다;

=head1 TCP Servers with IO::Socket

(IO::Socket 을 사용한 TCP 서버)

=begin original

As always, setting up a server is little bit more involved than running a client.
The model is that the server creates a special kind of socket that
does nothing but listen on a particular port for incoming connections.
It does this by calling the C<< IO::Socket::INET->new() >> method with
slightly different arguments than the client did.

=end original

항상 그렇듯, 서버의 세팅은 클라이언트를 실행하는 것보다도 정말 조금 더 수고를 해야합니다.
여기에서 사용하는 것은 서버가 특정 포트로 접속을 기다리는 것만이라는 특수한 종류의 
소켓을 작성하는 모델입니다.
이것은 C<< IO::Socket::INET->new() >> 이라는 메소드를 제대로 다른 인수를 붙여서 
호출하고나서 클라이언트를 실행하는 것으로 수행합니다.

=over 4

=item Proto

=begin original

This is which protocol to use.  Like our clients, we'll
still specify C<"tcp"> here.

=end original

이것은 사용하는 프로토콜입니다.
클라이언트와 마찬가지로 여기에서는 C<"tcp"> 를 지정합니다.

=item LocalPort

=begin original

We specify a local
port in the C<LocalPort> argument, which we didn't do for the client.
This is service name or port number for which you want to be the
server. (Under Unix, ports under 1024 are restricted to the
superuser.)  In our sample, we'll use port 9000, but you can use
any port that's not currently in use on your system.  If you try
to use one already in used, you'll get an "Address already in use"
message.  Under Unix, the C<netstat -a> command will show
which services current have servers.

=end original

C<LocalPort> 인수로 로컬 포트를 지정합니다.
이것은 서버에 하고 싶은 서비스 이름이나 포트번호 중 어느 것입니다(UNIX 에서는, 
1024 미만의 포트는 수퍼유저 한정입니다). 
우리들의 샘플에서는 9000번 포트를 사용하지만, 당신이 사용하는 시스템에서 
중복하지 않는다면 좋은 번호를 사용할 수 있스니다.
만약 이미 사용되는 포트를 사용하려고 하면 "Address already in use" 라는 
메시지를 보게 될겁니디.
UNIX 에서는 C<netstat -a> 커맨드를 사용해서 서비스가 현재 사용하는 서버를 
볼 수 있습니다.

=item Listen

=begin original

The C<Listen> parameter is set to the maximum number of
pending connections we can accept until we turn away incoming clients.
Think of it as a call-waiting queue for your telephone.
The low-level Socket module has a special symbol for the system maximum, which
is SOMAXCONN.

=end original

C<Listen> 파라메터는 클라이언트를 기다리게 해서 받아들일 수 있는 커넥션의 최대수를 설정합니다.
전화의 호출을 생각해주세요.
저수준의 소켓 무듈은 SOMAXCONN 이라는 그 시스템의 최대값을 나타내는 특수한 
심볼을 가지고 있습니다.

=item Reuse

=begin original

The C<Reuse> parameter is needed so that we restart our server
manually without waiting a few minutes to allow system buffers to
clear out.

=end original

C<Reuse> 파라메터는 ㅣ쓰템이 버퍼를 클리어하기 위한 시간을 
걸리지 않고 우리들의 서버를 수작업으로 재기동하는 것에 필요합니다.

=back

=begin original

Once the generic server socket has been created using the parameters
listed above, the server then waits for a new client to connect
to it.  The server blocks in the C<accept> method, which eventually accepts a
bidirectional connection from the remote client.  (Make sure to autoflush
this handle to circumvent buffering.)

=end original
위에 기술한 파라메터를 가진 범용 서버 소켓이 생성되면, 그 서버는 접속되는 새로운 클라이언트를 기다립니다.
C<accept> 메소드에 있는 서버 블록은 리모트 클라이언트에서의 쌍방향접속을 허가합니다
(버퍼링을 제어하기 위해서 핸들에 대해서 autoflust 하는 것을 잊지 마세요).

=begin original

To add to user-friendliness, our server prompts the user for commands.
Most servers don't do this.  Because of the prompt without a newline,
you'll have to use the C<sysread> variant of the interactive client above.

=end original

유저에게 친절하게 하기 위해, 우리들의 서버는 커맨드의 입력의 프롬프트를 나타냅니다.
대부분의 서버는 이런 일을 하지 않습니다.
프롬프트에는 개행이 없기 때문에, 위의 예제에 있는 대화적인 
클라이언트 류에서는 C<sysread> 를 사용할 필요가 있을 겁니다.

=begin original

This server accepts one of five different commands, sending output
back to the client.  Note that unlike most network servers, this one
only handles one incoming client at a time.  Multithreaded servers are
covered in Chapter 6 of the Camel.

=end original

이 서버는 다섯종류의 커맨드중 하나를 취해서, 클라이언트에 대해서 
(커맨드에 따른) 출력을 수행합니다.
많은 네트워크 서버와는 다르게, 이 서버 프로그램은 한번에 하나의 클라이언트밖에 
다룰 수 없다는 것에 주의해주세요.
멀티스레드화된 서버는 낙타책의 제6장에서 다루고 있습니다.

=begin original

Here's the code.  We'll

=end original

아래의 프로그램입니다.

 #!/usr/bin/perl -w
 use IO::Socket;
 use Net::hostent;		# for OO version of gethostbyaddr

 $PORT = 9000;			# pick something not in use

 $server = IO::Socket::INET->new( Proto     => 'tcp',
                                  LocalPort => $PORT,
                                  Listen    => SOMAXCONN,
                                  Reuse     => 1);

 die "can't setup server" unless $server;
 print "[Server $0 accepting clients]\n";

 while ($client = $server->accept()) {
   $client->autoflush(1);
   print $client "Welcome to $0; type help for command list.\n";
   $hostinfo = gethostbyaddr($client->peeraddr);
   printf "[Connect from %s]\n", $hostinfo ? $hostinfo->name : $client->peerhost;
   print $client "Command? ";
   while ( <$client>) {
     next unless /\S/;	     # blank line
     if    (/quit|exit/i)    { last;                                     }
     elsif (/date|time/i)    { printf $client "%s\n", scalar localtime;  }
     elsif (/who/i )         { print  $client `who 2>&1`;                }
     elsif (/cookie/i )      { print  $client `/usr/games/fortune 2>&1`; }
     elsif (/motd/i )        { print  $client `cat /etc/motd 2>&1`;      }
     else {
       print $client "Commands: quit date who cookie motd\n";
     }
   } continue {
      print $client "Command? ";
   }
   close $client;
 }

=head1 UDP: Message Passing

(UDP: 메시지 송신)

=begin original

Another kind of client-server setup is one that uses not connections, but
messages.  UDP communications involve much lower overhead but also provide
less reliability, as there are no promises that messages will arrive at
all, let alone in order and unmangled.  Still, UDP offers some advantages
over TCP, including being able to "broadcast" or "multicast" to a whole
bunch of destination hosts at once (usually on your local subnet).  If you
find yourself overly concerned about reliability and start building checks
into your message system, then you probably should use just TCP to start
with.

=end original

클라이언트, 서버를 섹업하는 다른 하나의 종류는 커넥션이 아니라 메시지를 사용하는 것입니다.
UDP 통신은 오버헤드가 낮고, 메시지가 모두 도착한다는 보증이 없이 도착의 순서도 
제대로 지켜주는 것도 보증되지 않기 때문에 신뢰성이 떨어집니다.
그래도 UDP 에는 한번에 송신호스트의 덩어리 전체
(보통은 로컬서브넷)에 대해서 "브로드캐스트", "멀티캐스트" 가 가능하다는 것을 포함해서,
TCP 에 대한 몇가지의 이점이 있습니다.
신뢰성에 관해서는 과도하게 관심을 가지고, 작성하는 메시지 시스템에 검사기능을 
집어넣으려고 한다면 오히려 TCP 를 사용하는 편이 좋겠죠.

=begin original

Note that UDP datagrams are I<not> a bytestream and should not be treated
as such. This makes using I/O mechanisms with internal buffering
like stdio (i.e. print() and friends) especially cumbersome. Use syswrite(),
or better send(), like in the example below.

=end original

UDP 는 바이트스트림이 I<아니고>, 그렇게 다뤄야 하는 것도 아닙니다.
이것은 stdio(즉 print() 나 그 친척) 처럼 내부 버퍼링이 붙은 I/O 기능을 특히 
다루기 어렵습니다.
아래의 예제처럼, syswrite() 나, 보다 좋은 send() 를 사용해주세요.

=begin original

Here's a UDP program similar to the sample Internet TCP client given
earlier.  However, instead of checking one host at a time, the UDP version
will check many of them asynchronously by simulating a multicast and then
using select() to do a timed-out wait for I/O.  To do something similar
with TCP, you'd have to use a different socket handle for each host.

=end original

아래에 예를 든 UDP 프로그램은 앞에 예를든 인터넷 TCP 클라이언트의 예제와 비슷하지만,
한번에 하나의 호스트를 체크하는 것이 아니라, 멀티캐스트를 시뮬레이트하고, 
select() 를 입출력의 타임아웃대기를 위해 사용하는 것에 의해 비동기적으로 많은 
체크를 수행합니다.
TCP 에서 이것과 같은 일을 하려면 호스트마다 다른 소켓 핸들을 사용하지 않으면 안되겠죠?

    #!/usr/bin/perl -w
    use strict;
    use Socket;
    use Sys::Hostname;

    my ( $count, $hisiaddr, $hispaddr, $histime,
	 $host, $iaddr, $paddr, $port, $proto,
	 $rin, $rout, $rtime, $SECS_of_70_YEARS);

    $SECS_of_70_YEARS      = 2208988800;

    $iaddr = gethostbyname(hostname());
    $proto = getprotobyname('udp');
    $port = getservbyname('time', 'udp');
    $paddr = sockaddr_in(0, $iaddr); # 0 means let kernel pick

    socket(SOCKET, PF_INET, SOCK_DGRAM, $proto)   || die "socket: $!";
    bind(SOCKET, $paddr)                          || die "bind: $!";

    $| = 1;
    printf "%-12s %8s %s\n",  "localhost", 0, scalar localtime time;
    $count = 0;
    for $host (@ARGV) {
	$count++;
	$hisiaddr = inet_aton($host) 	|| die "unknown host";
	$hispaddr = sockaddr_in($port, $hisiaddr);
	defined(send(SOCKET, 0, 0, $hispaddr))    || die "send $host: $!";
    }

    $rin = '';
    vec($rin, fileno(SOCKET), 1) = 1;

    # timeout after 10.0 seconds
    while ($count && select($rout = $rin, undef, undef, 10.0)) {
	$rtime = '';
	($hispaddr = recv(SOCKET, $rtime, 4, 0)) 	|| die "recv: $!";
	($port, $hisiaddr) = sockaddr_in($hispaddr);
	$host = gethostbyaddr($hisiaddr, AF_INET);
	$histime = unpack("N", $rtime) - $SECS_of_70_YEARS;
	printf "%-12s ", $host;
	printf "%8d %s\n", $histime - time, scalar localtime($histime);
	$count--;
    }

=begin original

Note that this example does not include any retries and may consequently
fail to contact a reachable host. The most prominent reason for this
is congestion of the queues on the sending host if the number of
list of hosts to contact is sufficiently large.

=end original

이 예제에서는 절대 다시 시험하지 않기 때문에, 도달가능한 호스트로의 접속에 실패하는 
일이 있다는 것에 주의해주세요.
이것의 제일 유명한 원인은, 만약 접속하는 호스트의 리스트 수가 충분히 크면,
송신호스트의 큐가 혼잡하다는 것입니다.

=head1 SysV IPC

=begin original

While System V IPC isn't so widely used as sockets, it still has some
interesting uses.  You can't, however, effectively use SysV IPC or
Berkeley mmap() to have shared memory so as to share a variable amongst
several processes.  That's because Perl would reallocate your string when
you weren't wanting it to.

=end original

System V IPC 는 소켓으로써는 그렇게 널리 사용되지 않지만, 
몇가지 흥미깊은 사용법이 있습니다.
단, System V 의 IPC 나 Berkley 의 mmap() 을 (다른 몇가지 프로세스의 사이에서 
변수를 공유하기 위한) 공유 메모리를 가지는 목적을 위해서 
효율 있게 사용할 수는 없습니다.
왜냐면, Perl 이 당신이 원하지 않을 때에 문자열의 재 할당을 해버릴 가능성이 있기 때문입니다.

=begin original

Here's a small example showing shared memory usage.

=end original

공유메모리의 사용법을 표시하는 작은 예제입니다.

    use IPC::SysV qw(IPC_PRIVATE IPC_RMID S_IRUSR S_IWUSR);

    $size = 2000;
    $id = shmget(IPC_PRIVATE, $size, S_IRUSR|S_IWUSR) || die "$!";
    print "shm key $id\n";

    $message = "Message #1";
    shmwrite($id, $message, 0, 60) || die "$!";
    print "wrote: '$message'\n";
    shmread($id, $buff, 0, 60) || die "$!";
    print "read : '$buff'\n";

    # the buffer of shmread is zero-character end-padded.
    substr($buff, index($buff, "\0")) = '';
    print "un" unless $buff eq $message;
    print "swell\n";

    print "deleting shm $id\n";
    shmctl($id, IPC_RMID, 0) || die "$!";

=begin original

Here's an example of a semaphore:

=end original

아래는 세마포어의 예제입니다:

    use IPC::SysV qw(IPC_CREAT);

    $IPC_KEY = 1234;
    $id = semget($IPC_KEY, 10, 0666 | IPC_CREAT ) || die "$!";
    print "shm key $id\n";

=begin original

Put this code in a separate file to be run in more than one process.
Call the file F<take>:

=end original

두가지 이상의 프로세스에서 동작하도록 이 코드를 분할된 파일에 놓습니다.
그 파일을 F<take> 라고 부릅니다:

    # create a semaphore

    $IPC_KEY = 1234;
    $id = semget($IPC_KEY,  0 , 0 );
    die if !defined($id);

    $semnum = 0;
    $semflag = 0;

    # 'take' semaphore
    # wait for semaphore to be zero
    $semop = 0;
    $opstring1 = pack("s!s!s!", $semnum, $semop, $semflag);

    # Increment the semaphore count
    $semop = 1;
    $opstring2 = pack("s!s!s!", $semnum, $semop,  $semflag);
    $opstring = $opstring1 . $opstring2;

    semop($id,$opstring) || die "$!";

=begin original

Put this code in a separate file to be run in more than one process.
Call this file F<give>:

=end original

이 코드를 두가지 이상의 프로세스에서 실행할 수 있도록 별도의 파일에 놓습니다.
이 파일을 F<giv> 라고 부릅니다.

    # 'give' the semaphore
    # run this in the original process and you will see
    # that the second process continues

    $IPC_KEY = 1234;
    $id = semget($IPC_KEY, 0, 0);
    die if !defined($id);

    $semnum = 0;
    $semflag = 0;

    # Decrement the semaphore count
    $semop = -1;
    $opstring = pack("s!s!s!", $semnum, $semop, $semflag);

    semop($id,$opstring) || die "$!";

=begin original

The SysV IPC code above was written long ago, and it's definitely
clunky looking.  For a more modern look, see the IPC::SysV module
which is included with Perl starting from Perl 5.005.

=end original

여기에서 예시한 System V 의 IPC 코드는 확실히 옛날에 쓰여진 것으로 
쓸모없는 것으로 보입니다.
보다 현대적인 것에 대해서는 Perl 5.005 부터 포함된 IPC::SysV 모듈을 참조해주세요.

=begin original

A small example demonstrating SysV message queues:

=end original

SysV 메시지 큐를 예시하는 간단한 예제입니다:

    use IPC::SysV qw(IPC_PRIVATE IPC_RMID IPC_CREAT S_IRUSR S_IWUSR);

    my $id = msgget(IPC_PRIVATE, IPC_CREAT | S_IRUSR | S_IWUSR);

    my $sent = "message";
    my $type_sent = 1234;
    my $rcvd;
    my $type_rcvd;

    if (defined $id) {
        if (msgsnd($id, pack("l! a*", $type_sent, $sent), 0)) {
            if (msgrcv($id, $rcvd, 60, 0, 0)) {
                ($type_rcvd, $rcvd) = unpack("l! a*", $rcvd);
                if ($rcvd eq $sent) {
                    print "okay\n";
                } else {
                    print "not okay\n";
                }
            } else {
                die "# msgrcv failed\n";
            }
        } else {
            die "# msgsnd failed\n";
        }
        msgctl($id, IPC_RMID, 0) || die "# msgctl failed: $!\n";
    } else {
        die "# msgget failed\n";
    }

=head1 NOTES

=begin original

Most of these routines quietly but politely return C<undef> when they
fail instead of causing your program to die right then and there due to
an uncaught exception.  (Actually, some of the new I<Socket> conversion
functions  croak() on bad arguments.)  It is therefore essential to
check return values from these functions.  Always begin your socket
programs this way for optimal success, and don't forget to add B<-T>
taint checking flag to the #! line for servers:

=end original

이 루틴의 대부분은 잘 짜여져 있지만, 뭔가 실패한 경우에는 
당신의 프로그램을 종료시키거나 포착되지 않은 예외를 일으키는 대신에 
C<undef> 를 반환합니다(실제로는 새로운 
I<Socket> 변환함수의 몇가지는 부정확한 인수에 대해서 croak() 합니다)
따라서 요점은, 이 함수들의 반환값들을 확인해야한다는 것입니다.
소켓 프로그램은 항상 최적의 성공을 위해 이 방법으로 시작하고,
그리고 서버에 대해서 pound-bang line(#! 의 줄을 말함)에 
오염검사 플래그 B<-T> 를 추가하는 것을 잊지 말아주세요.

    #!/usr/bin/perl -Tw
    use strict;
    use sigtrap;
    use Socket;

=head1 BUGS

=begin original

All these routines create system-specific portability problems.  As noted
elsewhere, Perl is at the mercy of your C libraries for much of its system
behaviour.  It's probably safest to assume broken SysV semantics for
signals and to stick with simple TCP and UDP socket operations; e.g., don't
try to pass open file descriptors over a local UDP datagram socket if you
want your code to stand a chance of being portable.

=end original

이 루틴은 모든, 시스템 고유의 이식성 문제를 만들어냅니다.
다른 장소에서 설명했듯이 Perl 의 행동은 사용하는 C 라이브러리에 좌우됩니다.
System V 의 이상한 시그널의 시맨틱스를 가정하는 것과, 단순한 
TCP 와 UDP 소켓 조작에 항상 하는 듯이 하는 일이 아마도 제일 안전한 것이겠죠.
예를들어, 당신이 자신의 프로그램에 이식성을 가지게 하도록 하고 싶다면,
로컬한 UDP 데이터 그램의 소켓을 통해서 파일 기술자를 
건네는 일을 하려고 해서는 안된다는 것입니다.

=head1 AUTHOR

=begin original

Tom Christiansen, with occasional vestiges of Larry Wall's original
version and suggestions from the Perl Porters.

=end original

Tom Christiansen, with occasional vestiges of Larry Wall's original
version and suggestions from the Perl Porters.

=head1 SEE ALSO

=begin original

There's a lot more to networking than this, but this should get you
started.

=end original

네트워크에 관한 사항은 아직 많이 있습니다.
여기에 있는 것은 스타트일 뿐입니다.

=begin original

For intrepid programmers, the indispensable textbook is I<Unix
Network Programming, 2nd Edition, Volume 1> by W. Richard Stevens
(published by Prentice-Hall).  Note that most books on networking
address the subject from the perspective of a C programmer; translation
to Perl is left as an exercise for the reader.

=end original

Richard Stevens 에 의한 꽤 중요한 교과서 
I<Unix Network Programming, 2nd Edition, Volume 1>
(Prentice-Hall 에서 출판되었습니다)가 있습니다.
네트워크에 관한 대부분의 책은 C 프로그래머를 대상으로 하는 점에 주의해주세요.
Perl 로 변환은 독자의 숙제로 남겨두겠습니다.

=begin original

The IO::Socket(3) manpage describes the object library, and the Socket(3)
manpage describes the low-level interface to sockets.  Besides the obvious
functions in L<perlfunc>, you should also check out the F<modules> file
at your nearest CPAN site.  (See L<perlmodlib> or best yet, the F<Perl
FAQ> for a description of what CPAN is and where to get it.)

=end original

IO::Socket(3) 매뉴얼 페이지에는 오브젝트 라이브러리의 설명이 있고,
Socket(3) 에는 저수준의 소켓에 대한 인터페이스의 설명이 있습니다.
L<perlfunc> 에 있는 함수의 외에도 CPAN 사이트에서 F<modules> 파일을 
체크하는 것도 좋을 겁니다(L<perlmodlib> 를 참조하거나 CPAN 이 어디에 있는지 
설명이 있는 F<Perl FAQ> 를 보는 것이 좋을 겁니다).

=begin original

Section 5 of the F<modules> file is devoted to "Networking, Device Control
(modems), and Interprocess Communication", and contains numerous unbundled
modules numerous networking modules, Chat and Expect operations, CGI
programming, DCE, FTP, IPC, NNTP, Proxy, Ptty, RPC, SNMP, SMTP, Telnet,
Threads, and ToolTalk--just to name a few.

=end original

F<modlues> 파일의 제 5장은
"Networking, Device Control (modems), and Interprocess Communication"
를 다루며, 핸들되지 않은 많은 네트워크 관련 무듈, 채트와 Expect operations, CGI 프로그래밍,
DCE, FTP, IPC, NNTP, Proxy, Ptty, RPC, SNMP, SMTP, Telnet, 쓰레드、
그리고 ToolTalk 를 포함하고 있습니다.