
=encoding utf-8

=head1 NAME

=begin original

perllocale - Perl locale handling (internationalization and localization)

=end original

perllocale - Perl 의 로케일 조작(국제화와 지역화)

=head1 DESCRIPTION

=begin original

Perl supports language-specific notions of data such as "is this
a letter", "what is the uppercase equivalent of this letter", and
"which of these letters comes first".  These are important issues,
especially for languages other than English--but also for English: it
would be naE<iuml>ve to imagine that C<A-Za-z> defines all the "letters"
needed to write in English. Perl is also aware that some character other
than '.' may be preferred as a decimal point, and that output date
representations may be language-specific.  The process of making an
application take account of its users' preferences in such matters is
called B<internationalization> (often abbreviated as B<i18n>); telling
such an application about a particular set of preferences is known as
B<localization> (B<l10n>).

=end original

Perl は「これは文字か」、「この文字の大文字はなにか」、「これらの文字のうちで
最初にくるのは何か」のような言語に固有なデータの
概念をサポートしています。
これらは特に英語以外の言語では重要なことです。
が、これは英語でも同様で、C<A-Za-z> がすべての「文字」を
定義していると考えてしまうのは単純すぎる(naE<iuml>ve)考えです。
Perl はまた、“.”以外の幾つかの文字を小数点として扱うことも
ありますし、日付の表現は言語によって変わりうるものです。
アプリケーションにそういったユーザーの選択を考慮させるためのプロセスは、
国際化(B<internationalization>)と呼ばれます(これはしばしば
B<i18n> と省略されます)。
アプリケーションを特定の選択に対応させることは地域化(B<localization>、
B<l10n>)として知られています。

=begin original

Perl can understand language-specific data via the standardized (ISO C,
XPG4, POSIX 1.c) method called "the locale system". The locale system is
controlled per application using one pragma, one function call, and
several environment variables.

=end original

Perl は言語固有なデータを、「ロケールシステム」と呼ばれる標準メソッド
(ISO C, XPG4, POSIX 1.c)を通して理解することができます。
このロケールシステムは一つのプラグマ、一つの関数呼び出し、幾つかの
環境変数を使って、アプリケーション毎に制御します。

=begin original

B<NOTE>: This feature is new in Perl 5.004, and does not apply unless an
application specifically requests it--see L<Backward compatibility>.
The one exception is that write() now B<always> uses the current locale
- see L<"NOTES">.

=end original

B<注意>: この機能は Perl 5.004 で新たに追加されたもので、アプリケーションから
明示的にその使用を要求されない限り使われません -- 
L<Backward compatibility> を参照してください。
一つの例外が write() で、これは B<常に> カレントのロケールを使用します - 
L<"NOTES"> を参照してください。

=head1 PREPARING TO USE LOCALES

(ロケールの使う前の準備)

=begin original

If Perl applications are to understand and present your data
correctly according a locale of your choice, B<all> of the following
must be true:

=end original

Perl アプリケーションが、あなたのデータを、あなたの選択したロケールに
正しく従って理解し提供するのであれば、以下の B<すべて> が真に
なっていなければなりません:

=over 4

=item *

=begin original

B<Your operating system must support the locale system>.  If it does,
you should find that the setlocale() function is a documented part of
its C library.

=end original

B<あなたの使っているオペレーティングシステムがロケールシステムに
対応していなければなりません>。
これに対応していれば、setlocale() という関数が C ライブラリの中に
あるはずです。

=item *

=begin original

B<Definitions for locales that you use must be installed>.  You, or
your system administrator, must make sure that this is the case. The
available locales, the location in which they are kept, and the manner
in which they are installed all vary from system to system.  Some systems
provide only a few, hard-wired locales and do not allow more to be
added.  Others allow you to add "canned" locales provided by the system
supplier.  Still others allow you or the system administrator to define
and add arbitrary locales.  (You may have to ask your supplier to
provide canned locales that are not delivered with your operating
system.)  Read your system documentation for further illumination.

=end original

B<あなたの使うロケールの定義がインストールされていなければなりません>。
あなた、もしくは管理者はこれを正しく取り扱わねばなりません。
使うことのできるロケール、それらが置かれている場所、インストールされる
規則といったものシステム毎に変わります。
一部のシステムでは、固定のほんの少しのロケールだけを提供し、ユーザーが
新たに追加することを許していません。
別のシステムでは、システムのサプライヤーが提供した「準備された」ロケールを
追加することができます(あなたのサプライヤーに使っているオペレーティング
システムと一緒に渡されていない準備されたロケールを提供するよう
依頼する必要があります)。
詳細はシステムのドキュメントを読んでください。

=item *

=begin original

B<Perl must believe that the locale system is supported>.  If it does,
C<perl -V:d_setlocale> will say that the value for C<d_setlocale> is
C<define>.

=end original

B<Perl が、ロケールシステムがサポートされていると信じていなければ
なりません>。
もしそうなっていれば、C<perl -V:d_setlocale> は
C<d_setlocale> の値が定義されているように報告するでしょう。

=back

=begin original

If you want a Perl application to process and present your data
according to a particular locale, the application code should include
the S<C<use locale>> pragma (see L<The use locale pragma>) where
appropriate, and B<at least one> of the following must be true:

=end original

Perl アプリケーションをあなたの使うデータを特定のロケールで処理したり
するようにしたいのであれば、そのアプリケーションコードはプラグマ
S<C<use locale>> を適切な場所に、そして以下に挙げる項目の
B<少なくとも一つ> が真でなければなりません。

=over 4

=item *

=begin original

B<The locale-determining environment variables (see L<"ENVIRONMENT">)
must be correctly set up> at the time the application is started, either
by yourself or by whoever set up your system account.

=end original

あなた自身でやるにしろ、あなたの使うシステムの管理者がするにしろ、
アプリケーションの実行開始時には B<ロケールを決定する環境変数
(L<"ENVIRONMENT"> を参照)が正しく設定されていなければなりません>。

=item *

=begin original

B<The application must set its own locale> using the method described in
L<The setlocale function>.

=end original

アプリケーションは、L<The setlocale function> に記述されている
メソッドを使う、B<自分用のロケールを設定しておかねばなりません>。

=back

=head1 USING LOCALES

(ロケールを使う)

=head2 The use locale pragma

(use locale プラグマ)

=begin original

By default, Perl ignores the current locale.  The S<C<use locale>>
pragma tells Perl to use the current locale for some operations:

=end original

デフォルトでは、Perl はカレントのロケールを無視します。
S<C<use locale>> プラグマは Perl に、幾つかの操作においてカレントの
ロケールを使うよう指示します。

=over 4

=item *

=begin original

B<The comparison operators> (C<lt>, C<le>, C<cmp>, C<ge>, and C<gt>) and
the POSIX string collation functions strcoll() and strxfrm() use
C<LC_COLLATE>.  sort() is also affected if used without an
explicit comparison function, because it uses C<cmp> by default.

=end original

B<比較演算子> (C<lt>, C<le>, C<cmp>, C<ge>, C<gt>) と、POSIX の文字列比較
関数 strcoll() および strxfrm() は C<LC_COLLATE> を使用します。
sort() は比較関数が陽に指定されなかった場合に影響を受けます。
これは、デフォルトでは C<cmp> を使うからです。

=begin original

B<Note:> C<eq> and C<ne> are unaffected by locale: they always
perform a char-by-char comparison of their scalar operands.  What's
more, if C<cmp> finds that its operands are equal according to the
collation sequence specified by the current locale, it goes on to
perform a char-by-char comparison, and only returns I<0> (equal) if the
operands are char-for-char identical.  If you really want to know whether
two strings--which C<eq> and C<cmp> may consider different--are equal
as far as collation in the locale is concerned, see the discussion in
L<Category LC_COLLATE: Collation>.

=end original

B<注意:> C<eq> および C<ne> はロケールの影響を受けません。
これらの関数は常に文字毎の比較をそのスカラオペランドに対して実行します。
それに加えて、C<cmp>はそのオペランドがカレントのロケールで
指定される照合シーケンスで等しいものであった場合、さらに文字毎の
照合を行おうします。
ですから、オペランドの全部の文字が等しい場合にのみ C<cmp> は I<0>(等しい)を
返します。
C<eq> と C<cmp> が異なると判定する可能性のある二つの文字列がロケールを
考慮した照合で等しいかどうかを本当に知りたいのなら、
L<Category LC_COLLATE: Collation> の記述を参照してください。

=item *

=begin original

B<Regular expressions and case-modification functions> (uc(), lc(),
ucfirst(), and lcfirst()) use C<LC_CTYPE>

=end original

B<正規表現と大小文字変換関数> (uc(), lc(), ucfirst(), lcfirst()) は
C<LC_CTYPE> を使用します。

=item *

=begin original

B<The formatting functions> (printf(), sprintf() and write()) use
C<LC_NUMERIC>

=end original

B<書式関数>(printf(), sprintf(), write()) は C<LC_NUMERIC> を使用します。

=item *

=begin original

B<The POSIX date formatting function> (strftime()) uses C<LC_TIME>.

=end original

B<POSIX の日付書式関数> (strfime()) は C<LC_TIME> を使用します。

=back

=begin original

C<LC_COLLATE>, C<LC_CTYPE>, and so on, are discussed further in 
L<LOCALE CATEGORIES>.

=end original

C<LC_COLLATE>, C<LC_CTYPE> などは、L<LOCALE CATEGORIES> でさらに
説明されています。

=begin original

The default behavior is restored with the S<C<no locale>> pragma, or
upon reaching the end of block enclosing C<use locale>.

=end original

S<C<no locale>> に出会うか、(S<C<use locale>> を囲む)ブロックの終端に
達するとデフォルトの動作に戻ります。

=begin original

The string result of any operation that uses locale
information is tainted, as it is possible for a locale to be
untrustworthy.  See L<"SECURITY">.

=end original

ロケール情報を使っている操作の結果である文字列は、ロケールが信頼できない
可能性があるかのように、汚染されていることに注意してください。
L<"SECURITY"> を参照してください。

=head2 The setlocale function

(setlocale 関数)

=begin original

You can switch locales as often as you wish at run time with the
POSIX::setlocale() function:

=end original

POSIX::setlocale() 関数を使って、実行時に好きな回数だけロケールを
切り替えることができます。

        # This functionality not usable prior to Perl 5.004
        require 5.004;

        # Import locale-handling tool set from POSIX module.
        # This example uses: setlocale -- the function call
        #                    LC_CTYPE -- explained below
        use POSIX qw(locale_h);

        # query and save the old locale
        $old_locale = setlocale(LC_CTYPE);

        setlocale(LC_CTYPE, "fr_CA.ISO8859-1");
        # LC_CTYPE now in locale "French, Canada, codeset ISO 8859-1"

        setlocale(LC_CTYPE, "");
        # LC_CTYPE now reset to default defined by LC_ALL/LC_CTYPE/LANG
        # environment variables.  See below for documentation.

        # restore the old locale
        setlocale(LC_CTYPE, $old_locale);

=begin original

The first argument of setlocale() gives the B<category>, the second the
B<locale>.  The category tells in what aspect of data processing you
want to apply locale-specific rules.  Category names are discussed in
L<LOCALE CATEGORIES> and L<"ENVIRONMENT">.  The locale is the name of a
collection of customization information corresponding to a particular
combination of language, country or territory, and codeset.  Read on for
hints on the naming of locales: not all systems name locales as in the
example.

=end original

setlocale() の第一引数には B<カテゴリー> を、第二引数には
B<ロケール> を与えます。
カテゴリーはロケール特有の規則を適用したいデータ処理の状況を指示します。
カテゴリー名は L<LOCALE CATEGORIES> と L<"ENVIRONMENT"> に記述されています。
ロケールはカスタマイズを行うための、特定の言語の組み合わせ、国や地域、
コードセットに関する情報の集合の名前です。
ヒントとしてロケールの名前付けに注目してください。
すべてのシステムがこの例のようにロケールに名前を付けているわけでは
ありません。

=begin original

If no second argument is provided and the category is something else
than LC_ALL, the function returns a string naming the current locale
for the category.  You can use this value as the second argument in a
subsequent call to setlocale().

=end original

第二引数が省略されていて、さらにカテゴリーが LC_ALL 以外の場合、この関数は
カテゴリーに対するカレントロケールの名前からなる文字列を返します。
この値を、後で行う setlocale() の呼び出しでの第二引数として
使うこともできます。

=begin original

If no second argument is provided and the category is LC_ALL, the
result is implementation-dependent.  It may be a string of
concatenated locales names (separator also implementation-dependent)
or a single locale name.  Please consult your setlocale(3) man page for
details.

=end original

カテゴリーが LC_ALL で、第二引数が与えられなかった場合には
その結果は処理系に依存するものとなります。
ロケールの名前を連結したものか(セパレーターはこれまた処理系依存のもの)、
単一のロケール名となります。
詳しくは setlocale(3) man ページをあたってください。

=begin original

If a second argument is given and it corresponds to a valid locale,
the locale for the category is set to that value, and the function
returns the now-current locale value.  You can then use this in yet
another call to setlocale().  (In some implementations, the return
value may sometimes differ from the value you gave as the second
argument--think of it as an alias for the value you gave.)

=end original

第二引数が与えられていて、かつそれが正当なものであれば、カテゴリの
ロケールが設定され、この関数は現在のロケール値を返します。
この値は次の setlocale() に呼び出しで使えます(一部の実装では、この
返り値は第二引数を与えたときと異なる場合があります -- これは与えた引数の
エイリアスと考えられます)。

=begin original

As the example shows, if the second argument is an empty string, the
category's locale is returned to the default specified by the
corresponding environment variables.  Generally, this results in a
return to the default that was in force when Perl started up: changes
to the environment made by the application after startup may or may not
be noticed, depending on your system's C library.

=end original

例に示したように、第二引数が空文字列であった場合にはカテゴリーの、
対応する環境変数によりデフォルト指定されるロケールが返されます。
一般的にはこの結果は、Perl が起動したときに強制的にデフォルトとして
設定された値です。
アプリケーションが起動した後での環境変数の変更が認識される/されないは、
使用している C ライブラリに依存します。

=begin original

If the second argument does not correspond to a valid locale, the locale
for the category is not changed, and the function returns I<undef>.

=end original

第二引数が正しいロケールを表わしていない場合、
カテゴリーに対するロケールは変更されず、関数は I<undef> を返します。

=begin original

For further information about the categories, consult setlocale(3).

=end original

カテゴリーに対する詳細な情報は、setlocale(3) を参照してください。

=head2 Finding locales

(ロケールを見つける)

=begin original

For locales available in your system, consult also setlocale(3) to
see whether it leads to the list of available locales (search for the
I<SEE ALSO> section).  If that fails, try the following command lines:

=end original

ロケールが使えるシステムであれば、使用可能なロケールがどういったもので
あるかどうかを setlocale(3) で調べてみてください
(I<SEE ALSO> の章を探してください)。
それがダメだったら、以下のコマンドを試してみてください。

        locale -a

        nlsinfo

        ls /usr/lib/nls/loc

        ls /usr/lib/locale

        ls /usr/lib/nls

	ls /usr/share/locale

=begin original

and see whether they list something resembling these

=end original

そして、そこに以下に挙げたものと似たものがあるかどうかを
確かめてください。

        en_US.ISO8859-1     de_DE.ISO8859-1     ru_RU.ISO8859-5
        en_US.iso88591      de_DE.iso88591      ru_RU.iso88595
        en_US               de_DE               ru_RU
        en                  de                  ru
        english             german              russian
        english.iso88591    german.iso88591     russian.iso88595
        english.roman8                          russian.koi8r

=begin original

Sadly, even though the calling interface for setlocale() has been
standardized, names of locales and the directories where the
configuration resides have not been.  The basic form of the name is
I<language_territory>B<.>I<codeset>, but the latter parts after
I<language> are not always present.  The I<language> and I<country>
are usually from the standards B<ISO 3166> and B<ISO 639>, the
two-letter abbreviations for the countries and the languages of the
world, respectively.  The I<codeset> part often mentions some B<ISO
8859> character set, the Latin codesets.  For example, C<ISO 8859-1>
is the so-called "Western European codeset" that can be used to encode
most Western European languages adequately.  Again, there are several
ways to write even the name of that one standard.  Lamentably.

=end original

残念ながら、setlocale() を呼び出すインターフェースが既に
標準化されているのにも関らず、ロケールの名前や、それが設定される
ディレクトリはまだなのです。
名前の基本形式は I<language_territory>B<.>I<codeset> ですが、末尾の部分は
常にある訳ではありません。
I<language> と I<country> は通常は B<ISO 3166> や B<ISO 639> という
標準による、言語や国を二文字に略したものになります。
I<codeset> の部分はしばしば文字集合 B<ISO 8859> の
バリエーションとなります。
たとえば、"Western codeset" と呼ばれる C<ISO 8859-1> は西欧における
エンコーディングとして用いることができます。
繰り返しますが、一つの標準の名前であってさえ、記述するには複数の方法が
存在するのです。
嘆かわしいことです。

=begin original

Two special locales are worth particular mention: "C" and "POSIX".
Currently these are effectively the same locale: the difference is
mainly that the first one is defined by the C standard, the second by
the POSIX standard.  They define the B<default locale> in which
every program starts in the absence of locale information in its
environment.  (The I<default> default locale, if you will.)  Its language
is (American) English and its character codeset ASCII.

=end original

“C”と“POSIX”という二つの特殊なロケールがあります。
現時点では、これら二つは同じロケールとなります。
その違いは主に、前者が C の標準により決められたものであるのに対して、
後者が POSIX の標準で決められているものであるという点にあります。
これらの規格が決めていることは、環境変数にあるロケール情報がない状態での
プログラム起動時の B<デフォルトのロケール> です
(I<デフォルトの> デフォルトロケールです)。
その言語は (アメリカ)英語であり、そのキャラクターセットは ASCII となります。

=begin original

B<NOTE>: Not all systems have the "POSIX" locale (not all systems are
POSIX-conformant), so use "C" when you need explicitly to specify this
default locale.

=end original

B<注意>:すべてのシステムが "POSIX" ロケールを持っているわけでは
ありません(すべてのシステムが POSIX に準拠しているわけではありません)ので、
明示的にこのデフォルトロケールを指定するのが必要なときには
"C" を使います。

=head2 LOCALE PROBLEMS

(ロケールの問題)

=begin original

You may encounter the following warning message at Perl startup:

=end original

Perl を実行したときに以下のようなメッセージを見たことがあるかもしれません:

	perl: warning: Setting locale failed.
	perl: warning: Please check that your locale settings:
	        LC_ALL = "En_US",
	        LANG = (unset)
	    are supported and installed on your system.
	perl: warning: Falling back to the standard locale ("C").

=begin original

This means that your locale settings had LC_ALL set to "En_US" and
LANG exists but has no value.  Perl tried to believe you but could not.
Instead, Perl gave up and fell back to the "C" locale, the default locale
that is supposed to work no matter what.  This usually means your locale
settings were wrong, they mention locales your system has never heard
of, or the locale installation in your system has problems (for example,
some system files are broken or missing).  There are quick and temporary
fixes to these problems, as well as more thorough and lasting fixes.

=end original

これは、あなたのロケールの設定が、LC_ALL が“En_US”であり LANG が
存在しているが値を持っていないということを意味します。
Perlはあなたを信じようとしたのですができなかったのです。
その代わりに、Perl はロケール設定をあきらめて、デフォルトである
"C" ロケールに戻ったのです。
これは通常はあなたのロケール設定が間違っているせいであり、聞いたことのない
ロケールであったり、あるいはあなたのインストールに問題があったのだろう
(例えば、一部のシステムファイルが壊れていたとか、なかったとか)と
いうことです。
以下で述べるのは、この問題を手っ取り早く一時的に修復するものです。

=head2 Temporarily fixing locale problems

(一時的にロケールの問題を修正する)

=begin original

The two quickest fixes are either to render Perl silent about any
locale inconsistencies or to run Perl under the default locale "C".

=end original

二つの(一時的な)対応策とは、ロケールに関する矛盾を無視するように
するというものと、Perl をデフォルトロケール "C" で実行するというものです。

=begin original

Perl's moaning about locale problems can be silenced by setting the
environment variable PERL_BADLANG to a zero value, for example "0".
This method really just sweeps the problem under the carpet: you tell
Perl to shut up even when Perl sees that something is wrong.  Do not
be surprised if later something locale-dependent misbehaves.

=end original

Perl 起動時の問題は、環境変数 PERL_BADLANG にゼロ、たとえば
"0" を設定することによって回避できます。
この方法は問題をカーペットの下に押し込むだけのことです:
つまり、Perl が何か間違ったことを見つけたとしても Perl を
黙らせておくというものです。
もし後でロケールに依存した変な振る舞いがあったとしても
驚かないでください。

=begin original

Perl can be run under the "C" locale by setting the environment
variable LC_ALL to "C".  This method is perhaps a bit more civilized
than the PERL_BADLANG approach, but setting LC_ALL (or
other locale variables) may affect other programs as well, not just
Perl.  In particular, external programs run from within Perl will see
these changes.  If you make the new settings permanent (read on), all
programs you run see the changes.  See L<"ENVIRONMENT"> for
the full list of relevant environment variables and L<USING LOCALES>
for their effects in Perl.  Effects in other programs are 
easily deducible.  For example, the variable LC_COLLATE may well affect
your B<sort> program (or whatever the program that arranges "records"
alphabetically in your system is called).

=end original

環境変数 LC_ALL に "C" を設定することにより、Perl はロケール "C" の下でも
実行することができます。
このやり方は PERL_BADLANG よりは多少まともなものですが、それでも
LC_ALL (もしくは他のロケール変数)を設定するということは Perl 以外の
プログラムにも影響を及ぼします。
特に、Perl の内側で実行される外部プログラムはこの変更に影響を
受けることになります。
新しい設定を恒久的なものにしたいというのであれば、あなたが実行する
プログラム全てがこの変更に影響を受けることになります。
関係する環境変数の完全なリストは L<"ENVIRONMENT"> を参照してください。
また、Perl におけるそれらの効果については L<USING LOCALES> を
参照してください。
他のプログラムに対する影響は簡単に避けられます。
たとえば、変数 LC_COLLATE はあなたの B<sort> プログラム
(もしくは「レコード」をアルファベット順に並べ替えるプログラム)に
影響を及ぼします。

=begin original

You can test out changing these variables temporarily, and if the
new settings seem to help, put those settings into your shell startup
files.  Consult your local documentation for the exact details.  For in
Bourne-like shells (B<sh>, B<ksh>, B<bash>, B<zsh>):

=end original

これらの変数に対する変更を一時的に行ってテストすることができます。
そして新しい設定が助けになるものであればその設定をシェルのスタートアップ
ファイルに追加するのです。
詳細はあなたの使っているシステムのドキュメントを調べてみてください。
Bourne シェルに似たシェル(B<sh>, B<ksh>, B<bash>, B<zsh>)であれば
以下のようになります:

	LC_ALL=en_US.ISO8859-1
	export LC_ALL

=begin original

This assumes that we saw the locale "en_US.ISO8859-1" using the commands
discussed above.  We decided to try that instead of the above faulty
locale "En_US"--and in Cshish shells (B<csh>, B<tcsh>)

=end original

これは、コマンドが参照するロケールを "en_US.ISO8859-1" にしています。
Cシェルライクなもの(B<csh>, B<tcsh>)の場合には以下のようになります:

	setenv LC_ALL en_US.ISO8859-1

=begin original

or if you have the "env" application you can do in any shell

=end original

あるいは、"env" プログラムがあるなら、どのようなシェルでも、以下のように
書けます:

	env LC_ALL=en_US.ISO8859-1 perl ...

=begin original

If you do not know what shell you have, consult your local
helpdesk or the equivalent.

=end original

あなたがシェルについて良く知らないというのであれば、
あなたのおそばのヘルプデスク等に訊ねてみてください。

=head2 Permanently fixing locale problems

(ロケールの問題を恒久的に修正する)

=begin original

The slower but superior fixes are when you may be able to yourself
fix the misconfiguration of your own environment variables.  The
mis(sing)configuration of the whole system's locales usually requires
the help of your friendly system administrator.

=end original

時間はかかるけれども優れた修正方法は、あなたの環境の間違っている部分を
正しくするというものです。
システム全体での間違いはあなたの使っているシステムの、フレンドリーな
管理者の助けを必要とするでしょう。

=begin original

First, see earlier in this document about L<Finding locales>.  That tells
how to find which locales are really supported--and more importantly,
installed--on your system.  In our example error message, environment
variables affecting the locale are listed in the order of decreasing
importance (and unset variables do not matter).  Therefore, having
LC_ALL set to "En_US" must have been the bad choice, as shown by the
error message.  First try fixing locale settings listed first.

=end original

まず最初にこのドキュメントの L<Finding locales> を参照してください。
そこにはあなたの使うシステムで実際にサポートされているロケール、
そしてもっと重要なインストールされているロケールを見つけだす方法が
解説されています。
私たちが使ったエラーメッセージの例では、環境変数は重要度の高いものから
低いものへという順になっています。
したがって、LC_ALL を "En_US" に設定することは良くない選択であり、
これはエラーメッセージにも現れています。
まず最初にリストの最初にあるロケール設定を修正します。

=begin original

Second, if using the listed commands you see something B<exactly>
(prefix matches do not count and case usually counts) like "En_US"
without the quotes, then you should be okay because you are using a
locale name that should be installed and available in your system.
In this case, see L<Permanently fixing your system's locale configuration>.

=end original

次に、もしあなたがリストアップのコマンドを使って得たものが
B<正確に> "En_US" のようなもの(接頭辞の一致は考慮せず、大小文字の違いは
考慮します)であれば、あなたが使っているロケール名に対応するものが
システムに正しくインストールされていれば OK です。
この場合、L<Permanently fixing your system's locale configuration> を
参照してください。

=head2 Permanently fixing your system's locale configuration

(あなたのシステムのロケール設定を恒久的に修正する)

=begin original

This is when you see something like:

=end original

これは以下のようなメッセージが出たけれども:

	perl: warning: Please check that your locale settings:
	        LC_ALL = "En_US",
	        LANG = (unset)
	    are supported and installed on your system.

=begin original

but then cannot see that "En_US" listed by the above-mentioned
commands.  You may see things like "en_US.ISO8859-1", but that isn't
the same.  In this case, try running under a locale
that you can list and which somehow matches what you tried.  The
rules for matching locale names are a bit vague because
standardization is weak in this area.  See again the 
L<Finding locales> about general rules.

=end original

"En_US" が先に挙げたコマンドによってリスト中になかった場合です。
"en_US.ISO8859-1" のようなものを見たかも知れませんが、まったく
同一のものではなかったのでしょう。
この場合、コマンドで挙げられたもの一致するロケールで
実行してみてください。
ロケール名のマッチングルールは少々はっきりしないものです。
それは、この分野に関する標準が弱いものであるからです。
一般的なルールについては L<Finding locales> をもう一度見てください。

=head2 Fixing system locale configuration

(システムのロケール設定を修正する)

=begin original

Contact a system administrator (preferably your own) and report the exact
error message you get, and ask them to read this same documentation you
are now reading.  They should be able to check whether there is something
wrong with the locale configuration of the system.  The L<Finding locales>
section is unfortunately a bit vague about the exact commands and places
because these things are not that standardized.

=end original

システム管理者にコンタクトをとって、あなたの得たエラーメッセージそのままを
レポートして、今ここまで読んできたことを説明してください。
システム管理者はシステムのロケール設定についてどこがどう間違っているかを
理解できるはずです。
標準化がなされていないので、コマンド名などに関して L<Finding locales> の
章は残念ながら少々あやふやなものになっています。

=head2 The localeconv function

(localeconv 関数)

=begin original

The POSIX::localeconv() function allows you to get particulars of the
locale-dependent numeric formatting information specified by the current
C<LC_NUMERIC> and C<LC_MONETARY> locales.  (If you just want the name of
the current locale for a particular category, use POSIX::setlocale()
with a single parameter--see L<The setlocale function>.)

=end original

POSIX::localeconv() 関数は、カレントの C<LC_NUMERIC> や C<LC_MONETARY> で
指定されるロケール依存の数値書式の情報を取り出します(ある特定の
カテゴリーのカレントロケールを知りたいだけなのなら、
POSIX::setlocale() を引数一つで使います。
L<The setlocale function> を参照してください)。

        use POSIX qw(locale_h);

        # Get a reference to a hash of locale-dependent info
        $locale_values = localeconv();

        # Output sorted list of the values
        for (sort keys %$locale_values) {
            printf "%-20s = %s\n", $_, $locale_values->{$_}
        }

=begin original

localeconv() takes no arguments, and returns B<a reference to> a hash.
The keys of this hash are variable names for formatting, such as
C<decimal_point> and C<thousands_sep>.  The values are the
corresponding, er, values.  See L<POSIX/localeconv> for a longer
example listing the categories an implementation might be expected to
provide; some provide more and others fewer.  You don't need an
explicit C<use locale>, because localeconv() always observes the
current locale.

=end original

localeconv() は引数を取らず、戻り値としてハッシュに対する
B<リファレンス> を返します。
このハッシュのキーは C<decimal_point> や C<thousands_sep> のように
整形された変数名であり、格納されている値はそのキーに対応する値です。
ある実装が提供しているであろうすべてのカテゴリーをリストアップしている
長いサンプルは L<POSIX/localeconv> を参照してください。
しかしながら、一部のものが多かったり少なかったするかもしれません。
ロケールを問い合わせるジョブの関数のように C<use locale> する必要が
ないことに注意してください。
localeconv() は常にカレントのロケールを監視しています。

=begin original

Here's a simple-minded example program that rewrites its command-line
parameters as integers correctly formatted in the current locale:

=end original

以下の例は、コマンドラインで渡されたパラメーターをカレントのロケールにおける
正しい書式に書きなおすというものです。

        # See comments in previous example
        require 5.004;
        use POSIX qw(locale_h);

        # Get some of locale's numeric formatting parameters
        my ($thousands_sep, $grouping) =
             @{localeconv()}{'thousands_sep', 'grouping'};

        # Apply defaults if values are missing
        $thousands_sep = ',' unless $thousands_sep;

=begin original

	# grouping and mon_grouping are packed lists
	# of small integers (characters) telling the
	# grouping (thousand_seps and mon_thousand_seps
	# being the group dividers) of numbers and
	# monetary quantities.  The integers' meanings:
	# 255 means no more grouping, 0 means repeat
	# the previous grouping, 1-254 means use that
	# as the current grouping.  Grouping goes from
	# right to left (low to high digits).  In the
	# below we cheat slightly by never using anything
	# else than the first grouping (whatever that is).
	if ($grouping) {
	    @grouping = unpack("C*", $grouping);
	} else {
	    @grouping = (3);
	}

=end original

	# grouping と mon_grouping は小整数のパック済みリストになって
	# います。これはgrouping (thousand_seps と mon_thousand_seps
	# はグループを分けるものです)の数と金銭に関するものの指定を
	# 行っています。その整数の意味はこうです: 255はグルーピング
	# しないことを意味します。1から254はカレントのグルーピングで
	# 使用する数値を意味します。グルーピングは右から左へ(下位桁から
	# 上位桁)と適用されます。下の例では最初のグルーピング以外は
	# 使わないことによってこれを避けています。
	if ($grouping) {
	    @grouping = unpack("C*", $grouping);
	} else {
	    @grouping = (3);
	}

        # Format command line params for current locale
        for (@ARGV) {
            $_ = int;    # Chop non-integer part
            1 while
            s/(\d)(\d{$grouping[0]}($|$thousands_sep))/$1$thousands_sep$2/;
            print "$_";
        }
        print "\n";

=head2 I18N::Langinfo

=begin original

Another interface for querying locale-dependent information is the
I18N::Langinfo::langinfo() function, available at least in UNIX-like
systems and VMS.

=end original

ロケール依存の情報を問い合わせるその他のインターフェースとしては
I18N::Langinfo::langinfo() 関数があり、少なくとも UNIX 風のシステムと
VMS で利用可能です。

=begin original

The following example will import the langinfo() function itself and
three constants to be used as arguments to langinfo(): a constant for
the abbreviated first day of the week (the numbering starts from
Sunday = 1) and two more constants for the affirmative and negative
answers for a yes/no question in the current locale.

=end original

以下の例は langinfo() 関数自身と、 langinfo() の引数として使う 3 つの
定数をインポートします: 1 つは現在のロケールでの週の最初の日の省略形
(番号は日曜日=1として振られています)、後の 2 つははい/いいえの質問に
対しての肯定および否定を現在のロケールで表すものです。

    use I18N::Langinfo qw(langinfo ABDAY_1 YESSTR NOSTR);

    my ($abday_1, $yesstr, $nostr) = map { langinfo } qw(ABDAY_1 YESSTR NOSTR);

    print "$abday_1? [$yesstr/$nostr] ";

=begin original

In other words, in the "C" (or English) locale the above will probably
print something like:

=end original

言い換えると、"C" (または English) ロケールでは上記のものはおそらく
以下のようなものが表示されます:

    Sun? [yes/no] 

=begin original

See L<I18N::Langinfo> for more information.

=end original

さらなる情報については L<I18N::Langinfo> を参照してください。

=head1 LOCALE CATEGORIES

(ロケールカテゴリー)

=begin original

The following subsections describe basic locale categories.  Beyond these,
some combination categories allow manipulation of more than one
basic category at a time.  See L<"ENVIRONMENT"> for a discussion of these.

=end original

以下のセクションでは、基本的なロケールカテゴリーの説明をします。
先の例のように、複数の基本カテゴリーを扱うことができる幾つかの
組み合わせカテゴリー(combination categories)があります。
この事に関する詳細は、L<"ENVIRONMENT"> を参照してください。

=head2 Category LC_COLLATE: Collation

(カテゴリー LC_COLLATE: 照合)

=begin original

In the scope of S<C<use locale>>, Perl looks to the C<LC_COLLATE>
environment variable to determine the application's notions on collation
(ordering) of characters.  For example, 'b' follows 'a' in Latin
alphabets, but where do 'E<aacute>' and 'E<aring>' belong?  And while
'color' follows 'chocolate' in English, what about in Spanish?

=end original

S<C<use locale>> のスコープの内側にあるとき、Perl はアプリケーションで
使用する文字の照合(順番)を決定するために環境変数 C<LC_COLLATE> を
参照します(ラテンアルファベットでは 'b' は 'a' に続くものですが、
'E<aacute>' や 'E<aring>' はどこに置かれるのでしょう?)。
また、英語では 'color' は 'chocolate' よりも後になりますが、スペイン語では
どうでしょう?

=begin original

The following collations all make sense and you may meet any of them
if you "use locale".

=end original

以下の照合は全て意味あるものであり、"use locale" をすれば直面することも
あるでしょう。

	A B C D E a b c d e
	A a B b C c D d E e
	a A b B c C d D e E
	a b c d e A B C D E

=begin original

Here is a code snippet to tell what "word"
characters are in the current locale, in that locale's order:

=end original

以下のコード片はカレントのロケールにおける英数文字をそのロケールでの
順序で出力するものです。

        use locale;
        print +(sort grep /\w/, map { chr } 0..255), "\n";

=begin original

Compare this with the characters that you see and their order if you
state explicitly that the locale should be ignored:

=end original

これと、陽にロケールを無視するように指示したときのキャラクターとを
比較してみてください。

        no locale;
        print +(sort grep /\w/, map { chr } 0..255), "\n";

=begin original

This machine-native collation (which is what you get unless S<C<use
locale>> has appeared earlier in the same block) must be used for
sorting raw binary data, whereas the locale-dependent collation of the
first example is useful for natural text.

=end original

この、マシン本来の照合(同じブロックの前のほうで S<C<use locale>> を
していない方)は生のバイナリデータのソートに用いるもので、
最初の例で使ったロケール依存の照合は通常のテキストに使うのに便利です。

=begin original

As noted in L<USING LOCALES>, C<cmp> compares according to the current
collation locale when C<use locale> is in effect, but falls back to a
char-by-char comparison for strings that the locale says are equal. You
can use POSIX::strcoll() if you don't want this fall-back:

=end original

L<USING LOCALES> で述べたように、C<cmp> は C<use locale> が有効なときには
カレントの照合ロケールに従って比較を行いますが、
この結果が等しいと出た場合には文字毎の比較に逆戻りします。
この逆戻りが嫌ならば、POSIX::strcoll() を使うことができます。

        use POSIX qw(strcoll);
        $equal_in_locale =
            !strcoll("space and case ignored", "SpaceAndCaseIgnored");

=begin original

$equal_in_locale will be true if the collation locale specifies a
dictionary-like ordering that ignores space characters completely and
which folds case.

=end original

$equal_in_locale は照合ロケールが空白キャラクタを完全に無視し、
大小文字の区別を無視するような辞書に似た順序付けを
指定している場合には真になるでしょう。

=begin original

If you have a single string that you want to check for "equality in
locale" against several others, you might think you could gain a little
efficiency by using POSIX::strxfrm() in conjunction with C<eq>:

=end original

「ロケールにおける等価性」の検査を他のものに対して行いたい(一つの)
文字列があるときにあなたは、POSIX::strxfrm() を C<eq> と一緒に
使うことによって多少の効率アップができると考えるかもしれません。

        use POSIX qw(strxfrm);
        $xfrm_string = strxfrm("Mixed-case string");
        print "locale collation ignores spaces\n"
            if $xfrm_string eq strxfrm("Mixed-casestring");
        print "locale collation ignores hyphens\n"
            if $xfrm_string eq strxfrm("Mixedcase string");
        print "locale collation ignores case\n"
            if $xfrm_string eq strxfrm("mixed-case string");

=begin original

strxfrm() takes a string and maps it into a transformed string for use
in char-by-char comparisons against other transformed strings during
collation.  "Under the hood", locale-affected Perl comparison operators
call strxfrm() for both operands, then do a char-by-char
comparison of the transformed strings.  By calling strxfrm() explicitly
and using a non locale-affected comparison, the example attempts to save
a couple of transformations.  But in fact, it doesn't save anything: Perl
magic (see L<perlguts/Magic Variables>) creates the transformed version of a
string the first time it's needed in a comparison, then keeps this version around
in case it's needed again.  An example rewritten the easy way with
C<cmp> runs just about as fast.  It also copes with null characters
embedded in strings; if you call strxfrm() directly, it treats the first
null it finds as a terminator.  don't expect the transformed strings
it produces to be portable across systems--or even from one revision
of your operating system to the next.  In short, don't call strxfrm()
directly: let Perl do it for you.

=end original

strxfrm() は文字列を引数にとり、それを同様の変換を加えられた文字列との
文字毎の比較に使えるような文字列に変換します。
「フードの中では」、ロケールに影響された Perl の比較演算子は 
strxfrm() を両オペランドのために呼び出して、その後で文字毎の比較を、
変換された文字列に対して行います。
strxfrm() を陽に呼び出すこととロケールに影響されない比較を行うことで、
上記の例は変換をセーブするようになります。
実際にはこれは何もセーブしません。
Perl の魔法(L<perlguts/Magic Variables> を参照)は、比較の際に必要であれば
最初に変換された文字列を生成し、それからそれが再び必要になるまで
取っておくのです。
C<cmp> を使って書き直したサンプルは可能な限り早く実行されます。
また、文字列に埋め込まれているナルキャラクターにも対処します。
strxfrm() を直接呼び出した場合、ナルは終端子としてみなされます。
そして、変換後の文字列がシステムを越えて使えるようなものであると
期待してはいけません。
また、あるオペレーティングシステムのバージョンで作ったものが次の
バージョンでも同様であるということも期待してはいけません。
一言でいうと、strxfrm() を直接呼び出してはいけない、ということです。
Perlに呼び出しをさせましょう。

=begin original

Note: C<use locale> isn't shown in some of these examples because it isn't
needed: strcoll() and strxfrm() exist only to generate locale-dependent
results, and so always obey the current C<LC_COLLATE> locale.

=end original

注意: 幾つかのサンプルでは、必要がないので C<use locale> がありません。
strcoll() や strxfm() はロケール依存の結果しか生成しませんので、
常に C<LC_COLLATE> ロケールを参照するのです。

=head2 Category LC_CTYPE: Character Types

(カテゴリー LC_CTYPE: 文字タイプ)

=begin original

In the scope of S<C<use locale>>, Perl obeys the C<LC_CTYPE> locale
setting.  This controls the application's notion of which characters are
alphabetic.  This affects Perl's C<\w> regular expression metanotation,
which stands for alphanumeric characters--that is, alphabetic,
numeric, and including other special characters such as the underscore or
hyphen.  (Consult L<perlre> for more information about
regular expressions.)  Thanks to C<LC_CTYPE>, depending on your locale
setting, characters like 'E<aelig>', 'E<eth>', 'E<szlig>', and
'E<oslash>' may be understood as C<\w> characters.

=end original

S<C<use locale>> のスコープにあるとき、Perl は C<LC_CTYPE> ロケールの
設定に従います。
これは、アプリケーションの英字かどうかの扱いを制御します。
これは、英数字 -- つまり、英字、数字、および下線やハイフンと言った特別な
文字を含みます --に関わる正規表現のメタ表記 C<\w> に影響します。
(正規表現に関するさらなる情報については L<perlre> を参照してください)。
C<LC_CTYPE> のおかげで、ロケール設定に依存した 'E<aelig>', 'E<eth>',
'E<szlig>', 'E<oslash>' のような文字が C<\w> 文字として認識できるのです。

=begin original

The C<LC_CTYPE> locale also provides the map used in transliterating
characters between lower and uppercase.  This affects the case-mapping
functions--lc(), lcfirst, uc(), and ucfirst(); case-mapping
interpolation with C<\l>, C<\L>, C<\u>, or C<\U> in double-quoted strings
and C<s///> substitutions; and case-independent regular expression
pattern matching using the C<i> modifier.

=end original

C<LC_CTYPE> ロケールはまた、小文字と大文字との間の相互変換に使われる
マッピングを提供します。
これは大文字小文字変換関数 lc(), lcfirst, uc(), 
ucfirst() とダブルクォートで囲まれた文字列の中での C<\l>, C<\L>, 
C<\u>, <\U> による大文字小文字変換、そして C<s///> による置換、
C<i> 修飾子を使った(大小文字を無視する)正規表現パターンマッチングに
影響を及ぼします。

=begin original

Finally, C<LC_CTYPE> affects the POSIX character-class test
functions--isalpha(), islower(), and so on.  For example, if you move
from the "C" locale to a 7-bit Scandinavian one, you may find--possibly
to your surprise--that "|" moves from the ispunct() class to isalpha().

=end original

さらに、C<LC_CTYPE> は POSIX のキャラクタクラステスト関数、isalpha(), 
islower() などにも影響を及ぼします。
たとえば、“C”ロケールを 7 ビットのスカンジナビアのものにしたとすると、
多分あなたは驚くことになるでしょうが、"|"  が ispunct() クラスから
isalpha() クラスに移動するのです。

=begin original

B<Note:> A broken or malicious C<LC_CTYPE> locale definition may result
in clearly ineligible characters being considered to be alphanumeric by
your application.  For strict matching of (mundane) letters and
digits--for example, in command strings--locale-aware applications
should use C<\w> inside a C<no locale> block.  See L<"SECURITY">.

=end original

B<注意:> 壊れた、あるいは悪意のある C<LC_CTYPE> ロケールの定義は、
不適切なキャラクターを英数字であるとみなしてしまう可能性があります。
(アクセント記号のない)文字や数字の厳密なマッチング、例えばコマンド文字列の
ロケールを気にするアプリケーションは C<no locale> ブロックの内側で
C<\w> を使うべきです。
L<"SECURITY"> を参照してください。

=head2 Category LC_NUMERIC: Numeric Formatting

(カテゴリー LC_NUMERIC: 数値形式)

=begin original

After a proper POSIX::setlocale() call, Perl obeys the C<LC_NUMERIC>
locale information, which controls an application's idea of how numbers
should be formatted for human readability by the printf(), sprintf(), and
write() functions. String-to-numeric conversion by the POSIX::strtod()
function is also affected.  In most implementations the only effect is to
change the character used for the decimal point--perhaps from '.'  to ','.
These functions aren't aware of such niceties as thousands separation and
so on. (See L<The localeconv function> if you care about these things.)

=end original

適切な POSIX::setlocale() 呼び出しの後、Perl は C<LC_NUMERIC> 
ロケール情報を参照します。
これはアプリケーションが printf(), sprintf(), write() といった関数を
使ったときに数値をどのように整形するかということを制御するものです。
文字列から数値への変換には、関数 POSIX::strtod() も影響を及ぼします。
大部分の実装では、小数点を表わすキャラクターを '.'  から ',' へと
変更するだけの効果しかありません。
これらの関数は三桁毎の区切りなどについては考慮しません(この事について
心配があるのなら L<The localeconv function> を参照してください)。

=begin original

Output produced by print() is also affected by the current locale: it
corresponds to what you'd get from printf() in the "C" locale.  The
same is true for Perl's internal conversions between numeric and
string formats:

=end original

print() により生成された出力もカレントロケールの影響を受けます:
これは "C" ロケールで printf を使ったときの結果に対応します。
Perl の、数値と文字列との間の内部的な変換はこれと同じです。

        use POSIX qw(strtod setlocale LC_NUMERIC);

	setlocale LC_NUMERIC, "";

        $n = 5/2;   # Assign numeric 2.5 to $n

        $a = " $n"; # Locale-dependent conversion to string

        print "half five is $n\n";       # Locale-dependent output

        printf "half five is %g\n", $n;  # Locale-dependent output

        print "DECIMAL POINT IS COMMA\n"
            if $n == (strtod("2,5"))[0]; # Locale-dependent conversion

=begin original

See also L<I18N::Langinfo> and C<RADIXCHAR>.

=end original

L<I18N::Langinfo> と C<RADIXCHAR> も参照してください。

=head2 Category LC_MONETARY: Formatting of monetary amounts

(カテゴリー LC_MONETARY: 金銭の書式)

=begin original

The C standard defines the C<LC_MONETARY> category, but no function
that is affected by its contents.  (Those with experience of standards
committees will recognize that the working group decided to punt on the
issue.)  Consequently, Perl takes no notice of it.  If you really want
to use C<LC_MONETARY>, you can query its contents--see 
L<The localeconv function>--and use the information that it returns in your 
application's own formatting of currency amounts.  However, you may well 
find that the information, voluminous and complex though it may be, still 
does not quite meet your requirements: currency formatting is a hard nut 
to crack.

=end original

標準 C では C<LC_MONETARY> カテゴリーを定義していますが、その内容に
影響される関数はありません。
(規格委員会の経験によって、それらはワーキンググループがこの問題を
蹴り出すことに決めたことを認識したのでしょう。)
結果として、Perl はこれに注意を払いません。
もし本当に C<LC_MONETARY> を使いたければ、自分でその内容を
問い合わせることができます。
(L<The localeconv function> を参照してください)。
そして返ってきた情報をアプリケーションの通貨量の整形に使います。
しかし、この情報を取得することはできるでしょうが、大量かつ複雑で、
要求に対して本当にあったものではないでしょう。
金銭に関する書式は手におえない代物なのです。

=begin original

See also L<I18N::Langinfo> and C<CRNCYSTR>.

=end original

L<I18N::Langinfo> と C<CRNCYSTR> も参照してください。

=head2 LC_TIME

=begin original

Output produced by POSIX::strftime(), which builds a formatted
human-readable date/time string, is affected by the current C<LC_TIME>
locale.  Thus, in a French locale, the output produced by the C<%B>
format element (full month name) for the first month of the year would
be "janvier".  Here's how to get a list of long month names in the
current locale:

=end original

人が読みやすい、整形された日付/時刻文字列を作り出す
POSIX::strftime() によって生成された出力はカレントの C<LC_TIME> ロケールに
影響を受けます。
したがって、フランスのロケールでは、C<%B> 書式指定子(省略のない月の名前)を
一年の最初の月に対して使ったときの結果は、“janvier”となります。
以下の例は、カレントロケールにおける長い月名のリストを得るものです。

        use POSIX qw(strftime);
        for (0..11) {
            $long_month_name[$_] =
                strftime("%B", 0, 0, 0, 1, $_, 96);
        }

=begin original

Note: C<use locale> isn't needed in this example: as a function that
exists only to generate locale-dependent results, strftime() always
obeys the current C<LC_TIME> locale.

=end original

注意: C<use locale> はこの例では必要ではありません。
strftime() は常にカレントの C<LC_TIME> ロケールを参照し、ロケール依存の
結果のみを生成します。

=begin original

See also L<I18N::Langinfo> and C<ABDAY_1>..C<ABDAY_7>, C<DAY_1>..C<DAY_7>,
C<ABMON_1>..C<ABMON_12>, and C<ABMON_1>..C<ABMON_12>.

=end original

L<I18N::Langinfo> と C<ABDAY_1>..C<ABDAY_7>, C<DAY_1>..C<DAY_7> と
C<ABMON_1>..C<ABMON_12> と C<ABMON_1>..C<ABMON_12> も参照してください。

=head2 Other categories

(その他のカテゴリー)

=begin original

The remaining locale category, C<LC_MESSAGES> (possibly supplemented
by others in particular implementations) is not currently used by
Perl--except possibly to affect the behavior of library functions
called by extensions outside the standard Perl distribution and by the
operating system and its utilities.  Note especially that the string
value of C<$!> and the error messages given by external utilities may
be changed by C<LC_MESSAGES>.  If you want to have portable error
codes, use C<%!>.  See L<Errno>.

=end original

残ったロケールカテゴリー C<LC_MESSAGES> (別の特定の実装により
提供されていることもあるでしょう)は、現在の Perl では、標準の Perl 配布
パッケージにはない拡張モジュールや OS やそのユーティリティから呼ばれる
ライブラリ関数が使っている可能性を除けば、使っていません。
C<$!> の文字列値と、外部のユーティリティから与えられたエラーメッセージは
C<LC_MESSAGES> で変更されているかもしれないことに特に注意してください。
移植性のあるエラーコードがほしい場合は、C<%!> を使ってください。
L<Errno> を参照してください。

=head1 SECURITY

(セキュリティ)

=begin original

Although the main discussion of Perl security issues can be found in
L<perlsec>, a discussion of Perl's locale handling would be incomplete
if it did not draw your attention to locale-dependent security issues.
Locales--particularly on systems that allow unprivileged users to
build their own locales--are untrustworthy.  A malicious (or just plain
broken) locale can make a locale-aware application give unexpected
results.  Here are a few possibilities:

=end original

Perl のセキュリティに関する事項の主な議論は L<perlsec> にありますが、
Perl のロケールの扱いに関する議論はそれがあなたのロケール依存の
セキュリティ事項に対して注意していなければ不完全です。
ロケールは(特に特権のないユーザーが自分のロケールを構築するのを許すような
システムでは)信用できないものなのです。
悪意のある(もしくは単に壊れた)ロケールはロケールを使うアプリケーションを
予期できない結果にする可能性があります。
以下に幾つかの可能性を挙げます。

=over 4

=item *

=begin original

Regular expression checks for safe file names or mail addresses using
C<\w> may be spoofed by an C<LC_CTYPE> locale that claims that
characters such as "E<gt>" and "|" are alphanumeric.

=end original

安全なファイル名やメイルアドレスを検索するための正規表現で C<\w> を使うと、
“E<gt>”や“|”を英数字と主張するような C<LC_CTYPE> に
だまされてしまう可能性があります。

=item *

=begin original

String interpolation with case-mapping, as in, say, C<$dest =
"C:\U$name.$ext">, may produce dangerous results if a bogus LC_CTYPE
case-mapping table is in effect.

=end original

C<$dest = "C:\U$name.$ext"> のような、大文字小文字変換を伴った文字列の改変は、
不正な LC_CTYPE の大文字小文字変換テーブルが有効であるときに
危険な結果を生成する可能性があります。

=item *

=begin original

A sneaky C<LC_COLLATE> locale could result in the names of students with
"D" grades appearing ahead of those with "A"s.

=end original

陰険な C<LC_COLLATE>ロケールは "D" 等級の生徒の名前を
"A" の前に置いてしまう結果にさせるかもしれません。

=item *

=begin original

An application that takes the trouble to use information in
C<LC_MONETARY> may format debits as if they were credits and vice versa
if that locale has been subverted.  Or it might make payments in US
dollars instead of Hong Kong dollars.

=end original

手間を惜しまずに C<LC_MONETARY> にある情報を使うアプリケーションは、
ロケールがおかしいと、負債を預金のように扱ったり、その逆にしたり
してしまうかもしれません。
あるいは、香港ドルの代わりに US ドルで支払いをさせたりしてしまうかも
しれません。

=item *

=begin original

The date and day names in dates formatted by strftime() could be
manipulated to advantage by a malicious user able to subvert the
C<LC_DATE> locale.  ("Look--it says I wasn't in the building on
Sunday.")

=end original

strftime() により整形された日付情報は、C<LC_DATE> をいじりまわすことの
できる悪意あるユーザーにより操作されてしまう可能性があります
(「見てくれよ、こいつ俺が日曜日にビルディングにいなかったって
言ってるよ」)。

=back

=begin original

Such dangers are not peculiar to the locale system: any aspect of an
application's environment which may be modified maliciously presents
similar challenges.  Similarly, they are not specific to Perl: any
programming language that allows you to write programs that take
account of their environment exposes you to these issues.

=end original

このような危険は、ロケールシステムに特有のものではありません。
意地の悪い変更を通して同じような攻撃を受けるようなアプリケーション環境の
あらゆる状況が対象となります。
同様に、これは Perl に固有なものでもありません。
環境を考慮するようなプログラムを書くことのできるあらゆるプログラミング
言語で同様の危険性があるのです。

=begin original

Perl cannot protect you from all possibilities shown in the
examples--there is no substitute for your own vigilance--but, when
C<use locale> is in effect, Perl uses the tainting mechanism (see
L<perlsec>) to mark string results that become locale-dependent, and
which may be untrustworthy in consequence.  Here is a summary of the
tainting behavior of operators and functions that may be affected by
the locale:

=end original

perlは例示したようなすべての可能性からあなたを守ることはできません。
あなた自身の用心に代り得るものはないのです。
しかし、C<use locale> が有効であるとき、Perl は汚染チェック機構
(L<perlsec> を参照)を、ロケールに依存した結果であり、
信用できないかもしれない文字列に注意するために使用します。
以下は、ロケールにより影響を受ける可能性のある演算子や関数の汚染される
振る舞いのまとめです。

=over 4

=item  *

=begin original

B<Comparison operators> (C<lt>, C<le>, C<ge>, C<gt> and C<cmp>):

=end original

B<比較演算子> (C<lt>, C<le>, C<ge>, C<gt>, C<cmp>):

=begin original

Scalar true/false (or less/equal/greater) result is never tainted.

=end original

スカラの真/偽(もしくは未満/等しい/越えている)の結果は
決して汚染されません。

=item  *

=begin original

B<Case-mapping interpolation> (with C<\l>, C<\L>, C<\u> or C<\U>)

=end original

B<大文字小文字変換> (C<\l>, C<\L>, C<\u>, C<\U>)

=begin original

Result string containing interpolated material is tainted if
C<use locale> is in effect.

=end original

展開されたものが含まれる文字列は C<use locale> が有効な
場合には汚染されます。

=item  *

=begin original

B<Matching operator> (C<m//>):

=end original

B<マッチング演算子> (C<m//>):

=begin original

Scalar true/false result never tainted.

=end original

スカラの真/偽の結果は決して汚染されません。

=begin original

Subpatterns, either delivered as a list-context result or as $1 etc.
are tainted if C<use locale> is in effect, and the subpattern regular
expression contains C<\w> (to match an alphanumeric character), C<\W>
(non-alphanumeric character), C<\s> (whitespace character), or C<\S>
(non whitespace character).  The matched-pattern variable, $&, $`
(pre-match), $' (post-match), and $+ (last match) are also tainted if
C<use locale> is in effect and the regular expression contains C<\w>,
C<\W>, C<\s>, or C<\S>.

=end original

配列コンテキストの結果や、$1 などから派生したサブパターンは
C<use locale> が有効であるときには汚染されます。
そして、C<\w> (英数字にマッチする)、C<\W>
(英数字以外にマッチする)、C<\s> (空白キャラクター)、
C<\S> (空白でないキャラクター)を含む正規表現サブパターンも同様です。
マッチした結果を保持する変数、$&、$`(マッチした部分より前)、$'(マッチした
部分より後)、$+ (最後にマッチしたもの)、そして C<\w>、C<\W>、
C<\s>、C<\S> を含む正規表現も、C<use locale> が有効であるときには
汚染されます。

=item  *

=begin original

B<Substitution operator> (C<s///>):

=end original

B<置換演算子> (C<s///>):

=begin original

Has the same behavior as the match operator.  Also, the left
operand of C<=~> becomes tainted when C<use locale> in effect
if modified as a result of a substitution based on a regular
expression match involving C<\w>, C<\W>, C<\s>, or C<\S>; or of
case-mapping with C<\l>, C<\L>,C<\u> or C<\U>.

=end original

マッチング演算子と同じ振る舞いをします。
また、C<=~> の左側のオペランドは、C<use locale> が有効のとき、
C<\w>, C<\W>, C<\s>, C<\S> の正規表現マッチングによる置換か、
C<\l>, C<\L>,C<\u>, C<\U> の大文字小文字マッピングによって、
値が変更された場合、汚染されます。

=item *

=begin original

B<Output formatting functions> (printf() and write()):

=end original

B<出力書式関数> (printf() と write()):

=begin original

Results are never tainted because otherwise even output from print,
for example C<print(1/7)>, should be tainted if C<use locale> is in
effect.

=end original

結果は決して汚染されません; なぜなら、もしそうでないなら、
例えば C<print(1/7)> のような、print からの出力ですら
C<use locale> が有効のときは汚染されることになってしまいます。

=item *

=begin original

B<Case-mapping functions> (lc(), lcfirst(), uc(), ucfirst()):

=end original

B<大文字小文字変換関数> (lc(), lcfirst(), uc(), ucfirst()):

=begin original

Results are tainted if C<use locale> is in effect.

=end original

C<use locale> が有効なときに、結果が汚染されます。

=item *

=begin original

B<POSIX locale-dependent functions> (localeconv(), strcoll(),
strftime(), strxfrm()):

=end original

B<POSIX ロケール依存関数> (localeconv(), strcoll(),
strftime(), strxfrm()):

=begin original

Results are never tainted.

=end original

結果は決して汚染されません。

=item *

=begin original

B<POSIX character class tests> (isalnum(), isalpha(), isdigit(),
isgraph(), islower(), isprint(), ispunct(), isspace(), isupper(),
isxdigit()):

=end original

B<POSIX 文字クラステスト> (isalnum(), isalpha(), isdigit(),
isgraph(), islower(), isprint(), ispunct(), isspace(), isupper(),
isxdigit()):

=begin original

True/false results are never tainted.

=end original

真/偽の結果は決して汚染されません。

=back

=begin original

Three examples illustrate locale-dependent tainting.
The first program, which ignores its locale, won't run: a value taken
directly from the command line may not be used to name an output file
when taint checks are enabled.

=end original

三つの例を使って、ロケール依存の汚染を説明します。
最初のプログラムはそのロケールを無視して、実行されません。
汚染検査が有効であるときには、コマンドラインから直接とった値を
出力ファイル名として使うことはできません。

        #/usr/local/bin/perl -T
        # Run with taint checking

        # Command line sanity check omitted...
        $tainted_output_file = shift;

        open(F, ">$tainted_output_file")
            or warn "Open of $untainted_output_file failed: $!\n";

=begin original

The program can be made to run by "laundering" the tainted value through
a regular expression: the second example--which still ignores locale
information--runs, creating the file named on its command line
if it can.

=end original

このプログラムは、汚染された値を正規表現を通して
「洗浄」(laundering)することにより実行できるようにできます。
以下に挙げる二番目の例は、これもロケール情報を無視しています。
実行されると、コマンドラインにある名前のファイルを可能であれば作成します。

        #/usr/local/bin/perl -T

        $tainted_output_file = shift;
        $tainted_output_file =~ m%[\w/]+%;
        $untainted_output_file = $&;

        open(F, ">$untainted_output_file")
            or warn "Open of $untainted_output_file failed: $!\n";

=begin original

Compare this with a similar but locale-aware program:

=end original

これを、非常に良く似てはいますが、ロケールを使ったプログラムと
比較してみてください。

        #/usr/local/bin/perl -T

        $tainted_output_file = shift;
        use locale;
        $tainted_output_file =~ m%[\w/]+%;
        $localized_output_file = $&;

        open(F, ">$localized_output_file")
            or warn "Open of $localized_output_file failed: $!\n";

=begin original

This third program fails to run because $& is tainted: it is the result
of a match involving C<\w> while C<use locale> is in effect.

=end original

この三番目のプログラムは、$& が汚染されているので実行に失敗します;
これは C<use locale> が有効であるときの C<\w> を含んだマッチングによる
結果です。

=head1 ENVIRONMENT

(環境変数)

=over 12

=item PERL_BADLANG

=begin original

A string that can suppress Perl's warning about failed locale settings
at startup.  Failure can occur if the locale support in the operating
system is lacking (broken) in some way--or if you mistyped the name of
a locale when you set up your environment.  If this environment
variable is absent, or has a value that does not evaluate to integer
zero--that is, "0" or ""-- Perl will complain about locale setting
failures.

=end original

Perl が起動時にロケールの設定に失敗した場合に警告を出すのを抑制できる
文字列です。
オペレーティングシステムのロケールサポートがなんらかの理由でなかったり、
壊れていたりするとき、あるいは環境変数に設定したロケールの名前を
間違えていた場合に発生します。
もしこの変数が存在していないとか、あるいはその値が評価すると0に
ならないようなもの、つまり“0”や“”でない場合に、Perl はロケールの設定に
失敗するとメッセージを出力します。

=begin original

B<NOTE>: PERL_BADLANG only gives you a way to hide the warning message.
The message tells about some problem in your system's locale support,
and you should investigate what the problem is.

=end original

B<注意>: PERL_BADLANG は警告メッセージを出さないようにするだけです。
このメッセージはあなたの使うシステムのロケールサポートになにかの問題が
あるということを伝えるものですから、あなたは問題が何なのかを
確かめるべきでしょう。

=back

=begin original

The following environment variables are not specific to Perl: They are
part of the standardized (ISO C, XPG4, POSIX 1.c) setlocale() method
for controlling an application's opinion on data.

=end original

以下の環境変数は Perl に特有のものではなく、アプリケーションのデータの
扱いを制御するための標準的な(ISO C, XPG4, POSIX 1.c) setlocale() メソッドの
一部分です。

=over 12

=item LC_ALL

=begin original

C<LC_ALL> is the "override-all" locale environment variable. If
set, it overrides all the rest of the locale environment variables.

=end original

C<LC_ALL> は「全て上書き」ロケール環境変数です。
もしこの環境変数が設定されていると、他のすべての環境変数を上書きします。

=item LANGUAGE

=begin original

B<NOTE>: C<LANGUAGE> is a GNU extension, it affects you only if you
are using the GNU libc.  This is the case if you are using e.g. Linux.
If you are using "commercial" UNIXes you are most probably I<not>
using GNU libc and you can ignore C<LANGUAGE>.

=end original

B<注意>: C<LANGUAGE> は GNU の拡張で、GNU libc を使っているときにのみ
効果があります。
Linux を使ったときなどがこれに該当します。
あなたが「商用の」UNIX を使っているのであれば GNU libc は
使われていないでしょうし、C<LANGUAGE> は無視することができます。

=begin original

However, in the case you are using C<LANGUAGE>: it affects the
language of informational, warning, and error messages output by
commands (in other words, it's like C<LC_MESSAGES>) but it has higher
priority than L<LC_ALL>.  Moreover, it's not a single value but
instead a "path" (":"-separated list) of I<languages> (not locales).
See the GNU C<gettext> library documentation for more information.

=end original

C<LANGUAGE> を使った場合には、コマンドからの情報、警告、エラーといった
メッセージの言語に影響を及ぼします(言い換えると C<LC_MESSAGES> と
似ています)が、L<LC_ALL> よりも優先順位は下です。
さらに、これは単一の値ではなくて言語(ロケールではありません)の、
“:”で連結された「パス」になっています。
より詳しい情報は GNU C<gettext> ライブラリのドキュメントを参照してください。

=item LC_CTYPE

=begin original

In the absence of C<LC_ALL>, C<LC_CTYPE> chooses the character type
locale.  In the absence of both C<LC_ALL> and C<LC_CTYPE>, C<LANG>
chooses the character type locale.

=end original

C<LC_ALL> がないときに、C<LC_CTYPE> は文字タイプのロケールを選択します。
C<LC_ALL> と C<LC_CTYPE> の両方ともない場合、C<LANG> が文字タイプの
ロケールを選択します。

=item LC_COLLATE

=begin original

In the absence of C<LC_ALL>, C<LC_COLLATE> chooses the collation
(sorting) locale.  In the absence of both C<LC_ALL> and C<LC_COLLATE>,
C<LANG> chooses the collation locale.

=end original

C<LC_ALL> がないときに、C<LC_COLLATE> は照合(ソート)ロケールを選択します。
C<LC_ALL> と C<LC_COLLATE> の両方ともない場合、C<LANG> が
照合ロケールを選択します。

=item LC_MONETARY

=begin original

In the absence of C<LC_ALL>, C<LC_MONETARY> chooses the monetary
formatting locale.  In the absence of both C<LC_ALL> and C<LC_MONETARY>,
C<LANG> chooses the monetary formatting locale.

=end original

C<LC_ALL> がないときに、C<LC_MONETARY> は通貨形式ロケールを選択します。
C<LC_ALL> と C<LC_MONETARY> の両方ともない場合、
C<LANG> が通貨形式ロケールを選択します。

=item LC_NUMERIC

=begin original

In the absence of C<LC_ALL>, C<LC_NUMERIC> chooses the numeric format
locale.  In the absence of both C<LC_ALL> and C<LC_NUMERIC>, C<LANG>
chooses the numeric format.

=end original

C<LC_ALL> がないときに、C<LC_NUMERIC> は数値表記のロケールを選択します。
C<LC_ALL> と C<LC_NUMERIC> の両方ともない場合、C<LANG> が数値表記を
選択します。

=item LC_TIME

=begin original

In the absence of C<LC_ALL>, C<LC_TIME> chooses the date and time
formatting locale.  In the absence of both C<LC_ALL> and C<LC_TIME>,
C<LANG> chooses the date and time formatting locale.

=end original

C<LC_ALL> がないときに、C<LC_TIME> は日付・時刻表記のロケールを選択します。
C<LC_ALL> と C<LC_TIME> の両方ともない場合、C<LANG> が日付・時刻表記の
ロケールを選択します。

=item LANG

=begin original

C<LANG> is the "catch-all" locale environment variable. If it is set, it
is used as the last resort after the overall C<LC_ALL> and the
category-specific C<LC_...>.

=end original

C<LANG> は「包括的」なロケール環境変数です。
これに値が設定されている場合、C<LC_ALL> も、各カテゴリーの C<LC_...> も
設定されていないときの最後の参照場所として使われます。

=back

=head2 Examples

(例)

=begin original

The LC_NUMERIC controls the numeric output:

=end original

LC_NUMERIC は数値出力を制御します:

        use locale;
        use POSIX qw(locale_h); # Imports setlocale() and the LC_ constants.
        setlocale(LC_NUMERIC, "fr_FR") or die "Pardon";
        printf "%g\n", 1.23; # If the "fr_FR" succeeded, probably shows 1,23.

=begin original

and also how strings are parsed by POSIX::strtod() as numbers:

=end original

そして文字列が POSIX::strtod() によってどのように数値としてパースされるかも
制御します:

        use locale;
        use POSIX qw(locale_h strtod);
        setlocale(LC_NUMERIC, "de_DE") or die "Entschuldigung";
        my $x = strtod("2,34") + 5;
        print $x, "\n"; # Probably shows 7,34.

=head1 NOTES

(注意)

=head2 Backward compatibility

(過去互換性)

=begin original

Versions of Perl prior to 5.004 B<mostly> ignored locale information,
generally behaving as if something similar to the C<"C"> locale were
always in force, even if the program environment suggested otherwise
(see L<The setlocale function>).  By default, Perl still behaves this
way for backward compatibility.  If you want a Perl application to pay
attention to locale information, you B<must> use the S<C<use locale>>
pragma (see L<The use locale pragma>) to instruct it to do so.

=end original

5.004 より前のバージョンの Perl では、B<ほとんど> ロケール情報を無視して、
たとえプログラム環境が別のものを指示していたとしても常に C<"C"> ロケール
(L<The setlocale function> を参照) が強制されているかのように
振る舞っていました。
デフォルトでは、Perl は今でもこのように動作するので、過去互換性があります。
Perl アプリケーションをロケール情報に注目するようにしたいのなら、
S<C<use locale>> プラグマ(L<The use locale pragma> を参照)を
B<使わなければなりません>。

=begin original

Versions of Perl from 5.002 to 5.003 did use the C<LC_CTYPE>
information if available; that is, C<\w> did understand what
were the letters according to the locale environment variables.
The problem was that the user had no control over the feature:
if the C library supported locales, Perl used them.

=end original

5.002 から 5.003 の Perl は、使用可能である場合には C<LC_CTYPE> の情報を
使っていました。
つまり、C<\w> はロケールの環境変数に従った文字を理解していたのです。
問題は、C ライブラリがロケールをサポートしている場合には Perl がそれを
使ってしまい、ユーザーがこの機能を制御できないということでした。

=head2 I18N:Collate obsolete

(I18N:Collate は古いもの)

=begin original

In versions of Perl prior to 5.004, per-locale collation was possible
using the C<I18N::Collate> library module.  This module is now mildly
obsolete and should be avoided in new applications.  The C<LC_COLLATE>
functionality is now integrated into the Perl core language: One can
use locale-specific scalar data completely normally with C<use locale>,
so there is no longer any need to juggle with the scalar references of
C<I18N::Collate>.

=end original

5.004 より前のバージョンの Perl では、ロケール毎の照合は C<I18N::Collate>
ライブラリモジュールを使うことで可能でした。
このモジュールは現在、やや時代遅れとなっていて、新しいアプリケーションでは
使用を避けるべきものです。
現在、C<LC_COLLATE> 機能は Perl のコア言語に統合されました。
スカラデータのロケール固有の比較は C<use locale> を使うことで完全に
行なわれます。
このため、C<I18N::Collate> のスカラリファレンスを使ってお手玉する必要は
もはやないのです。

=head2 Sort speed and memory use impacts

(ソートの速度とメモリ使用に与える影響)

=begin original

Comparing and sorting by locale is usually slower than the default
sorting; slow-downs of two to four times have been observed.  It will
also consume more memory: once a Perl scalar variable has participated
in any string comparison or sorting operation obeying the locale
collation rules, it will take 3-15 times more memory than before.  (The
exact multiplier depends on the string's contents, the operating system
and the locale.) These downsides are dictated more by the operating
system's implementation of the locale system than by Perl.

=end original

ロケールによる比較とソートは通常、デフォルトのソートに比べ二倍から
四倍遅くなります。
また、メモリの使用量も増大します。
Perl のスカラ変数がロケールの照合規則を使ったなんらかの文字列比較や
ソートの中で現れると、それによって以前より三倍から十五倍の時間を
要するようになります(実際のところの乗数は文字列の内容、オペレーティング
システム、ロケールに依存します)。
この性能ダウンは、Perl によるものよりもオペレーティングシステムの
ロケールシステムの実装によるものが顕著に現れます。

=head2 write() and LC_NUMERIC

(write() と LC_NUMERIC)

=begin original

Formats are the only part of Perl that unconditionally use information
from a program's locale; if a program's environment specifies an
LC_NUMERIC locale, it is always used to specify the decimal point
character in formatted output.  Formatted output cannot be controlled by
C<use locale> because the pragma is tied to the block structure of the
program, and, for historical reasons, formats exist outside that block
structure.

=end original

フォーマットは Perl で、プログラムのロケールから来る情報を無条件に
使用する唯一の部分です。
プログラムの環境で LC_NUMERIC ロケールが指定されていれば、書式指定された
出力にある小数点のキャラクターは常にそこで指定されたものが使われます。
書式指定された出力は C<use locale> によって制御することはできません。
なぜなら、このプラグマはプラグマのあるブロック構造に結び付けられていて、
また、歴史的経緯によってフォーマットはブロック構造の外側に
存在しているからなのです。

=head2 Freely available locale definitions

(自由に利用可能なロケール定義)

=begin original

There is a large collection of locale definitions at
ftp://dkuug.dk/i18n/WG15-collection .  You should be aware that it is
unsupported, and is not claimed to be fit for any purpose.  If your
system allows installation of arbitrary locales, you may find the
definitions useful as they are, or as a basis for the development of
your own locales.

=end original

ftp://dkuug.dk/i18n/WG15-collection にロケール定義の大規模なコレクションが
あります。
これがサポート無しのものであり、どんな目的にも適合するとは
主張していないものであることに注意すべきです。
あなたの使うシステムがロケール機能のインストールを許しているのであれば、
この場所で便利な定義を見つけることができるでしょうし、あるいは自分で
ロケールを定義する基礎となるようなものを見つけられるかもしれません。

=head2 I18n and l10n

(I18n と l10n)

=begin original

"Internationalization" is often abbreviated as B<i18n> because its first
and last letters are separated by eighteen others.  (You may guess why
the internalin ... internaliti ... i18n tends to get abbreviated.)  In
the same way, "localization" is often abbreviated to B<l10n>.

=end original

"Internationalization" (国際化)はその最初と最後の文字、そしてその間にある
文字数から B<i18n> としばしば略されます。
同様のやり方で、"localization" もしばしば B<l10n> と省略されます。

=head2 An imperfect standard

(不完全な標準)

=begin original

Internationalization, as defined in the C and POSIX standards, can be
criticized as incomplete, ungainly, and having too large a granularity.
(Locales apply to a whole process, when it would arguably be more useful
to have them apply to a single thread, window group, or whatever.)  They
also have a tendency, like standards groups, to divide the world into
nations, when we all know that the world can equally well be divided
into bankers, bikers, gamers, and so on.  But, for now, it's the only
standard we've got.  This may be construed as a bug.

=end original

国際対応は標準 C や標準 POSIX に定義されているように、不完全で、扱いにくく、
粒度が大きすぎると酷評されます(ロケールは、単一のスレッドであるとか、
ウィンドウグループといったものに対して適用するのが便利であるときにも
プロセス全体に適用されます)。
また、標準化グループに似て、世界を国に分割しようとする傾向があります。
しかし現在のところ、これが私たちが手にすることができる唯一の標準なのです。
これはバグとして解釈できるかもしれません。

=head1 Unicode and UTF-8

(Unicode と UTF-8)

=begin original

The support of Unicode is new starting from Perl version 5.6, and
more fully implemented in the version 5.8.  See L<perluniintro> and
L<perlunicode> for more details.

=end original

Unicode 対応は Perl 5.6 から開始され、バージョン 5.8 でより完全に
実装されました。
さらなる詳細については L<perluniintro> と L<perlunicode> を
参照してください。

=begin original

Usually locale settings and Unicode do not affect each other, but
there are exceptions, see L<perlunicode/Locales> for examples.

=end original

通常はロケール設定と Unicode は互いに影響を与えませんが、例外もあります;
例については L<perlunicode/Locales> を参照してください。

=head1 BUGS

(バグ)

=head2 Broken systems

(壊れているシステム)

=begin original

In certain systems, the operating system's locale support
is broken and cannot be fixed or used by Perl.  Such deficiencies can
and will result in mysterious hangs and/or Perl core dumps when the
C<use locale> is in effect.  When confronted with such a system,
please report in excruciating detail to <F<perlbug@perl.org>>, and
complain to your vendor: bug fixes may exist for these problems
in your operating system.  Sometimes such bug fixes are called an
operating system upgrade.

=end original

幾つかのオペレーティングシステムにおける環境でのロケールサポートは、
おかしなもので、Perl がそれに対処したり使ったりできないようなものです。
そういった不完全なものは、C<use locale> が有効になったときに Perl を
不可思議なハングアップに導いたり、コアダンプをさせたりします。
このようなシステムに直面した場合、詳しい状況を <F<perlbug@perl.org>> に
レポートし、そして使用しているシステムのベンダーに不満を伝えてください。
問題の幾つかに対するバグフィックスがされているかもしれません。
そういったバグ修正は、オペレーティングシステムのアップグレードと
呼ばれることがあります。

=head1 SEE ALSO

L<I18N::Langinfo>, L<perluniintro>, L<perlunicode>, L<open>,
L<POSIX/isalnum>, L<POSIX/isalpha>,
L<POSIX/isdigit>, L<POSIX/isgraph>, L<POSIX/islower>,
L<POSIX/isprint>, L<POSIX/ispunct>, L<POSIX/isspace>,
L<POSIX/isupper>, L<POSIX/isxdigit>, L<POSIX/localeconv>,
L<POSIX/setlocale>, L<POSIX/strcoll>, L<POSIX/strftime>,
L<POSIX/strtod>, L<POSIX/strxfrm>.

=head1 HISTORY

=begin original

Jarkko Hietaniemi's original F<perli18n.pod> heavily hacked by Dominic
Dunlop, assisted by the perl5-porters.  Prose worked over a bit by
Tom Christiansen.

=end original

Jarkko Hietaniemi の原文書 F<perli18n.pod> は perl5-porters の助けの元、
Dominic Dunlop によって大きく変更されました。
表現に関しては Tom Christiansen が少し作業をしました。

Last update: Thu Jun 11 08:44:13 MDT 1998

=begin meta

Created: KIMURA Koichi
Updated: Kentaro Shirakata <argrath@ub32.org> (5.8.8-)

=end meta

