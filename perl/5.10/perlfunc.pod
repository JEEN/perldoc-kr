=encoding utf8

=head1 NAME
X<function>

=begin original

perlfunc - Perl builtin functions

=end original

perlfunc - Perl 내장함수

=head1 DESCRIPTION

=begin original

The functions in this section can serve as terms in an expression.
They fall into two major categories: list operators and named unary
operators.  These differ in their precedence relationship with a
following comma.  (See the precedence table in L<perlop>.)  List
operators take more than one argument, while unary operators can never
take more than one argument.  Thus, a comma terminates the argument of
a unary operator, but merely separates the arguments of a list
operator.  A unary operator generally provides a scalar context to its
argument, while a list operator may provide either scalar or list
contexts for its arguments.  If it does both, the scalar arguments will
be first, and the list argument will follow.  (Note that there can ever
be only one such list argument.)  For instance, splice() has three scalar
arguments followed by a list, whereas gethostbyname() has four scalar
arguments.

=end original

이 섹션의 함수는 식의 안에서 항으로써 사용할 수 있습니다.
이것들은 크게 2개로 나뉩니다.
리스트연산자와 이름붙은 단항연산자입니다.
이 둘의 차이점은 그 뒤에 나올 콤마와의 우선순위의 관계에 있습니다.
(L<perlop> 의 우ㄴ순위의 표를 참조해주세요.)
리스트연산자는 2개 이상의 인수를 얻는 것에 대해서 
단항연산자가 복수의 인수를 얻을 수는 없습니다.
즉, 콤마는 단항연산자의 인수의 끝이 되지만, 
리스트연산자의 경우에는 인수의 구분자일 뿐입니다.
단항연산자는 일반적으로 인수에 대해 스칼라컨텍스트를 주는 것에 대해서 
스칼라 연산자의 경우에는 인수에 대해서 스칼라 컨텍스트를 주는 경우도 
리스트 컨텍스트를 주는 경우도 있습니다.
하나의 리스트 연산자가 양쪽의 컨텍스트를 주는 경우에는 스칼라 인수가 
몇 개 열거되고, 마지막에 리스트 인수가 하나 계속됩니다.
(리스트 인수는 1개뿐입니다)
예를 들면 splice() 는 3개의 스칼라인수에 하나의 리스트인수가 계속됩니다.
한편 gethostbyname() 은 4개ㅢ 스칼라 인수를 얻습니다.

=begin original

In the syntax descriptions that follow, list operators that expect a
list (and provide list context for the elements of the list) are shown
with LIST as an argument.  Such a list may consist of any combination
of scalar arguments or list values; the list values will be included
in the list as if each individual element were interpolated at that
point in the list, forming a longer single-dimensional list value.
Commas should separate elements of the LIST.

=end original

마지막에 실리는 구문기술에서는 리스트를 얻어(그 리스트의 요소에 
리스트 컨텍스트를 부여) 리스트 연산자는 인수로써 LIST 를 얻도록 씁니다.
그런 리스트에는 임의의 스칼라 인수의 조합이나 리스트 값을 포함할 수 있고,
리스트 값은 리스트 안에 각각의 요소가 전개되는 것처럼 들어갑니다.
1차원의 긴 리스트값이 형성될 수도 있습니다.
LIST 요소는 콤마로 구분되어집니다.

=begin original

Any function in the list below may be used either with or without
parentheses around its arguments.  (The syntax descriptions omit the
parentheses.)  If you use the parentheses, the simple (but occasionally
surprising) rule is this: It I<looks> like a function, therefore it I<is> a
function, and precedence doesn't matter.  Otherwise it's a list
operator or unary operator, and precedence does matter.  And whitespace
between the function and left parenthesis doesn't count--so you need to
be careful sometimes:

=end original

아래의 리스트 함수는 모두, 인수의 앞뒤의 괄호는 생략가능합니다.
(구문기술에서는 생략하고 있습니다)
괄호를 사용할 때에는 단순한(하지만, 때로는 깜짝 놀랄 결과가 됩니다) 규칙을
적용할 수 있습니다: I<함수처럼 보인다면>, I<그것은 함수>이고, 우선순위는 
관계없습니다.
그렇게 보이면, 그것은 리스트 연산자가 단항연산자로, 우선순위가 관계있습니다.
또, 함수와 열린괄호의 사이의 공백은 관계없기 때문에, 때로는 
신경쓰지 않으면 안됩니다:

    print 1+2+4;	# Prints 7.
    print(1+2) + 4;	# Prints 3.
    print (1+2)+4;	# Also prints 3!
    print +(1+2)+4;	# Prints 7.
    print ((1+2)+4);	# Prints 7.

=begin original

If you run Perl with the B<-w> switch it can warn you about this.  For
example, the third line above produces:

=end original

Perl 에 B<-w> 스위치를 붙여서 실행하면 이런 것에는 경고를 냅니다.
예를 들면, 위의 3번째는 아래처럼 경고가 나옵니다:

    print (...) interpreted as function at - line 1.
    Useless use of integer addition in void context at - line 1.

=begin original

A few functions take no arguments at all, and therefore work as neither
unary nor list operators.  These include such functions as C<time>
and C<endpwent>.  For example, C<time+86_400> always means
C<time() + 86_400>.

=end original

몇 가지의 함수는 인수를 모두 얻지 않기에, 단항연산자로써도
리스트연산자로써도 동작하지 않습니다.
이런 함수로써는 C<time> 이나 C<endpwent> 가 있습니다.
예를 들면, <time+86_400> 은 항상 C<time() + 86_400> 으로 취급됩니다.

=begin original

For functions that can be used in either a scalar or list context,
nonabortive failure is generally indicated in a scalar context by
returning the undefined value, and in a list context by returning the
null list.

=end original

스칼라컨텍스트에서도 리스트 컨텍스트에서도 사용할 수 있는 함수는 
치명적이지 않은 에러를 나타내기 위해 스칼라 컨텍스트에서는 
미정의값을 반환하고, 리스트컨텍스트에서는 빈 리스트를 반환합니다.

=begin original

Remember the following important rule: There is B<no rule> that relates
the behavior of an expression in list context to its behavior in scalar
context, or vice versa.  It might do two totally different things.
Each operator and function decides which sort of value it would be most
appropriate to return in scalar context.  Some operators return the
length of the list that would have been returned in list context.  Some
operators return the first value in the list.  Some operators return the
last value in the list.  Some operators return a count of successful
operations.  In general, they do what you want, unless you want
consistency.
X<context>

=end original

아래에 기술한 중요한 룰을 잊지 않도록해주세요: 리스트 컨텍스트에서의 
행동과 스칼라 컨텍스트에서의 행동의 관게, 혹은 그 반대의 B<룰은 관계없습니>.
2 개의 전혀 다른 것이 있습니다.
각각 연산자와 함수는 스칼라 컨텍스트에서는 제일 적절하다고 생각되는 값을
반환합니다.
리스트 컨텍스트에서 반환할 때의 리스트의 길이를 반환하는 연산자도 있습니다.
리스트의 맨처음의 값을 반환하는 연산자도 있습니다.
리스트의 맨 마지막의 값을 반환하는 연산자도 있습니다.
성공한 조작의 수를 반환하는 연산자도 있습니다.
일반적으로는 일관성을 요구하지 않는 한 이쪽이 원하는 일을 합니다.

X<context>

=begin original

A named array in scalar context is quite different from what would at
first glance appear to be a list in scalar context.  You can't get a list
like C<(1,2,3)> into being in scalar context, because the compiler knows
the context at compile time.  It would generate the scalar comma operator
there, not the list construction version of the comma.  That means it
was never a list to start with.

=end original

스칼라 컨텍스트에서의 이름붙은 배열은, 스칼라컨텍스트에서의 리스트를 
한번 본 것과는 전혀 다릅니다.
컴파일러는 컴파일 시에 컨텍스트를 알고 있기 때문에, C<(1,2,3)> 같은 
리스트를 스칼라 컨텍스트로 얻을 수는 없습니다. 
이것은 스칼라 컴마 연산자를 생성하고, 컴마의 리스트 작성판이 아닙니다.
이것은 처음부터 리스트가 아니라는 것을 의미합니다.

=begin original

In general, functions in Perl that serve as wrappers for system calls
of the same name (like chown(2), fork(2), closedir(2), etc.) all return
true when they succeed and C<undef> otherwise, as is usually mentioned
in the descriptions below.  This is different from the C interfaces,
which return C<-1> on failure.  Exceptions to this rule are C<wait>,
C<waitpid>, and C<syscall>.  System calls also set the special C<$!>
variable on failure.  Other functions do not, except accidentally.

=end original

일반적으로, 같은 이름의 시스템 호출의 래퍼로써 동작하는 Perl 함수 
(chown(2), fork(2), closedir(2) 같은)는 아래에 기술한대로, 
성공 시에 참을 반환하고 그렇지 않으면 C<undef> 를 반환합니다.
이것은 실패 시에 C<-1> 을 반환하는 C 의 인터페이스와는 다릅니다.
이 룰의 예외는 C<wait>, C<waitpid>, C<syscall> 입니다.
시스템 호출은 실패시에 특수변수 C<$!> 을 설정합니다.
그 외의 함수는 사고를 빼고는 설정하지 않습니다.

=head2 Perl Functions by Category
X<function>

(카테고리 별 Perl 함수)

=begin original

Here are Perl's functions (including things that look like
functions, like some keywords and named operators)
arranged by category.  Some functions appear in more
than one place.

=end original

아래에 카테고리 별 함수(키워나 이름붙은 연산자같은 함수처럼 보이는 것도 
파함합니다) 를 나타냅니다. 
여러 곳에 나타나는 함수도 있습니다.

=over 4

=item Functions for SCALARs or strings
X<scalar> X<string> X<character>

(스칼라나 문자열을 위한 함수)

C<chomp>, C<chop>, C<chr>, C<crypt>, C<hex>, C<index>, C<lc>, C<lcfirst>,
C<length>, C<oct>, C<ord>, C<pack>, C<q//>, C<qq//>, C<reverse>,
C<rindex>, C<sprintf>, C<substr>, C<tr///>, C<uc>, C<ucfirst>, C<y///>

=item Regular expressions and pattern matching
X<regular expression> X<regex> X<regexp>

(정규표현과 패턴매칭)

C<m//>, C<pos>, C<quotemeta>, C<s///>, C<split>, C<study>, C<qr//>

=item Numeric functions
X<numeric> X<number> X<trigonometric> X<trigonometry>

(숫자값 함수)

C<abs>, C<atan2>, C<cos>, C<exp>, C<hex>, C<int>, C<log>, C<oct>, C<rand>,
C<sin>, C<sqrt>, C<srand>

=item Functions for real @ARRAYs
X<array>

(실제 배열을 위한 함수)

C<pop>, C<push>, C<shift>, C<splice>, C<unshift>

=item Functions for list data
X<list>

(리스트 데이터를 위한 함수)

C<grep>, C<join>, C<map>, C<qw//>, C<reverse>, C<sort>, C<unpack>

=item Functions for real %HASHes
X<hash>

(실제 해쉬를 위한 함수)

C<delete>, C<each>, C<exists>, C<keys>, C<values>

=item Input and output functions
X<I/O> X<input> X<output> X<dbm>

(입출력 함수)

C<binmode>, C<close>, C<closedir>, C<dbmclose>, C<dbmopen>, C<die>, C<eof>,
C<fileno>, C<flock>, C<format>, C<getc>, C<print>, C<printf>, C<read>,
C<readdir>, C<rewinddir>, C<say>, C<seek>, C<seekdir>, C<select>, C<syscall>,
C<sysread>, C<sysseek>, C<syswrite>, C<tell>, C<telldir>, C<truncate>,
C<warn>, C<write>

=item Functions for fixed length data or records

(고정길이 데이터나 레코드를 위한 함수)

C<pack>, C<read>, C<syscall>, C<sysread>, C<syswrite>, C<unpack>, C<vec>

=item Functions for filehandles, files, or directories
X<file> X<filehandle> X<directory> X<pipe> X<link> X<symlink>

(파일핸들, 파일, 디렉토리를 위한 함수)

C<-I<X>>, C<chdir>, C<chmod>, C<chown>, C<chroot>, C<fcntl>, C<glob>,
C<ioctl>, C<link>, C<lstat>, C<mkdir>, C<open>, C<opendir>,
C<readlink>, C<rename>, C<rmdir>, C<stat>, C<symlink>, C<sysopen>,
C<umask>, C<unlink>, C<utime>

=item Keywords related to the control flow of your Perl program
X<control flow>

(프로그램의 흐름을 제어하는 것에 관련된 키워드)

C<caller>, C<continue>, C<die>, C<do>, C<dump>, C<eval>, C<exit>,
C<goto>, C<last>, C<next>, C<redo>, C<return>, C<sub>, C<wantarray>

=item Keywords related to switch

(switch 에 관련된 키워드)

C<break>, C<continue>, C<given>, C<when>, C<default>

=begin original

(These are only available if you enable the "switch" feature.
See L<feature> and L<perlsyn/"Switch statements">.)

=end original

(이것들은 "swtich" 기능이 유효한 경우에만 이용가능합니다.
L<feature> 와 L<perlsyn/"Switch statemnets"> 를 참조해주세요.)

=item Keywords related to scoping

(영역에 관한 키워드)

C<caller>, C<import>, C<local>, C<my>, C<our>, C<state>, C<package>,
C<use>

=begin original

(C<state> is only available if the "state" feature is enabled. See
L<feature>.)

=end original

(C<state> 는 "state" 기능이 유효한 경우에만 이용가능합니다.
L<feature> 를 참조해주세요.)

=item Miscellaneous functions

(여러가지 함수)

C<defined>, C<dump>, C<eval>, C<formline>, C<local>, C<my>, C<our>,
C<reset>, C<scalar>, C<state>, C<undef>, C<wantarray>

=item Functions for processes and process groups
X<process> X<pid> X<process id>

(프로세스와 프로세스그룹을 위한 함수)

C<alarm>, C<exec>, C<fork>, C<getpgrp>, C<getppid>, C<getpriority>, C<kill>,
C<pipe>, C<qx//>, C<setpgrp>, C<setpriority>, C<sleep>, C<system>,
C<times>, C<wait>, C<waitpid>

=item Keywords related to perl modules
X<module>

(perl 모듈에 관한 키워드)

C<do>, C<import>, C<no>, C<package>, C<require>, C<use>

=item Keywords related to classes and object-orientation
X<object> X<class> X<package>

(클래스와 오브젝트 지향에 관한 키워드)

C<bless>, C<dbmclose>, C<dbmopen>, C<package>, C<ref>, C<tie>, C<tied>,
C<untie>, C<use>

=item Low-level socket functions
X<socket> X<sock>

(저레벨 소켓함수)

C<accept>, C<bind>, C<connect>, C<getpeername>, C<getsockname>,
C<getsockopt>, C<listen>, C<recv>, C<send>, C<setsockopt>, C<shutdown>,
C<socket>, C<socketpair>

=item System V interprocess communication functions
X<IPC> X<System V> X<semaphore> X<shared memory> X<memory> X<message>

(System V 프로세스간 통신함수)

C<msgctl>, C<msgget>, C<msgrcv>, C<msgsnd>, C<semctl>, C<semget>, C<semop>,
C<shmctl>, C<shmget>, C<shmread>, C<shmwrite>

=item Fetching user and group info
X<user> X<group> X<password> X<uid> X<gid>  X<passwd> X</etc/passwd>

(유저와 그룹의 정보 취득)

C<endgrent>, C<endhostent>, C<endnetent>, C<endpwent>, C<getgrent>,
C<getgrgid>, C<getgrnam>, C<getlogin>, C<getpwent>, C<getpwnam>,
C<getpwuid>, C<setgrent>, C<setpwent>

=item Fetching network info
X<network> X<protocol> X<host> X<hostname> X<IP> X<address> X<service>

(네트워크 정보 획득)

C<endprotoent>, C<endservent>, C<gethostbyaddr>, C<gethostbyname>,
C<gethostent>, C<getnetbyaddr>, C<getnetbyname>, C<getnetent>,
C<getprotobyname>, C<getprotobynumber>, C<getprotoent>,
C<getservbyname>, C<getservbyport>, C<getservent>, C<sethostent>,
C<setnetent>, C<setprotoent>, C<setservent>

=item Time-related functions
X<time> X<date>

(시각에 관함함수)

C<gmtime>, C<localtime>, C<time>, C<times>

=item Functions new in perl5
X<perl5>

(perl5 에서의 새로운 함수)

C<abs>, C<bless>, C<break>, C<chomp>, C<chr>, C<continue>, C<default>, 
C<exists>, C<formline>, C<given>, C<glob>, C<import>, C<lc>, C<lcfirst>,
C<lock>, C<map>, C<my>, C<no>, C<our>, C<prototype>, C<qr//>, C<qw//>, C<qx//>,
C<readline>, C<readpipe>, C<ref>, C<sub>*, C<sysopen>, C<tie>, C<tied>, C<uc>,
C<ucfirst>, C<untie>, C<use>, C<when>

=begin original

* - C<sub> was a keyword in perl4, but in perl5 it is an
operator, which can be used in expressions.

=end original

* - C<sub> 는 perl4 에서는 키워드이지만, petl5 에서는 연산자이기에 식으로
사용할 수 있습니다.

=item Functions obsoleted in perl5

(perl5 에서는 낡은 함수)

C<dbmclose>, C<dbmopen>

=back

=head2 Portability
X<portability> X<Unix> X<portable>

(이식성)

=begin original

Perl was born in Unix and can therefore access all common Unix
system calls.  In non-Unix environments, the functionality of some
Unix system calls may not be available, or details of the available
functionality may differ slightly.  The Perl functions affected
by this are:

=end original

Perl 은 Unix 환경에서 태어났기 때문에 모든 공통하는 Unix 시스템 호출에 
접근합니다. 비 Unix 환경에서는 몇 가지의 Unix 시스템 호ㄹ의 
기능을 사용할 수 없거나, 사용할 수 있는 기능의 상세 내용이 조금 
다르거나 합니다.
이것에 의해 영향을 받는 Perl 함수는 아래와 같습니다:

C<-X>, C<binmode>, C<chmod>, C<chown>, C<chroot>, C<crypt>,
C<dbmclose>, C<dbmopen>, C<dump>, C<endgrent>, C<endhostent>,
C<endnetent>, C<endprotoent>, C<endpwent>, C<endservent>, C<exec>,
C<fcntl>, C<flock>, C<fork>, C<getgrent>, C<getgrgid>, C<gethostbyname>,
C<gethostent>, C<getlogin>, C<getnetbyaddr>, C<getnetbyname>, C<getnetent>,
C<getppid>, C<getpgrp>, C<getpriority>, C<getprotobynumber>,
C<getprotoent>, C<getpwent>, C<getpwnam>, C<getpwuid>,
C<getservbyport>, C<getservent>, C<getsockopt>, C<glob>, C<ioctl>,
C<kill>, C<link>, C<lstat>, C<msgctl>, C<msgget>, C<msgrcv>,
C<msgsnd>, C<open>, C<pipe>, C<readlink>, C<rename>, C<select>, C<semctl>,
C<semget>, C<semop>, C<setgrent>, C<sethostent>, C<setnetent>,
C<setpgrp>, C<setpriority>, C<setprotoent>, C<setpwent>,
C<setservent>, C<setsockopt>, C<shmctl>, C<shmget>, C<shmread>,
C<shmwrite>, C<socket>, C<socketpair>,
C<stat>, C<symlink>, C<syscall>, C<sysopen>, C<system>,
C<times>, C<truncate>, C<umask>, C<unlink>,
C<utime>, C<wait>, C<waitpid>

=begin original

For more information about the portability of these functions, see
L<perlport> and other available platform-specific documentation.

=end original

이 함수들의 이식성에 관한 정보데 대해서는 L<perlport> 와 
그 외의 플랫폼고유의 도메인을 참조해주세요.

=head2 Alphabetical Listing of Perl Functions

=over 8

=item -X FILEHANDLE
X<-r>X<-w>X<-x>X<-o>X<-R>X<-W>X<-X>X<-O>X<-e>X<-z>X<-s>X<-f>X<-d>X<-l>X<-p>
X<-S>X<-b>X<-c>X<-t>X<-u>X<-g>X<-k>X<-T>X<-B>X<-M>X<-A>X<-C>

=item -X EXPR

=item -X DIRHANDLE

=item -X

=begin original

A file test, where X is one of the letters listed below.  This unary
operator takes one argument, either a filename, a filehandle, or a dirhandle, 
and tests the associated file to see if something is true about it.  If the
argument is omitted, tests C<$_>, except for C<-t>, which tests STDIN.
Unless otherwise documented, it returns C<1> for true and C<''> for false, or
the undefined value if the file doesn't exist.  Despite the funny
names, precedence is the same as any other named unary operator.  The
operator may be any of:

=end original

X 는 아래에 주는 문자로, 파일 테스트를 수행합니다.
이 단항연산자는 파일이름이나 파일핸들을 유일한 인수로써 동작하고,
"어떤 것"에 대해 참인지 거짓인지를 판정한 결과를 반환합니다.
인수가 생략되면, C<-t> 에서는 STDIN 을 조사하지만, 그 외에는 C<$_> 를 조사합니다.
특히 기술되지 않으면, 참으로써 C<1> 을 반환하고, 거짓으로써 C<''> 를 반환하고,
파일이 존재하지 않으면, 미정의값을 반환합니다.
겉보기에는 바뀌었지만, 우선순위는 이름붙은 단항연산자와 같으며, 
다른 단항연산자처럼 인수를 괄호로 묶을 수도 있습니다.
연산자에는 아래와 같은 것들이 있습니다:

=begin original

    -r	File is readable by effective uid/gid.
    -w	File is writable by effective uid/gid.
    -x	File is executable by effective uid/gid.
    -o	File is owned by effective uid.

=end original

    -r  파일이 실효한 uid/gid 로 읽기 가능 
    -w  파일이 실효한 uid/gid 로 쓰기 가능
    -x  파일이 실효한 uid/gid 로 실행 가능 
    -o  파일이 실효한 uid 소유물

=begin original

    -R	File is readable by real uid/gid.
    -W	File is writable by real uid/gid.
    -X	File is executable by real uid/gid.
    -O	File is owned by real uid.

=end original

    -R  파일이 진짜 uid/gid 로 읽기 가능
    -W  파일이 진짜 uid/gid 로 쓰기 가능
    -X  파일이 진짜 uid/gid 로 실행 가능
    -O  파일이 진짜 uid 소유물 

=begin original

    -e	File exists.
    -z	File has zero size (is empty).
    -s	File has nonzero size (returns size in bytes).

=end original

    -e  파일이 존재
    -z  파일의 크기가 제로(빈 파일)
    -s  파일의 크기가 제로 이외 (바이트 단위로 크기를 반환)

=begin original

    -f	File is a plain file.
    -d	File is a directory.
    -l	File is a symbolic link.
    -p	File is a named pipe (FIFO), or Filehandle is a pipe.
    -S	File is a socket.
    -b	File is a block special file.
    -c	File is a character special file.
    -t	Filehandle is opened to a tty.

=end original

    -f  파일은 통상의 파일 
    -d  파일은 디렉토리
    -l  파일은 심볼릭 링크
    -p  파일은 이름붙은 파이프(FIFO) 또는 파일 핸들은 파이프
    -S  파일은 소켓
    -b  파일은 블록 특수 파일 
    -c  파일은 캐릭터 특수 파일
    -t  파일 핸들은 tty 에 오픈되어 있다

=begin original

    -u	File has setuid bit set.
    -g	File has setgid bit set.
    -k	File has sticky bit set.

=end original

    -u  파일의 setuid 비트가 설정되어 있다
    -g  파일의 setgid 비트가 설정되어 있다
    -k  파일의 sticky 비트가 설정되어 있다

=begin original

    -T	File is an ASCII text file (heuristic guess).
    -B	File is a "binary" file (opposite of -T).

=end original

    -T  파일은 ASCII 텍스트 파일 (유추)
    -B  파일은 바이너리 파일 (-T 의 반대)

=begin original

    -M	Script start time minus file modification time, in days.
    -A	Same for access time.
    -C	Same for inode change time (Unix, may differ for other platforms)

=end original

    -M  스크립트 실행시각에서 파일 수정시각을 뺀 것(날짜 단위)
    -A  똑같이 접근이 있고부터의 일수
    -C  똑같이(Unix 에서는) inode 가 변경되고서의 일수(그 외의 플랫폼에서는 다를지도 모릅니다)

=begin original

Example:

=end original

예제:

    while (<>) {
	chomp;
	next unless -f $_;	# ignore specials
	#...
    }

=begin original

The interpretation of the file permission operators C<-r>, C<-R>,
C<-w>, C<-W>, C<-x>, and C<-X> is by default based solely on the mode
of the file and the uids and gids of the user.  There may be other
reasons you can't actually read, write, or execute the file: for
example network filesystem access controls, ACLs (access control lists),
read-only filesystems, and unrecognized executable formats.  Note
that the use of these six specific operators to verify if some operation
is possible is usually a mistake, because it may be open to race
conditions.

=end original

파일의 퍼미션 연산자 C<-r>, C<-R>, C<-w>, C<-W>, C<-x>, C<-X> 의 해석은
파일의 모드와 유저의 실효/실 uid 와 실효/실 gid 만으로 판단됩니다.
실제로 파일을 읽을 수 있거나, 쓸 수 있거나, 실행할 수 있게 하기 위해서는
별도의 조건이 필요할지도 모릅니다.
예를들면, 네트워크 파일시스템접근 컨트롤, ACL(Access Control List), 
일기 전용 파일시스템, 인식 할수 없는 실행파일 포맷 등입니다.
이 6개의 연산자들을 특정의 조작이 가능한지를 확인하기 위해 사용하는 것은
일반적으로는 오해라는 것에 주의해주세요; 왜냐면, 이것들은 경합조건을 
빼기 쉽기때문입니다.

=begin original

Also note that, for the superuser on the local filesystems, the C<-r>,
C<-R>, C<-w>, and C<-W> tests always return 1, and C<-x> and C<-X> return 1
if any execute bit is set in the mode.  Scripts run by the superuser
may thus need to do a stat() to determine the actual mode of the file,
or temporarily set their effective uid to something else.

=end original

로컬파일 시스템의 수퍼유저에게는 C<-r>, C<-R>, C<-w>, C<-W> 에 대해서 
항상 1이 반환되고, 모드 중의 어떤것이 실행허가 비트가 서 있으면, 
C<-x>, C<-X> 에도 1이 반환되는 것에도 주의해주세요.
수퍼유저가 실헹하는 스크립트에서는, 파일의 모드를 조사하기위해서는
stat() 을 실행할 거나 실효 uid 를 일시적으로 별도의 것으로 할 필요가 있습니다.

=begin original

If you are using ACLs, there is a pragma called C<filetest> that may
produce more accurate results than the bare stat() mode bits.
When under the C<use filetest 'access'> the above-mentioned filetests
will test whether the permission can (not) be granted using the
access() family of system calls.  Also note that the C<-x> and C<-X> may
under this pragma return true even if there are no execute permission
bits set (nor any extra execute permission ACLs).  This strangeness is
due to the underlying system calls' definitions. Note also that, due to
the implementation of C<use filetest 'access'>, the C<_> special
filehandle won't cache the results of the file tests when this pragma is
in effect.  Read the documentation for the C<filetest> pragma for more
information.

=end original

ACL 을 사용하고 있는 경우는 현재의 stat() 모드비트보다도 정밀도 높은 
결과를 작성하는 C<filetest> 프라그마가 있습니다.
C<use filetest 'access'> 라고 한 경우, 위에 기술한 파일테스트는 
시스템 호ㄹ의 access() 패밀리를 사용해서 권한을 줄수 있는가 어떤 가를 
테스트합니다.
또, 이 프라그마가 지정된 경우, C<-x> 와 C<-X> 는 설령 실행허가비트
(또는 추가의 실행허가 ACL) 이 설정되어 있지 않은 경우에도 
참을 반환하는 것에 주의해주세요.
이 동작은 사용하는 시스템 호출의 정의에 의한 것입니다. 
C<use filetest 'access'> 의 구성에 의해, 이 프라그마가 유효한 경우는 
C<_> 특수 파일핸들은 파일테스트의 결과를 캐쉬하지 않는 것에 주의해주세요.
보다 자세한 정보에 대해서는 C<filetest> 프라그마의 문서를 참조해주세요.

=begin original

Note that C<-s/a/b/> does not do a negated substitution.  Saying
C<-exp($foo)> still works as expected, however--only single letters
following a minus are interpreted as file tests.

=end original

C<-s/a/b> 는 치환연산 (s///) 의 부호반전이 아닙니.
그러나, C<-exp($foo)> 는 기대한 대로 동작합니다.
마이너스 기호의 뒤에 영어가 1자가 따라붙을 때에만 파일 테스트로 해석됩니다.

=begin original

The C<-T> and C<-B> switches work as follows.  The first block or so of the
file is examined for odd characters such as strange control codes or
characters with the high bit set.  If too many strange characters (>30%)
are found, it's a C<-B> file; otherwise it's a C<-T> file.  Also, any file
containing null in the first block is considered a binary file.  If C<-T>
or C<-B> is used on a filehandle, the current IO buffer is examined
rather than the first block.  Both C<-T> and C<-B> return true on a null
file, or a file at EOF when testing a filehandle.  Because you have to
read a file to do the C<-T> test, on most occasions you want to use a C<-f>
against the file first, as in C<next unless -f $file && -T $file>.

=end original

파일테스트 C<-T> 와 C<-B> 의 동작원리는 다음처럼 되어있습니다.
파일의 최초의 수 블록을 조사하고, 바뀐 제어코드나 상위 비트가 설정되어 있는
일반적인 텍스트에는 나타나지 않는 문자를 찾습니다.
그런 문자가 많이(>30%) 발견되면 그 파일은 C<-B> 파일인 것으 판단됩니다.
그렇지 않으면 C<-T> 파일이 됩니다.
최초의 블록에 스루문자가 포함되어 있는 파일도, 바이너리 파일로 간주합니다.
C<-T> 나 C<-B> 를 파인핸들에 대해서 사용하면,
맨처음ㅢ 블록을 조사하는 대신에 IO 버퍼를 조사합니다.
조사한 파일의 내용이 아무것도 없을 때나, 파일핸들을 조사할 때에 EOF 에 
도달한 때에는 C<-T> 도 C<-B> 도 참을 반환합니다.
C<-T> 테스트를 하기 위해서는 파일을 읽어들이지 않으면 안되기 때문에 
대개는 C<next unless -f $file && ^T $file> 과 같은 형태로 
우선은 조사하고 싶은 파일에 대해서 C<-f> 를 사용하고 싶을 겁니다.

=begin original

If any of the file tests (or either the C<stat> or C<lstat> operators) are given
the special filehandle consisting of a solitary underline, then the stat
structure of the previous file test (or stat operator) is used, saving
a system call.  (This doesn't work with C<-t>, and you need to remember
that lstat() and C<-l> will leave values in the stat structure for the
symbolic link, not the real file.)  (Also, if the stat buffer was filled by
an C<lstat> call, C<-T> and C<-B> will reset it with the results of C<stat _>).
Example:

=end original

어느 파일테스트(혹은 C<stat> 이나 C<lstat>) 연산자에도, 
밑줄에서부터 만들어지는 특별한 파일핸들을 주면,
앞의 파일테스트(나 stat) 의 stat 구조체가 사용되어 시스템 호출을 생략합니다.
(C<-t> 에는 사용할 수 없고, lstat() 나 C<-l> 는 실제 파일이 아니고, 
심볼릭링크의 정보를 stat 구조체에 남기는 것을 기억해둘 필요가 있습니다.)
(또, stat 버퍼가 C<lstat> 호출로 넣어진 경우, 
C<-T> 와 C<-B> 의 결과는 C<stat _> 의 결과로 리셋됩니다.
예제:

    print "Can do.\n" if -r $a || -w _ || -x _;

    stat($filename);
    print "Readable\n" if -r _;
    print "Writable\n" if -w _;
    print "Executable\n" if -x _;
    print "Setuid\n" if -u _;
    print "Setgid\n" if -g _;
    print "Sticky\n" if -k _;
    print "Text\n" if -T _;
    print "Binary\n" if -B _;

=begin original

As of Perl 5.9.1, as a form of purely syntactic sugar, you can stack file
test operators, in a way that C<-f -w -x $file> is equivalent to
C<-x $file && -w _ && -f _>. (This is only syntax fancy: if you use
the return value of C<-f $file> as an argument to another filetest
operator, no special magic will happen.)

=end original

Perl 5.9.1 에서 순수하게 신택스 슈거로써 파일테스트 연산를 
스택시키는 것이 가능하기에 C<-f -w -x $file> 은 
C<-x $file && -w _ && -f _> 와 같습니다.
(이것은 문법상에서만의 얘기입니다; 만약 C<-f $file> 의 반환값을 
다른파일 테스트 연산자의 인수로써 사용하는 경우는 어떤 특별한 것도 
일어나지 않습니다)

=item abs VALUE
X<abs> X<absolute>

=item abs

=begin original

Returns the absolute value of its argument.
If VALUE is omitted, uses C<$_>.

=end original

인수의 절대값을 반환합니다.
VALUE 가 생략된 경우는 C<$_> 를 사용합니다.

=item accept NEWSOCKET,GENERICSOCKET
X<accept>

=begin original

Accepts an incoming socket connect, just as the accept(2) system call
does.  Returns the packed address if it succeeded, false otherwise.
See the example in L<perlipc/"Sockets: Client/Server Communication">.

=end original

accept(2) 시스템 호출처럼, 착신하는 소켓의 접속을 접합니다.
성공시에는 pack 된 주소를 반환하고, 실패하면 거짓을 반환합니다.
L<perlipc/"Sockets: Client/Server Communication"> 의 예제를 참조해주세요.

=begin original

On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptor, as determined by the
value of $^F.  See L<perlvar/$^F>.

=end original

파일에 대해 close-on-exec 플래그를 서포트하고 있는 시스템에서는 
플래그는 $^F 의 값으로 결정되고, 새롭게 오픈된 파일 기술자에 대해서
설정됩니다. L<perlvar/$^F> 를 참조해주세요.

=item alarm SECONDS
X<alarm>
X<SIGALRM>
X<timer>

=item alarm

=begin original

Arranges to have a SIGALRM delivered to this process after the
specified number of wallclock seconds has elapsed.  If SECONDS is not
specified, the value stored in C<$_> is used. (On some machines,
unfortunately, the elapsed time may be up to one second less or more
than you specified because of how seconds are counted, and process
scheduling may delay the delivery of the signal even further.)

=end original

지정한 벽시계초수가 경과한 뒤에 자기 프로세스에 SIGALRM 이 
전송되도록 합ㅣ다. SECONDS 가 지정되어 있지 않은 경우는 
C<$_> 에 있는 값을 사용합니다.
(머신에 따라서는 초를 세는 법이 다르기 때문에 지정한 초수보다도 
최대 1초의 차가 있습니다)

=begin original

Only one timer may be counting at once.  Each call disables the
previous timer, and an argument of C<0> may be supplied to cancel the
previous timer without starting a new one.  The returned value is the
amount of time remaining on the previous timer.

=end original

한번에 하나의 타이머만이 설정가능합니다.
호출을 수행할 때마다 이전의 타이머를 무효화하고, 
새로운 타이머를 기동하지 않고 이전의 타이머를 캔슬하기 위해 
인수에 C<0> 을 설정하고 호출할 수 있습니다.
이전의 타이머의 남은 시간이 반환값이 됩니다.

=begin original

For delays of finer granularity than one second, the Time::HiRes module
(from CPAN, and starting from Perl 5.8 part of the standard
distribution) provides ualarm().  You may also use Perl's four-argument
version of select() leaving the first three arguments undefined, or you
might be able to use the C<syscall> interface to access setitimer(2) if
your system supports it. See L<perlfaq8> for details.

=end original

1초보다 정밀도 높은 슬리프를 수행하려면, Time::HiRes 모듈(CPAN 에서, 
또는 Perl 5.8에서는 표준배포되어있습니다) 이 ualaram() 을 제공합니다.
Perl 의 4인수판 select() 를 최초의 3인수를 미정의해서 사용하든 지
settimer(2) 를 지원하고 있는 시스템에서는 Perl 의 
C<syscall> 인터페이스를 사용해서 접근하는 것도 가능합니다.
자세한 내용은 L<perlfaq8> 을 참조해주세요.

=begin original

It is usually a mistake to intermix C<alarm> and C<sleep> calls.
(C<sleep> may be internally implemented in your system with C<alarm>)

=end original

C<alarm> 과 C<sleep> 를 섞어서 사용하는 것은 통상적으로는 잘못된 것입니다.
(C<sleep> 는 내부적으로 C<alarm> 을 사용해서 내부적으로 구성되어 있을 지도
모릅니다)

=begin original

If you want to use C<alarm> to time out a system call you need to use an
C<eval>/C<die> pair.  You can't rely on the alarm causing the system call to
fail with C<$!> set to C<EINTR> because Perl sets up signal handlers to
restart system calls on some systems.  Using C<eval>/C<die> always works,
modulo the caveats given in L<perlipc/"Signals">.

=end original

C<alarm> 을 시스템 호출의 시간단축을 위해 사용하고 싶다면, 
C<eval>/C<die> 의 쌍으로 사용할 필요가 있습니다.
시스템 호출이 실패한 때에 C<$!> 에 C<EINTR> 이 설정되어 있는 것에
연결해서는 안됩니다. 왜냐면 시스템에 의해서는 Perl 은 
시스템 호출을 재개하기 위해 시그널 핸들러를 설정하기 때문입니다.
C<eval>/C<die> 는 항상 잘 움직입니다.
주의점에 대해서는 C<Lperlipc/"Signals"> 를 참조해주세요.

    eval {
	local $SIG{ALRM} = sub { die "alarm\n" }; # NB: \n required
	alarm $timeout;
	$nread = sysread SOCKET, $buffer, $size;
	alarm 0;
    };
    if ($@) {
	die unless $@ eq "alarm\n";   # propagate unexpected errors
    	# timed out
    }
    else {
    	# didn't
    }

=begin original

For more information see L<perlipc>.

=end original

보다 자세한 정보에 대해서는 L<perlipc>를 참조해주세요.

=item atan2 Y,X
X<atan2> X<arctangent> X<tan> X<tangent>

=begin original

Returns the arctangent of Y/X in the range -PI to PI.

=end original

-π에서π의 범위로 Y/X 의 역정접을 반환합니다. 

=begin original

For the tangent operation, you may use the C<Math::Trig::tan>
function, or use the familiar relation:

=end original

정접을 구하기 위해서는, C<Math::Trig::tan> 을 사용하든가 
아래의 잘 알려진 함수를 사용해 주세요.

    sub tan { sin($_[0]) / cos($_[0])  }

=begin original

Note that atan2(0, 0) is not well-defined.

=end original

atan2(0, 0) 은 미정의인 것에 주의해주세요.

=item bind SOCKET,NAME
X<bind>

=begin original

Binds a network address to a socket, just as the bind system call
does.  Returns true if it succeeded, false otherwise.  NAME should be a
packed address of the appropriate type for the socket.  See the examples in
L<perlipc/"Sockets: Client/Server Communication">.

=end original

bind(2) 시스템 호출 처럼, 네트워크주소를 소켓에 연결합니다.
성공시에는 참을 반환하고, 실패시에는 거짓을 반환합니다.
NAME 은 , 소켓에 대해 적절한 형태로 pack 된 주소가 아니면 안됩니다.
L<perlipc/"Sockets: Client/Server Communication"> 의 예제를 참조해주세요.

=item binmode FILEHANDLE, LAYER
X<binmode> X<binary> X<text> X<DOS> X<Windows>

=item binmode FILEHANDLE

=begin original

Arranges for FILEHANDLE to be read or written in "binary" or "text"
mode on systems where the run-time libraries distinguish between
binary and text files.  If FILEHANDLE is an expression, the value is
taken as the name of the filehandle.  Returns true on success,
otherwise it returns C<undef> and sets C<$!> (errno).

=end original

바이너리 파일과 텍스트파일을 구별하는 OS에서는 
FILEHANDLE 을 "바이너리" 혹은 "텍스트" 로 읽도록 지정합니다.
FILEHANDLE 이 식인 경우에는, 그 식의 값이 파일핸들의 이름으로 사용됩니다.

=begin original

On some systems (in general, DOS and Windows-based systems) binmode()
is necessary when you're not working with a text file.  For the sake
of portability it is a good idea to always use it when appropriate,
and to never use it when it isn't appropriate.  Also, people can
set their I/O to be by default UTF-8 encoded Unicode, not bytes.

=end original

텍스트파일이 아닌 것을 다루는 경우에 bindmode() 가 필요한 
시스템도 있습니다(일반적으로는 DOS 와 Windows 기반의 시스템입니다).
이식성을 위해서 적절한 때에는 항상 이것을 사용하고, 적절하지 않을 때에는
결코 사용하지 않는 것은 좋은 생각입니다.
또, 기본값으로써 I/O 를 bytes 가 아닌 UTF-8 인코드 된 Unicode 로 
정의하는 것도 가능합니다.

=begin original

In other words: regardless of platform, use binmode() on binary data,
like for example images.

=end original

바꿔 말하면: 플랫폼에 상관없이 예제의 이미지처럼 바이너리 파일에 대해서는
binmode() 를 사용해 주세요.

=begin original

If LAYER is present it is a single string, but may contain multiple
directives. The directives alter the behaviour of the file handle.
When LAYER is present using binmode on text file makes sense.

=end original

LAYER 가 존재하면, 그것은 단일의 문자열이지만, 복수의 지시자를 
포함할 수가 있습니다.
지시자는 파일핸들의 행동을 변경합니다.
LAYER 가 존재하면, 텍스트 파일에서의 binmode 가 의미를 가집니다.

=begin original

If LAYER is omitted or specified as C<:raw> the filehandle is made
suitable for passing binary data. This includes turning off possible CRLF
translation and marking it as bytes (as opposed to Unicode characters).
Note that, despite what may be implied in I<"Programming Perl"> (the
Camel) or elsewhere, C<:raw> is I<not> simply the inverse of C<:crlf>
-- other layers which would affect the binary nature of the stream are
I<also> disabled. See L<PerlIO>, L<perlrun> and the discussion about the
PERLIO environment variable.

=end original

LAYER 가 생략되거나, C<:raw> 가 지정되면, 파일핸들은 바이너리 데이터의 
통과에 적합하게 설정됩니다.
이것에는 CRLF 변환ㅡㄹ 끄거나, 각각을 (Unicode 문자가 아닌) 
바이트이면 마크하거하 한 것을 포함합니다.
I<"프로그래밍 Perl"> (낙타책) 이나 그 외에 암시되어 있는 것에도 상관없이 
C<:raw:> 는 단순히 C<:crlf> 의 I<반대가 아닙니다> -- 스트림의 
바이너리로써의 성질에 영향을 주는 I<그 외의 계층도 무효화됩니다>.
L<PerlIO>, L<perlrun> 및 PERLIO 환경변수에 관한 의논을 참조하세요.

=begin original

The C<:bytes>, C<:crlf>, and C<:utf8>, and any other directives of the
form C<:...>, are called I/O I<layers>.  The C<open> pragma can be used to
establish default I/O layers.  See L<open>.

=end original

C<:bytes>, C<:crlf>, C<:utf8> 와 그외의 C<:...> 형식의 지시자는 
I/O I<층> 이 호출됩니다.
C<open> 프라그마는 기본 I/O 층을 지정하기 위해 사용됩니다.
L<open> 을 참조해주세요.

=begin original

I<The LAYER parameter of the binmode() function is described as "DISCIPLINE"
in "Programming Perl, 3rd Edition".  However, since the publishing of this
book, by many known as "Camel III", the consensus of the naming of this
functionality has moved from "discipline" to "layer".  All documentation
of this version of Perl therefore refers to "layers" rather than to
"disciplines".  Now back to the regularly scheduled documentation...>

=end original

I<binmode() 함수의 LAYER 파라미터는 "프로그래밍 Perl 제 3판" 에서는 
"디시플린(DISCIPLINE)" 이라고 표현되어 있습니다.
그러나 "낙타책 제 3판" 으로 알려진 이 책의 출판 뒤에, 이 기능의 이름은 
"DISCIPLINE" 에서 "계층" 으로 변경한 것으로 합의되었습니다.
따라서, 이 버젼의 Perl 의 모든 문서에서는 "DISCIPLINE" 이 아닌 
"계층"으로 기술되어 있습니다. 그럼 다시 해설로 돌아가겠습니다. >

=begin original

To mark FILEHANDLE as UTF-8, use C<:utf8> or C<:encoding(utf8)>.
C<:utf8> just marks the data as UTF-8 without further checking,
while C<:encoding(utf8)> checks the data for actually being valid
UTF-8. More details can be found in L<PerlIO::encoding>.

=end original

FILEHANDLE 이 UTF-8 인 마크를 붙이기에는, C<:utf8>  이나 
C<:encoding(utf8)> 을 사용해주세요.
C<:utf8> 은 보다 더 체크없이 데이터가 UTF-8 으로써 마크하지만, 
C<:encoding(utf8)> 은 데이터가 실제로 유효한 UTF-8 인지 어떤지를 체크합니다.
보다 자세한 내용은 L<PerIO::encoding> 에 있습니다.

=begin original

In general, binmode() should be called after open() but before any I/O
is done on the filehandle.  Calling binmode() will normally flush any
pending buffered output data (and perhaps pending input data) on the
handle.  An exception to this is the C<:encoding> layer that
changes the default character encoding of the handle, see L<open>.
The C<:encoding> layer sometimes needs to be called in
mid-stream, and it doesn't flush the stream.  The C<:encoding>
also implicitly pushes on top of itself the C<:utf8> layer because
internally Perl will operate on UTF-8 encoded Unicode characters.

=end original

일반적으로 binmode() 는 open() 호출 뒤, 이 파일핸들에 대한 I/O 조작을 
하기 전에 호출되어야 합니다.
binmode() 를 호출하면, 보통은 이 파일핸들에 대해 
버퍼링되는 모든 출력 데이터(및 아마 입력데이터)를 플래쉬합니다.
예외는 이 핸들에 대해 기본값문자 인코딩을 변경하는 
C<:encoding> 층입니다; L<open> 을 참조해주세요.
C<:encoding> 층은 스트림의 도충에서 호출할 필요가 있는 있고, 
그것에 의해 스트림은 플래쉬되지 않습니다.
Perl 은 내부에서 UTF-8 인코드된 Unicode 문자를 조작하기 때문에
C<:encoding> 은 암묵적으로 자신을 C<:utf8> 층위에 둡니다.

=begin original

The operating system, device drivers, C libraries, and Perl run-time
system all work together to let the programmer treat a single
character (C<\n>) as the line terminator, irrespective of the external
representation.  On many operating systems, the native text file
representation matches the internal representation, but on some
platforms the external representation of C<\n> is made up of more than
one character.

=end original

오퍼레이션 시스템, 디바이스 드라이스 드라이버, C 라이브러리, 
Perl 런타임시스템은 모두, 프로그래머가 외부표현에 상관없이 
한 문자(C<\n>) 를 줄 끝단으로 다루는 것처럼 협조작업합니다.
많은 오퍼레이팅 시스템에서는 네이티브 텍스트파일표현은 
내부표현과 같지만, C<\n> 의 외부표현이 복수문자가 되는 
플랫폼도 있습니다.

=begin original

Mac OS, all variants of Unix, and Stream_LF files on VMS use a single
character to end each line in the external representation of text (even
though that single character is CARRIAGE RETURN on Mac OS and LINE FEED
on Unix and most VMS files). In other systems like OS/2, DOS and the
various flavors of MS-Windows your program sees a C<\n> as a simple C<\cJ>,
but what's stored in text files are the two characters C<\cM\cJ>.  That
means that, if you don't use binmode() on these systems, C<\cM\cJ>
sequences on disk will be converted to C<\n> on input, and any C<\n> in
your program will be converted back to C<\cM\cJ> on output.  This is what
you want for text files, but it can be disastrous for binary files.

=end original

Mac OS, 모든 Unix 계열, VMS 의 Stream_LF 파일은 텍스트 외부표현으로써 
각 줄의 끝단에 한문자를 사용하고 있습니다(그 문자는 Mac OS 에서는 복귀로 
VMS, MS-DOS, MS-Windows 계열같은 그 외의 시스템에서는
프로그램에서는 C<\n> 은 단순히 C<\cJ> 로 보입니다만, 
텍스트파일로써 보존될 경우는 C<\cM\cJ> 의 두문자가 됩니다.
즉, 만약 이 시스템들에서 binmode() 를 사용하지 않으면, 
데스크상의 C<\cM\cJ> 같은 나열은 입력시에 C<\n> 으로 변경되고, 
프로그램이 출력한 모든 C<\n> 은 C<\cM\cJ> 로 역변환됩니다.
이것은 텍스트파일의 경우는 생각대로의 결과이지만, 
바이너리파일의 경우에는 비참합니다.

=begin original

Another consequence of using binmode() (on some systems) is that
special end-of-file markers will be seen as part of the data stream.
For systems from the Microsoft family this means that if your binary
data contains C<\cZ>, the I/O subsystem will regard it as the end of
the file, unless you use binmode().

=end original

binmode() 를(몇 개의 시스템에서) 사용하는 것에 의해 그 외의 작용으로써는, 
특별한 파일 종단 마커가 데이터 스트림의 일부로써 볼 수 있습니다.
Microsoft 패밀리의 시스템에서는 bindmode() 를 사용하지 않으면 
만약 바이너리 데이터에 C<\cZ> 가 포함되어 있을 때에, I/O 서브 시스템이 
이것을 파일 끝단으로 간주하는 것을 의미합니다.

=begin original

binmode() is not only important for readline() and print() operations,
but also when using read(), seek(), sysread(), syswrite() and tell()
(see L<perlport> for more details).  See the C<$/> and C<$\> variables
in L<perlvar> for how to manually set your input and output
line-termination sequences.

=end original

binmode() 는 readline() 과 print() 조작에서만이 아니라, 
read(), seek(), sysread(), syswrite(), tell() 을 사용할 때에ㄴ도 중요합니다
(자세한 내용은 L<perlport> 를 참조해주세요).
입출력의 줄 끝단의 시퀀스를 수동으로 설정하는 방법에 대해서는 
L<perlvar> 의 C<$/> 변수와 C<$\> 변수를 참조해주세요.

=item bless REF,CLASSNAME
X<bless>

=item bless REF

=begin original

This function tells the thingy referenced by REF that it is now an object
in the CLASSNAME package.  If CLASSNAME is omitted, the current package
is used.  Because a C<bless> is often the last thing in a constructor,
it returns the reference for convenience.  Always use the two-argument
version if a derived class might inherit the function doing the blessing.
See L<perltoot> and L<perlobj> for more about the blessing (and blessings)
of objects.

=end original

이 변수는, REF 에서 건제니 오브젝트에 대해서, 
CLASSNAME 안의 오브젝트가 된 것을 전달합니다.
CLASSNAME 이 생략된 경우에는, 그 시점의 패키지가 됩니다.
C<bless> 는 일반적으로 생성자의 마지막에 놓여지기 때문에, 
간편하게 그 리퍼런스를 반환합니다.
파생클래스가 bless 된 함수를 계승하는 경우는 
항상 2인수판을 사용해주세요.
오브젝트의 bless(나 재 bless) 에 대한 
상세한 내용응 L<perltoot> 와 L<perlobj>를 참조해주세요.

=begin original

Consider always blessing objects in CLASSNAMEs that are mixed case.
Namespaces with all lowercase names are considered reserved for
Perl pragmata.  Builtin types have all uppercase names. To prevent
confusion, you may wish to avoid such package names as well.  Make sure
that CLASSNAME is a true value.

=end original

대문자솜누자가 섞여진 경우 CLASSNAME 의 오브젝트는 항상 bless 하는 것을 
고려해주세요.
모든 소문자의 이름을 가지는 이름공간은 Perl 프로그래머를 위해 예약되어 있습니다.
혼란을 피하기 위해서, 패키지이름으로써 이런 이름은 피해야 합니다.
CLASSNAME 은 참의 값을 가지도록 해주세요.

=begin original

See L<perlmod/"Perl Modules">.

=end original

L<perlmod/"Perl Modules"> 을 참조해주세요.

=item break

=begin original

Break out of a C<given()> block.

=end original

C<given()>  블록에서 탈출합니다.

=begin original

This keyword is enabled by the "switch" feature: see L<feature>
for more information.

=end original

이 키워드는 "switch" 기능에 의해 유효하게 됩니다:
보다 자세한 정보에 대해서는 L<feature> 를 참조해주세요.

=item caller EXPR
X<caller> X<call stack> X<stack> X<stack trace>

=item caller

=begin original

Returns the context of the current subroutine call.  In scalar context,
returns the caller's package name if there is a caller, that is, if
we're in a subroutine or C<eval> or C<require>, and the undefined value
otherwise.  In list context, returns

=end original

그 시점의 서브루틴 호출의 생성자를 반환합니다.
스칼라 컨텍스트에서는 호출하는 곳이 있는 경우 
(서브루틴, C<eval>, C<require> 의 안에 있을 때) 에는
호출하는 패키지를 반환하고, 그 외의 경우에는 미정의값을 반환합니다.
리스트 컨텍스트에서는 아래를 반환합니다.

    # 0         1          2
    ($package, $filename, $line) = caller;

=begin original

With EXPR, it returns some extra information that the debugger uses to
print a stack trace.  The value of EXPR indicates how many call frames
to go back before the current one.

=end original

EXPR 을 붙이면, 디버거가 스택트레이스를 표시하기 위해 사용하는 정보를 반환합니다. EXPR 의 값은 현상태에서 센 
몇개의 앞의 콜 프레임까지 반환하는 가를 표시합니다.

    #  0         1          2      3            4
    ($package, $filename, $line, $subroutine, $hasargs,

    #  5          6          7            8       9         10
    $wantarray, $evaltext, $is_require, $hints, $bitmask, $hinthash)
     = caller($i);

=begin original

Here $subroutine may be C<(eval)> if the frame is not a subroutine
call, but an C<eval>.  In such a case additional elements $evaltext and
C<$is_require> are set: C<$is_require> is true if the frame is created by a
C<require> or C<use> statement, $evaltext contains the text of the
C<eval EXPR> statement.  In particular, for an C<eval BLOCK> statement,
$subroutine is C<(eval)>, but $evaltext is undefined.  (Note also that
each C<use> statement creates a C<require> frame inside an C<eval EXPR>
frame.)  $subroutine may also be C<(unknown)> if this particular
subroutine happens to have been deleted from the symbol table.
C<$hasargs> is true if a new instance of C<@_> was set up for the frame.
C<$hints> and C<$bitmask> contain pragmatic hints that the caller was
compiled with.  The C<$hints> and C<$bitmask> values are subject to change
between versions of Perl, and are not meant for external use.

=end original

여기에서 프레임이 서브루틴 호출이 아닌 경우, C<eval> 이 아닌 C<(eval)> 이 
됩니다.
이 경우, 추가 요소인 $evaltext 와 C<$is_require> 가 정의되어 있습니다:
C<$is_requure> 는 프레임이 C<require> 또는 C<use> 로 만들어진 경우에 
참이 되고, $evaltext 는 C<eval EXPR> 의 텍스트가 들어갑니다.
특히, C<eval BLOCK> 의 경우, $subroutine 은 C<(eval)> 이 되지만, 
$evaltext 는 미정의값이 됩니다.
(각각의 C<use> 는 C<eval EXPR> 안에서 C<require> 프레임을 만드는 것에 
주의해주세요) 
$subroutine 은 그 서브루틴이 심볼테이블에서 삭제된 경우는 
C<(unknown)> 이 됩니다.
C<$hasargs> 는 이 프레임 용에 C<@_> 의 새로운 실체가 설계된 경우에 참이 됩니다.
C<$hints> 와 C<$bitmask> 는 caller 가 컴파일된 때에 실제적인 힌트를 포함합니다.
C<$hints> 와 C<$bitmask> 는 Perl 의 버젼에 따라 변경될 가능성이 있기 때문에 
외부에서의 사용을 상정하지 않습니다.

=begin original

C<$hinthash> is a reference to a hash containing the value of C<%^H> when the
caller was compiled, or C<undef> if C<%^H> was empty. Do not modify the values
of this hash, as they are the actual values stored in the optree.

=end original

C<$hinthash> 는, caller 가 컴파일 된 때의 C<%^H> 의 값을 포함하는 
해쉬로의 리퍼런스나 혹은 C<%^H> 가 빌 경우는 C<undef> 입니다.
이 해쉬의 값은 구문 트리에 보관되는 실제의 값이기에 변경하지 말아주세요.

=begin original

Furthermore, when called from within the DB package, caller returns more
detailed information: it sets the list variable C<@DB::args> to be the
arguments with which the subroutine was invoked.

=end original

보다 더 DB 패키지의 안에서 호출된 경우는 caller 는 보다 자세한 정보를 
반환합니다. 서브루틴이 기동된 때의 인수를 변수 C<@DB::args> 에 설정합니다.

=begin original

Be aware that the optimizer might have optimized call frames away before
C<caller> had a chance to get the information.  That means that C<caller(N)>
might not return information about the call frame you expect it do, for
C<< N > 1 >>.  In particular, C<@DB::args> might have information from the
previous time C<caller> was called.

=end original

C<caller> 가 정보를 가지기 전에 옵티마이저가 호출 프레임을 최적화해버릴 지도
모르는 것에 주의하세요.
이것은 C<caller(N)> 이 C<< N > 1 >> 일 때 
당신이 예측한 호출 프레임의 정보를 반환하지 않을 지도 모르는 것을 의미합니다.
특히 C<@DB::args> 는 C<caller> 가 앞에서 호출된 때의 정보를 
가지고 있을 지도 모릅니다.

=item chdir EXPR
X<chdir>
X<cd>
X<directory, change>

=item chdir FILEHANDLE

=item chdir DIRHANDLE

=item chdir

=begin original

Changes the working directory to EXPR, if possible. If EXPR is omitted,
changes to the directory specified by C<$ENV{HOME}>, if set; if not,
changes to the directory specified by C<$ENV{LOGDIR}>. (Under VMS, the
variable C<$ENV{SYS$LOGIN}> is also checked, and used if it is set.) If
neither is set, C<chdir> does nothing. It returns true upon success,
false otherwise. See the example under C<die>.

=end original

(가능하다면) 최근 디렉토리를 EXPR 로 옮깁니다.
EXPR 을 지정하지 않으면 C<$ENV{HOME}> 이 지정되면, 
그 디렉토리로 옮깁니다.
그ㅎ지 않고, C<$ENV{LOGDIR}> 이 지정되었으면, 그 디렉토리로 옮깁니다.
(VMS 에서는 C<$ENV{SYS$LOGIN}> 도 체크되어, 만약 설정되어 있으면 사용됩니다).
어느 쪽도 설정되어있지 않으면 C<chdir> 은 아무것도 하지 않습니다.
성공 시에는 참을 반환하고, 그렇지 않으면 거짓을 반환합니다.
C<die> 의 항의 예를 참조해주세요.

=begin original

On systems that support fchdir, you might pass a file handle or
directory handle as argument.  On systems that don't support fchdir,
passing handles produces a fatal error at run time.

=end original

fchdir 에 대응하고 있는 시스템에서는 파일핸들이나 디렉토리 핸들을 인수로 
건넵니다.
fchdir 에 대응하지 않는 시스템에서는 핸들을 건네면 실행시에 
치명적에러가 됩니다.

=item chmod LIST
X<chmod> X<permission> X<mode>

=begin original

Changes the permissions of a list of files.  The first element of the
list must be the numerical mode, which should probably be an octal
number, and which definitely should I<not> be a string of octal digits:
C<0644> is okay, C<'0644'> is not.  Returns the number of files
successfully changed.  See also L</oct>, if all you have is a string.

=end original

LIST 에 포함된 파일의 퍼미션을 변경합니다.
LIST 의 최초의 요소는 숫자값표현의 모드여야 합니다.
C<0644> 는 OK 입니다만, C<'0644'> 는 안됩니다.
변경시에 성공한 파일의 수를 반환합니다.
문자열을 사용하고 싶은 경우는 L</oct> 를 참조해주세요.

    $cnt = chmod 0755, 'foo', 'bar';
    chmod 0755, @executables;
    $mode = '0644'; chmod $mode, 'foo';      # !!! sets mode to
                                             # --w----r-T
    $mode = '0644'; chmod oct($mode), 'foo'; # this is better
    $mode = 0644;   chmod $mode, 'foo';      # this is best

=begin original

On systems that support fchmod, you might pass file handles among the
files.  On systems that don't support fchmod, passing file handles
produces a fatal error at run time.   The file handles must be passed
as globs or references to be recognized.  Barewords are considered
file names.

=end original

fchmod 에 대응하는 시스템에서는 파일핸들을 인수로 건넵니다.
fchmod 에 대응하지 않는 시스템에서는 파일핸들을 건네면 실행시에 
치명적인 에러가 나옵니다.
파일핸들을 인식시키기 위해서는 글로브 또는 리퍼런스로써 
건네지 않으면 안됩니다.
Barewards 는 파일이름으로써 취급됩니다.

    open(my $fh, "<", "foo");
    my $perm = (stat $fh)[2] & 07777;
    chmod($perm | 0600, $fh);

=begin original

You can also import the symbolic C<S_I*> constants from the Fcntl
module:

=end original

심볼릭한 C<S_I*> 정수를 Fcntl 모듈에서 임포트 할 수도 있습니다.

    use Fcntl ':mode';

    chmod S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH, @executables;
    # This is identical to the chmod 0755 of the above example.

=item chomp VARIABLE
X<chomp> X<INPUT_RECORD_SEPARATOR> X<$/> X<newline> X<eol>

=item chomp( LIST )

=item chomp

=begin original

This safer version of L</chop> removes any trailing string
that corresponds to the current value of C<$/> (also known as
$INPUT_RECORD_SEPARATOR in the C<English> module).  It returns the total
number of characters removed from all its arguments.  It's often used to
remove the newline from the end of an input record when you're worried
that the final record may be missing its newline.  When in paragraph
mode (C<$/ = "">), it removes all trailing newlines from the string.
When in slurp mode (C<$/ = undef>) or fixed-length record mode (C<$/> is
a reference to an integer or the like, see L<perlvar>) chomp() won't
remove anything.
If VARIABLE is omitted, it chomps C<$_>.  Example:

=end original

모다 안전한 C<chop> (아래르 참조해주세요) 입니다.
C<$/> (C<English> 모듈에서는 $INPUT_RECORD_SEPARATOR 라고도 한다)
의 그 시점의 값에 대응하는 개행문자를 삭제합니다.
모든 인수에 삭제한 문자수의 합계를 반환합니다.
입력 코드에서 개행을 삭제하고 싶었는데, 마지막 레코드에 개행이 
들어있을 지 모를 경우에 사용할 수 있습니다.
단락 모드 (C<$/ = "">) 에서는 레코드의 마지막의 개행을 모두 뺄 수 있습니다.
흡입모드 (C<$/ = undef>) 나 고정 길이 레코드 모드 (C<$/> 이 
정수로의 리퍼런스나 유사한 것인 경우 L<perlvar> 를 참조해주세요)
그러면 chomp() 는 아무것도 없애지 않습니다.
VARIABLE 이 생략되면, $_ 을 대상으로해서 chomp 합니다.
예제:

    while (<>) {
	chomp;	# avoid \n on last field
	@array = split(/:/);
	# ...
    }

=begin original

If VARIABLE is a hash, it chomps the hash's values, but not its keys.

=end original

VARIABLE 이 해쉬라면, 해쉬의 키가 아닌 값에 대해서 chomp 합니다.

=begin original

You can actually chomp anything that's an lvalue, including an assignment:

=end original

좌변치라면, 대입을 포함해서 임의의 것을 chomp 할 수 있습니다:

    chomp($cwd = `pwd`);
    chomp($answer = <STDIN>);

=begin original

If you chomp a list, each element is chomped, and the total number of
characters removed is returned.

=end original

리스트를 chomp 하면, 고정 요소가 chomp 되어 삭제된 문자수의 합이 반환됩니다.

=begin original

Note that parentheses are necessary when you're chomping anything
that is not a simple variable.  This is because C<chomp $cwd = `pwd`;>
is interpreted as C<(chomp $cwd) = `pwd`;>, rather than as
C<chomp( $cwd = `pwd` )> which you might expect.  Similarly,
C<chomp $a, $b> is interpreted as C<chomp($a), $b> rather than
as C<chomp($a, $b)>.

=end original

단순한 변수이외의 것을 chomp 하는 경우는 괄호가 필요한 것임을 주의해주세요.
이것은 C<chomp $cow = `pwd`;> 는 예측되는 C<chomp($cwd = `pwd`)> 가 아닌 
C<(chomp $cwd) = `pwd`;> 로 해석되기 때문입니다.
이처럼, C<chomp $a, $b> 가 아니라 C<chomp($a, $b)> C<chomp($a), $b> 로 
해석됩니다.

=item chop VARIABLE
X<chop>

=item chop( LIST )

=item chop

=begin original

Chops off the last character of a string and returns the character
chopped.  It is much more efficient than C<s/.$//s> because it neither
scans nor copies the string.  If VARIABLE is omitted, chops C<$_>.
If VARIABLE is a hash, it chops the hash's values, but not its keys.

=end original

문자열의 마지막의 문자를 잘라내고 그 잘라낸 문자를 반환합니다.
문자열의 검색도 복사도 수행하지 않기 때문에 C<s/\n//> 보다도 
매우 효율적입니다.
VARIABLE 이 생략되면, $_ 을 대상으로 chop 합니다.
VARIABLE 이 해쉬일 경우, 해쉬의 value 를 chop 합니다만 
key 는 chop 하지 않습니다.

=begin original

You can actually chop anything that's an lvalue, including an assignment.

=end original

실제, 대입을 포함한 좌변치인 것이라도 chop 할 수 있습니다.

=begin original

If you chop a list, each element is chopped.  Only the value of the
last C<chop> is returned.

=end original

리스트를 chop 하면, 각각의 요소가 chop 됩니다.
마지막의 C<chop> 의 값만이 반환됩니다.

=begin original

Note that C<chop> returns the last character.  To return all but the last
character, use C<substr($string, 0, -1)>.

=end original

C<chop> 는 마지막의 문자를 반환하는 것에 주의해주세요.
마지막 이외의 모든 문자를 반환하기 위해서는 C<substr($string, 0, -1)> 를 
사용해주세요.

=begin original

See also L</chomp>.

=end original

L</chomp> 도 참조해주세요.

=item chown LIST
X<chown> X<owner> X<user> X<group>

=begin original

Changes the owner (and group) of a list of files.  The first two
elements of the list must be the I<numeric> uid and gid, in that
order.  A value of -1 in either position is interpreted by most
systems to leave that value unchanged.  Returns the number of files
successfully changed.

=end original

LIST 에 포함된 파일의 소유자 (와 그룹) 을 변경합니다.
LIST 의 처음의 2개의 요소에는 I<수치표현> 의 uid 와 gid 를 
이 순서로 주지 않으면 안됩니다.
어느쪽의 값을 -1 하면 대부분의 시스템에서는 그 값은 변경하지 않으면 
해석합니다.
변경시 성공한 파일의 수가 반환됩니다.

    $cnt = chown $uid, $gid, 'foo', 'bar';
    chown $uid, $gid, @filenames;

=begin original

On systems that support fchown, you might pass file handles among the
files.  On systems that don't support fchown, passing file handles
produces a fatal error at run time.  The file handles must be passed
as globs or references to be recognized.  Barewords are considered
file names.

=end original

fchown 에 대응하고 있는 시스템에서는 파일핸들을 인수로써 건넵니다.
fchown 에 대ㅇ하고 있지 않는 시스템에서는 파일핸들을 건네면 실행시에 
치명적인 에러가 됩니다.
파일핸들을 인식시키기 위해서는 글로브 혹은 리퍼런스로써 건네야 합니다.
Barewords 는 파일이름으로 취급됩니다.

=begin original

Here's an example that looks up nonnumeric uids in the passwd file:

=end original

passwd 파일에서 수치표현이 아닌 uid 를 검색하는 예를 나타냅니다:

    print "User: ";
    chomp($user = <STDIN>);
    print "Files: ";
    chomp($pattern = <STDIN>);

    ($login,$pass,$uid,$gid) = getpwnam($user)
	or die "$user not in passwd file";

    @ary = glob($pattern);	# expand filenames
    chown $uid, $gid, @ary;

=begin original

On most systems, you are not allowed to change the ownership of the
file unless you're the superuser, although you should be able to change
the group to any of your secondary groups.  On insecure systems, these
restrictions may be relaxed, but this is not a portable assumption.
On POSIX systems, you can detect this condition this way:

=end original

대부분의 시스템에서는 수퍼유저만이 파일의 소유자를 변경할 수 있ㅣ만, 
그룹은 실행자의 부 그룹에 변경할 수 있어야 합니다.
안전하지 않은 시스템에서는 이 제한은 느슨해져 있습니다.
하지만 이것은 이식성 있는 가정이 아닙니다.
POSIX 시스템에서는 아래처럼해서 이 조건을 검출할 수 있습니다:

    use POSIX qw(sysconf _PC_CHOWN_RESTRICTED);
    $can_chown_giveaway = not sysconf(_PC_CHOWN_RESTRICTED);

=item chr NUMBER
X<chr> X<character> X<ASCII> X<Unicode>

=item chr

=begin original

Returns the character represented by that NUMBER in the character set.
For example, C<chr(65)> is C<"A"> in either ASCII or Unicode, and
chr(0x263a) is a Unicode smiley face.  

=end original

특정의 문자셋 에서의 NUMBER 로 표현된 문자를 반환합니다.
예를들어, C<chr(65)> 는 ASCII 와 Unicode 양쪽에서 C<"A"> 가 됩니다.
chr(0x263a) 는 Unicode 의 스마일 페이스입니다.

=begin original

Negative values give the Unicode replacement character (chr(0xfffd)),
except under the L<bytes> pragma, where low eight bits of the value
(truncated to an integer) are used.

=end original

음수는 Unicode 의 치환문자 (chr(0xfffd)) 를 주지만, 
L<bytes> 프라그마의 영향아래에서는 (integer 로 묶여진) 값의 하위 8비트가
사용됩니다.

=begin original

If NUMBER is omitted, uses C<$_>.

=end original

NUMBER 가 생략된 경우, C<$_> 를 사용합니다.

=begin original

For the reverse, use L</ord>.

=end original

거꾸로 수행하기 위해서는 L</ord> 를 참조해주세요.

=begin original

Note that characters from 128 to 255 (inclusive) are by default
internally not encoded as UTF-8 for backward compatibility reasons.

=end original

128 에서 255 까지의 문자는 과거와의 호환성을 위해서 
기본값으로는 UTF-8 Unicode 로 인코드되지 않습니다.

=begin original

See L<perlunicode> for more about Unicode.

=end original

Unicode 에 대해서 좀더 알고 싶다면, L<perlunicode> 를 
참조해주세요.

=item chroot FILENAME
X<chroot> X<root>

=item chroot

=begin original

This function works like the system call by the same name: it makes the
named directory the new root directory for all further pathnames that
begin with a C</> by your process and all its children.  (It doesn't
change your current working directory, which is unaffected.)  For security
reasons, this call is restricted to the superuser.  If FILENAME is
omitted, does a C<chroot> to C<$_>.

=end original

같은 이름의 시스템 호출과 같은 것을 합니다.
현재의 프로세스 및 자식 프로세스에 대해서, C</> 로 시작하는 경로이름에 관해서 
지정된 디렉토리를 새로운 루트 디렉토리로 취급합니다.
(이것은 최근 디렉토리를 변경하지 않습니다. 최근 디렉토리 그 대로입니다).
보안 상의 이유에 의해, 이 호출은 수퍼유저밖에 수행할 수 없습니다.
FILENAME 을 생략하면, C<$_> 로 C<chroot> 합니다.

=item close FILEHANDLE
X<close>

=item close

=begin original

Closes the file or pipe associated with the file handle, flushes the IO
buffers, and closes the system file descriptor.  Returns true if those
operations have succeeded and if no error was reported by any PerlIO
layer.  Closes the currently selected filehandle if the argument is
omitted.

=end original

FILEHANDLE 에 대응한 파일 또는 파이프를 클로즈해서, 
IO 버퍼를 플러쉬해서 시스템 파일 기술자를 클로즈합니다.
조작이 성공하고 PerlIO 계층에서 에러가 보고되지 않은 경우에는 참을 반환합니다.
인수가 생략된 경우, 현재 선택된 파일핸들을 클로즈합니다.

=begin original

You don't have to close FILEHANDLE if you are immediately going to do
another C<open> on it, because C<open> will close it for you.  (See
C<open>.)  However, an explicit C<close> on an input file resets the line
counter (C<$.>), while the implicit close done by C<open> does not.

=end original

클로즈하고 곧 다시 같은 파일핸들에 대해서 오픈을 수행하는 경우에는 
C<open> 이 자동적으로 C<close> 를 수행하기 때문에, close FILEHANDLE 할 
필요는 없습니다(C<open> 을 참조해주세요). 
단, 명시적으로 클로즈를 수행한 때에만 입력파일의 
행번호 (C<$.>) ë 리셋이 수행되어, C<open> 에 의해 수행되는 암묵적인 
C<close> 에서는 수행되지 않습니다.

=begin original

If the file handle came from a piped open, C<close> will additionally
return false if one of the other system calls involved fails, or if the
program exits with non-zero status.  (If the only problem was that the
program exited non-zero, C<$!> will be set to C<0>.)  Closing a pipe
also waits for the process executing on the pipe to complete, in case you
want to look at the output of the pipe afterwards, and
implicitly puts the exit status value of that command into C<$?> and
C<${^CHILD_ERROR_NATIVE}>.

=end original

파일핸들이 파이프붙은 오픈이라면, 
C<close> 는 그 밖의 시스템 호출이 실패하거나 
프로그램이 제로가 아닌 상태에서 종료한 경우에도 거짓을 반환합니다.
(프로그램이 제로가 아닌 경우에서 끝난 것 뿐일 경우, C<$!> 가 C<0> 로 
설정됩니다). 
나중에 파이프의 출력을 보고 싶은 경우를 위해서 파이프의 클로즈에서는 
파이프 상에서 실행되는 프로세스의 완료를 가집니다.
또 자동적으로 커맨드의 상태값을 C<$?> 과 C<${^CHILD_ERROR_NATIVE}> 로
설정합니다.

=begin original

Prematurely closing the read end of a pipe (i.e. before the process
writing to it at the other end has closed it) will result in a
SIGPIPE being delivered to the writer.  If the other end can't
handle that, be sure to read all the data before closing the pipe.

=end original

도중에(즉, 쓰는 쪽이 닫히기 전) 
파이프가 읽는 쪽이 닫힌 경우 쓰는 쪽에 SIGPIPE 가 배송됩니다.
쓰는 쪽이 이것을 취급할 수 없는 경우, 
파이프를 닫기 전에 확실하게 모든 데이터가 읽혀지도록 할 필요가 있습니다.

=begin original

Example:

=end original

예제:

    open(OUTPUT, '|sort >foo')  # pipe to sort
        or die "Can't start sort: $!";
    #...			# print stuff to output
    close OUTPUT		# wait for sort to finish
        or warn $! ? "Error closing sort pipe: $!"
                   : "Exit status $? from sort";
    open(INPUT, 'foo')		# get sort's results
        or die "Can't open 'foo' for input: $!";

=begin original

FILEHANDLE may be an expression whose value can be used as an indirect
filehandle, usually the real filehandle name.

=end original

FILEHANDLE 은 식이라도 상관없습니다. 이 경우, 값은 간접 파일핸들로써 
취급되고, 보통은 실제의 파일핸들 이름입니다.

=item closedir DIRHANDLE
X<closedir>

=begin original

Closes a directory opened by C<opendir> and returns the success of that
system call.

=end original

C<opendir> 로 오픈한 디렉토리를 클로즈하고, 시스템호출의 반환값을 반환합니다.

=item connect SOCKET,NAME
X<connect>

=begin original

Attempts to connect to a remote socket, just as the connect system call
does.  Returns true if it succeeded, false otherwise.  NAME should be a
packed address of the appropriate type for the socket.  See the examples in
L<perlipc/"Sockets: Client/Server Communication">.

=end original

connect(2) 시스템 호출처럼, 리모트 소켓으로의 접속을 시험합니다.
성공시에는 참을 반환하고 실패시에는 거짓을 반환합니다.
NAME 은 소켓에 대해 적절한 형태의 pack 된 주소가 아니면 안됩니다.
L<perlipc/"Sockets: Client/Server Communication"> 의 예제를 참조하세요.

=item continue BLOCK
X<continue>

=item continue

=begin original

C<continue> is actually a flow control statement rather than a function.  If
there is a C<continue> BLOCK attached to a BLOCK (typically in a C<while> or
C<foreach>), it is always executed just before the conditional is about to
be evaluated again, just like the third part of a C<for> loop in C.  Thus
it can be used to increment a loop variable, even when the loop has been
continued via the C<next> statement (which is similar to the C C<continue>
statement).

=end original

C<continue> 는 실제로는 함수가 아닌 실행제어문입니다.
C<continue> BLOCK 이 BLOCK (전형적으로는 C<while> 또는 C<foreach> 안)에 있으면, 
이것은 조건문이 재평가되기 직전에 항상 실행됩니다.
이것은 C에 의한 C<for> 루프의 3번째 부분과 같습니다.
따라서, 이것은 C<next> 문 (이것은 C의 C<continue> 문과 비슷합니다)을 사용해서 
루프가 반복될 때에도 루프 변수를 더하거나 할 때에도 사용할 수 있습니다.

=begin original

C<last>, C<next>, or C<redo> may appear within a C<continue>
block.  C<last> and C<redo> will behave as if they had been executed within
the main block.  So will C<next>, but since it will execute a C<continue>
block, it may be more entertaining.

=end original

C<last>, C<next>, C<redo>  C<continue> 블록 안에 나타날 가능성이 있습니다.
C<last> 와 C<redo> 는 메인블록 안에서 실행되는 것처럼 행동합니다.
C<next> 의 경우는 C<continue> 블록을 실행하는 것이 되기때문에,
보다 재미있습니다.

    while (EXPR) {
	### redo always comes here
	do_something;
    } continue {
	### next always comes here
	do_something_else;
	# then back the top to re-check EXPR
    }
    ### last always comes here

=begin original

Omitting the C<continue> section is semantically equivalent to using an
empty one, logically enough.  In that case, C<next> goes directly back
to check the condition at the top of the loop.

=end original

C<continue> 섹션을 생략하는 것은 문법적으로는 빈 섹션을 지정한 것과 
같기에 논리적으로는 충분합니다. 이 경우, C<next> 는 간접루프 앞의 
조건체크로 돌아갑니다.

=begin original

If the "switch" feature is enabled, C<continue> is also a
function that will break out of the current C<when> or C<default>
block, and fall through to the next case. See L<feature> and
L<perlsyn/"Switch statements"> for more information.

=end original

"switch" 기능이 유효하다면, C<continue> 는 현재의 C<when> 이나 C<default> 
의 블록에서 날아가, 다음의 경우로 이동하기 위한 구문이 됩니다.
보다 자세한 정보에 대해서는 L<feature> 와 L<perlsyn/"Switch statements"> 
를 참조해주세요.

=item cos EXPR
X<cos> X<cosine> X<acos> X<arccosine>

=item cos

=begin original

Returns the cosine of EXPR (expressed in radians).  If EXPR is omitted,
takes cosine of C<$_>.

=end original

(라디안으로 표현된) EXPR 의 cosine 을 반환합니다.
EXPR 이 생략된 때에는 C<$_> 의 cosine 을 얻습니다.

=begin original

For the inverse cosine operation, you may use the C<Math::Trig::acos()>
function, or use this relation:

=end original

역 cosine 을 구하기 위해서는 C<Math::Trig::acos()> 함수를 사용하거나 
아래의 함수를 사용해주세요.

    sub acos { atan2( sqrt(1 - $_[0] * $_[0]), $_[0] ) }

=item crypt PLAINTEXT,SALT
X<crypt> X<digest> X<hash> X<salt> X<plaintext> X<password>
X<decrypt> X<cryptography> X<passwd> X<encrypt>

=begin original

Creates a digest string exactly like the crypt(3) function in the C
library (assuming that you actually have a version there that has not
been extirpated as a potential munitions).

=end original

C 라이브리의 crypt(3) 함수와 완전 같이, 다이제스트 문자열을 
작성합니다(일시적인 필수품으로 아직 없어지지 않은 버젼을 가지고 있다고 
가정하고 있습니다).

=begin original

crypt() is a one-way hash function.  The PLAINTEXT and SALT is turned
into a short string, called a digest, which is returned.  The same
PLAINTEXT and SALT will always return the same string, but there is no
(known) way to get the original PLAINTEXT from the hash.  Small
changes in the PLAINTEXT or SALT will result in large changes in the
digest.

=end original

crypt() 는 한방향 해쉬 함수입니다.
PLAINTEXT 와 SALT 는 다이제스트로 불려지는 짧은 문자열로 바꿔져서
그것이 반환됩니다.
PLAINTEXT 와 SASLT 가 같은 경우는 항상 같은 문자열을 반환하지만, 
해쉬에서 원래 PLAINTEXT 를 가지는 (기존의) 방법은 없습니다.
PLAINTEXT 나 SALT 를 조금 변경해도 다이제스트는 크게 변경됩니다.

=begin original

There is no decrypt function.  This function isn't all that useful for
cryptography (for that, look for F<Crypt> modules on your nearby CPAN
mirror) and the name "crypt" is a bit of a misnomer.  Instead it is
primarily used to check if two pieces of text are the same without
having to transmit or store the text itself.  An example is checking
if a correct password is given.  The digest of the password is stored,
not the password itself.  The user types in a password that is
crypt()'d with the same salt as the stored digest.  If the two digests
match the password is correct.

=end original

복호화함수는 없습니다.
이 함수는 암호화를 위해 전혀 도움되지 않기(이를 위해서는 
가까운 CPAN 미러에서 F<Crypt> 모듈을 찾아주요)때문에, 
"crypt" 라는 이름은 조금 잘못된 이름입니다.
그 대신에 일반적으로는 두개의 텍스트가 같은 지 어떤지를 텍스트 그 것을 
전송하거나 보관하거나 하지 않고 체크하기 위해 사용합니다.
예로써는 바른 패스워드가 주어졌는지 어떤지를 체크하는 것입니다.
패스워드 자신이 아닌 패스워드의 다이제스트가 보관됩니다.
유저가 패스워드를 입력하면, 보관된 다이제스트처럼 
salt 로 crypt() 합니다.
두개의 다이제스트가 같다면, 패스워드는 바른 것입니다.

=begin original

When verifying an existing digest string you should use the digest as
the salt (like C<crypt($plain, $digest) eq $digest>).  The SALT used
to create the digest is visible as part of the digest.  This ensures
crypt() will hash the new string with the same salt as the digest.
This allows your code to work with the standard L<crypt|/crypt> and
with more exotic implementations.  In other words, do not assume
anything about the returned string itself, or how many bytes in the
digest matter.

=end original

이미 있는 다이제스트 문자열을 검증하기 위해선 다이제스트를 
(C<crypt($plain, $digest) eq $digest> 처럼 해서) salt 로 사용합니다.
다이제스트를 만드는 것에 사용된 SALT 는 다이제스트의 일부로 보입니다.
그에 의해, crypt() 는 같은 salt 에서 새로운 문자열을 다이제스트로써 
해쉬화할 수 있도록 합니다.
이것에 의해 표준적인 C<crypt|/crypt> 나 더 다른 풍의 구성으로도 동작합니다.
바꿔말하면, 반환되는 문자열 그것이나 다이제스트 문자열이 
몇 바이트인지에 대해서 어떤 가정을 해서는 안됩니다.

=begin original

Traditionally the result is a string of 13 bytes: two first bytes of
the salt, followed by 11 bytes from the set C<[./0-9A-Za-z]>, and only
the first eight bytes of the digest string mattered, but alternative
hashing schemes (like MD5), higher level security schemes (like C2),
and implementations on non-UNIX platforms may produce different
strings.

=end original

전통적인 결과는 13 바이트의 문자열입니다: 최초의 2바이트는 salt, 계속해서 
집합 C<[./0-9A-Za-z]> 부터 11바이트로 다이제스트 문자열의 처음의 
8바이트만이 의미가 있습니다만, (MD5 처럼) 다른 해쉬 수법, 
(C2 같은) 높은 레벨의 보안수법, 비 UNIX 플랫폼에서의 
구성등에서는 다른 문자열이 생성될 수 있습니다.

=begin original

When choosing a new salt create a random two character string whose
characters come from the set C<[./0-9A-Za-z]> (like C<join '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]>).  This set of
characters is just a recommendation; the characters allowed in
the salt depend solely on your system's crypt library, and Perl can't
restrict what salts C<crypt()> accepts.

=end original

새로운 salt 를 선택할 경우는 집합 C<[./0-9A-Za-z]> 에서 
(C<join '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]> 처럼 해서)
랜덤하게 2개의 문자를 선택합니다.
이 문자집합은 단순한 추천사항입니다; salt 로 허락된 문자는 시스템의 암호화
라이브러리에만 의존하고 Perl 은 C<crypt()> 가 어떻게 salt 를 받아들이는 가에 
대해서 제한하고 있습니다.

=begin original

Here's an example that makes sure that whoever runs this program knows
their password:

=end original

프로그램을 실행하는 사람이 
자신의 패스워드를 알고 있는 것을 확인하는 예제입니다:

    $pwd = (getpwuid($<))[1];

    system "stty -echo";
    print "Password: ";
    chomp($word = <STDIN>);
    print "\n";
    system "stty echo";

    if (crypt($word, $pwd) ne $pwd) {
	die "Sorry...\n";
    } else {
	print "ok\n";
    }

=begin original

Of course, typing in your own password to whoever asks you
for it is unwise.

=end original

물론 자기신의 패스워드를 누구에게도 입력하는 것은 현명하지 않습니다.

=begin original

The L<crypt|/crypt> function is unsuitable for hashing large quantities
of data, not least of all because you can't get the information
back.  Look at the L<Digest> module for more robust algorithms.

=end original

L<crypt|/crypt> 함수는 대량의 데이터의 해쉬화에는 맞지 않습니다.
이것은 정보를 돌아가 하지 않는 이유만이 아닙니다.
보다 견고한 알고리즘에 대해서는 L<Digest> 모듈을 참조해주세요.

=begin original

If using crypt() on a Unicode string (which I<potentially> has
characters with codepoints above 255), Perl tries to make sense
of the situation by trying to downgrade (a copy of the string)
the string back to an eight-bit byte string before calling crypt()
(on that copy).  If that works, good.  If not, crypt() dies with
C<Wide character in crypt>.

=end original

Unicode 문자열(I<잠재적으로는> 255 를 넘는 코드 포인트를 가진 문자를
포함합니다)에 crypt() 를 사용한 경우, Perl 은 crypt() 를 호출하기 전에 
주어진 문자열을 8비트바이트 문자열에 다운그레이트하는 (문자열의 복사를 만듬)
것으로 상황을 맞출수 있습니다.
잘 움직이면, 그것으로 좋고 그렇지 않으면 crypt() 는 
C<Wide  character in crypt> 라는 메시지와 함께 die 합니다.

=item dbmclose HASH
X<dbmclose>

=begin original

[This function has been largely superseded by the C<untie> function.]

=end original

[이 함수는 C<untie> 함수로 바뀌었습니다]

=begin original

Breaks the binding between a DBM file and a hash.

=end original

DBM 파일과 해쉬의 연결을 해제합니다.

=item dbmopen HASH,DBNAME,MASK
X<dbmopen> X<dbm> X<ndbm> X<sdbm> X<gdbm>

=begin original

[This function has been largely superseded by the C<tie> function.]

=end original

[이 함수는 C<tie> 함수로 크게 바뀌었습니다]

=begin original

This binds a dbm(3), ndbm(3), sdbm(3), gdbm(3), or Berkeley DB file to a
hash.  HASH is the name of the hash.  (Unlike normal C<open>, the first
argument is I<not> a filehandle, even though it looks like one).  DBNAME
is the name of the database (without the F<.dir> or F<.pag> extension if
any).  If the database does not exist, it is created with protection
specified by MASK (as modified by the C<umask>).  If your system supports
only the older DBM functions, you may perform only one C<dbmopen> in your
program.  In older versions of Perl, if your system had neither DBM nor
ndbm, calling C<dbmopen> produced a fatal error; it now falls back to
sdbm(3).

=end original

dbm(3), ndbm(3), sdbm(3), gdbm(3) 파일 또는 Berkeley DB
파일을 연상배열로 묶습니다.
HASH 는 그 연상배열의 이름입니다.
(보통의 C<open> 과 달리 최초의 인수는 파일핸들I<이 아닙니다>. 뭐 비슷하지만)
DBNAME 은 데이터베이스의 이름입니다(확장자의 .dir 이나 .pag 는 만약 있어도 
붙지않습니다).
데이터베이스가 존재하지 않으면 MODE MASK(를 C<umask> 로 수정한 것)로
지정된 모드로 만들어집니다.
낡은 DBM 함수만을 지원하고 있는 시스템에서는 프로그ㅁ 안에서 1번만 
dbmopen() 을 실행할 수 있습니다.
옛날 버젼의 Perl 에서는 DBM 도 ndbm 도 가지고 있지 않은 시스템에서는 
dbmopen() 을 호출하면 치명적인 에러가 됩니다.
현재로는 sdbm(3) 에 폴백합니다.

=begin original

If you don't have write access to the DBM file, you can only read hash
variables, not set them.  If you want to test whether you can write,
either use file tests or try setting a dummy hash entry inside an C<eval>,
which will trap the error.

=end original

DBM 파일에 대해서 쓰기 권한이 없을 때에는 해쉬배열을 읽어내는 것만이 
가능하고, 지정한 것은 되지 않습니다.
쓸수있는가 없는가를 조사하고 싶은 경우는 파일테스트 연산자를 사용하거나 
에러를 트랩해주는 C<eval> 의 안에서 더미의 해쉬엔트리를 설정해 
보는 것이 됩니다.

=begin original

Note that functions such as C<keys> and C<values> may return huge lists
when used on large DBM files.  You may prefer to use the C<each>
function to iterate over large DBM files.  Example:

=end original

많은 DBM 파일을 사용할 때에는 C<keys> 나 C<values> 같은 함수는 
거대한 리스트를 반환합니다.
큰 DBM 파일에서는 C<each> 함수를 사용해서 반복을 수행하는 편이 
좋을 지도 모르겠습니다.
예제:

    # print out history file offsets
    dbmopen(%HIST,'/usr/lib/news/history',0666);
    while (($key,$val) = each %HIST) {
	print $key, ' = ', unpack('L',$val), "\n";
    }
    dbmclose(%HIST);

=begin original

See also L<AnyDBM_File> for a more general description of the pros and
cons of the various dbm approaches, as well as L<DB_File> for a particularly
rich implementation.

=end original

여러가지 dbm 수법에 대한 이점/결점에 관한 보다 일반적인 기술 및 
특히 리치한 구성인 L<DB_File> 에 관해서는 L<AnyDBM_File> 도 참조해주세요.

=begin original

You can control which DBM library you use by loading that library
before you call dbmopen():

=end original

dbmopen() 을 호출하기 전에 라이브러리를 읽어들이는 것으로 
어느 DBM 라이브러리를 사용하는 가를 제어할 수 있습니다.

    use DB_File;
    dbmopen(%NS_Hist, "$ENV{HOME}/.netscape/history.db")
	or die "Can't open netscape history file: $!";

=item defined EXPR
X<defined> X<undef> X<undefined>

=item defined

=begin original

Returns a Boolean value telling whether EXPR has a value other than
the undefined value C<undef>.  If EXPR is not present, C<$_> will be
checked.

=end original

좌변값 EXPR 이 미정의값 C<undef> 이외의 값을 가지는 지 그러지 않는 지를 
나타내고, 불 값을 반환합니다.
EXPR 이 없는 경우는 C<$_> 이 체크됩니다.

=begin original

Many operations return C<undef> to indicate failure, end of file,
system error, uninitialized variable, and other exceptional
conditions.  This function allows you to distinguish C<undef> from
other values.  (A simple Boolean test will not distinguish among
C<undef>, zero, the empty string, and C<"0">, which are all equally
false.)  Note that since C<undef> is a valid scalar, its presence
doesn't I<necessarily> indicate an exceptional condition: C<pop>
returns C<undef> when its argument is an empty array, I<or> when the
element to return happens to be C<undef>.

=end original

많은 연산자가 EOF 나 미초기화 변수, 시스템 에러 같은 
예외적인 조건에서 C<undef> 를 반환하도록 되어있습니다.
이 함수는 다른 값과 C<undef> 와를 구별하기 위해 사용할 수 있습니다.
(단순한 참거짓 값 테스트에서는 C<undef>, 0, C<"0"> 중 어떤 것이라도 
거짓을 반환하기에 구별할 수가 없습니다)
C<undef> 는 유효한 스칼라 값이기에, 그 존재가 I<반드시> 
예외적인 상황을 나타낸다고는 할 수 없는 것에 주의해주세요:
C<pop> 는 인수가 빈 배열이었을 때에는 C<undef> 를 반환하지만, 
I<어떨 때는> 반환해야할 요소가 때때로 C<undef> 였을 지도 모릅니다.

=begin original

You may also use C<defined(&func)> to check whether subroutine C<&func>
has ever been defined.  The return value is unaffected by any forward
declarations of C<&func>.  Note that a subroutine which is not defined
may still be callable: its package may have an C<AUTOLOAD> method that
makes it spring into existence the first time that it is called -- see
L<perlsub>.

=end original

C<defined(&func)>  라고 하는 것으로 서브루틴 C<&func> 의 존재를 
확인할 수도 있습니다.
반환값은 C<&func> 의 전방정의에는 영향받지 않습니다.
정의되지 않은 서브루틴도 호출 가능한 것에 주의해주세요.
최초에 호출된 때에 존재하게 하기 위한 
C<AUTOLOAD> 메소드를 가진 패키지일지도 모릅니다 --
L<perlsub> 를 참조해주세요.

=begin original

Use of C<defined> on aggregates (hashes and arrays) is deprecated.  It
used to report whether memory for that aggregate has ever been
allocated.  This behavior may disappear in future versions of Perl.
You should instead use a simple test for size:

=end original

집합(해쉬나 배열)로의 C<defined> 의 사용은 비 추천입니다.
이것은 그 집합에 메모리가 할당되었는 가를 보고하는 것에 
사용하였습니다.
이 행위는 장래의 버젼의 Perl 에서는 소멸될지도 모릅니다.
대신에 사이즈에 대한 간단한 테스트를 사용해야합니다.

    if (@an_array) { print "has array elements\n" }
    if (%a_hash)   { print "has hash members\n"   }

=begin original

When used on a hash element, it tells you whether the value is defined,
not whether the key exists in the hash.  Use L</exists> for the latter
purpose.

=end original

해쉬의 요소에 대해서 사용하면 value 가 정의되었는가를 반환하는 것이고 
해쉬에 key 가 존재하는 가 그렇지 않은 가를 반환하는 것은 아닙니다.
이 용도에는 L</exists> 를 사용해주세요.

=begin original

Examples:

=end original

예제:

    print if defined $switch{'D'};
    print "$val\n" while defined($val = pop(@ary));
    die "Can't readlink $sym: $!"
	unless defined($value = readlink $sym);
    sub foo { defined &$bar ? &$bar(@_) : die "No bar"; }
    $debugging = 0 unless defined $debugging;

=begin original

Note:  Many folks tend to overuse C<defined>, and then are surprised to
discover that the number C<0> and C<""> (the zero-length string) are, in fact,
defined values.  For example, if you say

=end original

주의: 많은 사람들이 C<defined> 를 너무 많이 써서, C<0> 와 C<""> 가 
예를들어 아래처럼 쓰면:

    "ab" =~ /a(.*)b/;

=begin original

The pattern match succeeds, and C<$1> is defined, despite the fact that it
matched "nothing".  It didn't really fail to match anything.  Rather, it
matched something that happened to be zero characters long.  This is all
very above-board and honest.  When a function returns an undefined value,
it's an admission that it couldn't give you an honest answer.  So you
should use C<defined> only when you're questioning the integrity of what
you're trying to do.  At other times, a simple comparison to C<0> or C<""> is
what you want.

=end original

패턴매칭이 성공하고, C<$1> 이 정의되어도, 실제로는 "없음"에 매치하고 있습니다.
그러나 이것은 아무것도 매치하고 있지 않은 것은 아닙니다.
뭔가에는 매치하고 있지만, 때때 그것이 길이 0이라는 것입니다.
이것은 꽤 솔직하고 정직한 것입니다.
함수가 미정의값을 반환할 때, 제대로 된 값을 반환하는 것이 불가능한 것을 
고백하고 있습니다.
그렇기 때문에, 당신이 자신이 하려고 하는 것의 완전성을 확인하는 것에만 
C<defined> 를 사용해야 합니다.
그 외의 경우에는, 단순히 C<0> 또는 C<""> 와 비교하는 것이 
당신이 원하는 것일 겁니다.

=begin original

See also L</undef>, L</exists>, L</ref>.

=end original

L</undef>, L</exists>, L</ref> 도 참조해주세요.

=item delete EXPR
X<delete>

=begin original

Given an expression that specifies a hash element, array element, hash slice,
or array slice, deletes the specified element(s) from the hash or array.
In the case of an array, if the array elements happen to be at the end,
the size of the array will shrink to the highest element that tests
true for exists() (or 0 if no such element exists).

=end original

해쉬요소, 배열요소, 해쉬슬라이스, 배열슬라이스를 지정하는 식을 얻고, 
지정된 요소를 해쉬나 배열에서 삭제합니다.
배열의 경우 배열요소가 마지막에 있는 경우는 
배열의 크기는 exsists() 가 참을 반환하는 맨 끝의 요소로 축소합니다.
(그ㄴ 요소가 없는 경우는 0이 됩니다)

=begin original

Returns a list with the same number of elements as the number of elements
for which deletion was attempted.  Each element of that list consists of
either the value of the element deleted, or the undefined value.  In scalar
context, this means that you get the value of the last element deleted (or
the undefined value if that element did not exist).

=end original

삭제를 하려고 한 그 수와 같은 수의 요소에서 리스트를 반환합니다.
이 리스트의 각요소는 삭제된 값이나 미정의 값중 어느쪽입니다.
스칼라컨텍스트에서는 이것은 삭제된 마지막의 요소(또는 삭제된 요소가 
없는 경우는 미정의값)을 얻는 것을 의미합니다.

    %hash = (foo => 11, bar => 22, baz => 33);
    $scalar = delete $hash{foo};             # $scalar is 11
    $scalar = delete @hash{qw(foo bar)};     # $scalar is 22
    @array  = delete @hash{qw(foo bar baz)}; # @array  is (undef,undef,33)

=begin original

Deleting from C<%ENV> modifies the environment.  Deleting from
a hash tied to a DBM file deletes the entry from the DBM file.  Deleting
from a C<tie>d hash or array may not necessarily return anything.

=end original

C<%ENV> 에서 삭제를 수행하면, 실제로 환경변수를 변경합니다.
DBM 파일에 tie 된 배열에서의 삭제는 그 DBM 파일에서 엔트리를 삭제합니다.
그러나 C<tie> 된 해쉬나 배열에서의 삭제는 값을 반환한다고는 할 수 없습니다.

=begin original

Deleting an array element effectively returns that position of the array
to its initial, uninitialized state.  Subsequently testing for the same
element with exists() will return false.  Also, deleting array elements
in the middle of an array will not shift the index of the elements
after them down.  Use splice() for that.  See L</exists>.

=end original

배열요소를 삭제한 경우, 뱅ㄹ의 위치는 초기의 초기화되지 않은 상태가 됩니다.
계속해서 같은 요소에 대해서 exsists() 로 테스트하면 거짓을 반환합니다.
또, 배열의 도충의 배열 요소를 삭제해도 인덱스는 시프트하지 않ㅅ브니다.
이 때문에 splice() 를 사용해주세요.
L</exists> 를 참조해주세요.

=begin original

The following (inefficiently) deletes all the values of %HASH and @ARRAY:

=end original

아래는 %HASH 와 @ARRAY 의 모든 값을 (비효율적으로) 삭제합니다:

    foreach $key (keys %HASH) {
	delete $HASH{$key};
    }

    foreach $index (0 .. $#ARRAY) {
	delete $ARRAY[$index];
    }

=begin original

And so do these:

=end original

그리고 아래처럼해도 됩니다.

    delete @HASH{keys %HASH};

    delete @ARRAY[0 .. $#ARRAY];

=begin original

But both of these are slower than just assigning the empty list
or undefining %HASH or @ARRAY:

=end original

그러나 이 2개는 단순히 빈 리스트를 대입하거나 %HASH 나 @ARRAY 를 
undef 하는 것보다 느립니다.

    %HASH = ();		# completely empty %HASH
    undef %HASH;	# forget %HASH ever existed

    @ARRAY = ();	# completely empty @ARRAY
    undef @ARRAY;	# forget @ARRAY ever existed

=begin original

Note that the EXPR can be arbitrarily complicated as long as the final
operation is a hash element, array element,  hash slice, or array slice
lookup:

=end original

마지막 조작이 해쉬 요소, 배열 요소, 해쉬 사이즈, 배열 사이즈 중의 
어느것인한 EXPR 에는 임의의 복잡한 식을 두는 것이 가능하는 것에 
주의해주세요.

    delete $ref->[$x][$y]{$key};
    delete @{$ref->[$x][$y]}{$key1, $key2, @morekeys};

    delete $ref->[$x][$y][$index];
    delete @{$ref->[$x][$y]}[$index1, $index2, @moreindices];

=item die LIST
X<die> X<throw> X<exception> X<raise> X<$@> X<abort>

=begin original

Outside an C<eval>, prints the value of LIST to C<STDERR> and
exits with the current value of C<$!> (errno).  If C<$!> is C<0>,
exits with the value of C<<< ($? >> 8) >>> (backtick `command`
status).  If C<<< ($? >> 8) >>> is C<0>, exits with C<255>.  Inside
an C<eval(),> the error message is stuffed into C<$@> and the
C<eval> is terminated with the undefined value.  This makes
C<die> the way to raise an exception.

=end original

C<eval> 의 밖에서는 LIST 의 값을 C<STDERR> 을 출력하고 그 시점의 
C<$!> (errno) 의 값으로 exit 합니다.
C<$!> 의 값이 C<0> 라면 
C<<< ($? >> 8) >>> (backtick `command` 의 스테이터스) 의 값으로 exit 합니다.
C<<< ($? >> 8) >>> 도 C<0> 이면, C<255> 로 exit 하게 됩니다.
C<eval> 의 안에서 사용하면 에러메시지가 C<$@> 에 들어갈 수 있습니.
C<eval> 은 중단되고 미정의 값을 반환합니다.
이것이 C<die> 가 예외를 발생시키는 방법입니다.

=begin original

Equivalent examples:

=end original

같은 예:

    die "Can't cd to spool: $!\n" unless chdir '/usr/spool/news';
    chdir '/usr/spool/news' or die "Can't cd to spool: $!\n"

=begin original

If the last element of LIST does not end in a newline, the current
script line number and input line number (if any) are also printed,
and a newline is supplied.  Note that the "input line number" (also
known as "chunk") is subject to whatever notion of "line" happens to
be currently in effect, and is also available as the special variable
C<$.>.  See L<perlvar/"$/"> and L<perlvar/"$.">.

=end original

LIST 의 마지막의 요소가 개행으로 끝나지 않으면, 그 시점의 
스크립트 이름과 시크립트의 행번호 (만약 있다면) 입력 파일의 
행번호로 개행문자가 계속해서 표시된디ㅏ.
"입력행번호" ("chunk" 라고도 불립니다) 는 
"행" 이라는 개념이 현재 유효하닥고 가정합니다.
또 특수변수 C<$.> 이라도 이용가능합니다.
L<perlvar/"$/"> 와 L<perlvar/"$."> 도 참조해주세요.

=begin original

Hint: sometimes appending C<", stopped"> to your message will cause it
to make better sense when the string C<"at foo line 123"> is appended.
Suppose you are running script "canasta".

=end original

힌트 : 메시지의 마지막을 C<", stopped"> 같은 것으로 
끝나게 해두면, C<"at foo line 123"> 처럼 
추가되어, 알기 쉬워집니다.
"canasta" 라는 스크립트를 실행한다고 합니다.

    die "/etc/games is no good";
    die "/etc/games is no good, stopped";

=begin original

produce, respectively

=end original

이것은 각각 아래처럼 표시합니다.

    /etc/games is no good at canasta line 123.
    /etc/games is no good, stopped at canasta line 123.

=begin original

See also exit(), warn(), and the Carp module.

=end original

exit() 와 warn() 과 Carp 모듈도 참주해주세요.

=begin original

If LIST is empty and C<$@> already contains a value (typically from a
previous eval) that value is reused after appending C<"\t...propagated">.
This is useful for propagating exceptions:

=end original

LIST 가 비었고 C<$@> 가 (전형적으로는 앞에서의 eval에서) 이미 값을 가지고 
있는 경우 이것은 예외를 전달시키는 경우에 유효합니다.

    eval { ... };
    die unless $@ =~ /Expected exception/;

=begin original

If LIST is empty and C<$@> contains an object reference that has a
C<PROPAGATE> method, that method will be called with additional file
and line number parameters.  The return value replaces the value in
C<$@>.  i.e. as if C<< $@ = eval { $@->PROPAGATE(__FILE__, __LINE__) }; >>
were called.

=end original

LIST 가 비었고 C<$@> 가 C<PROPAGATE> 메소드를 포함하는 메소드로의 
리퍼런스를 포함한 경우, 이 메소드가 추가 파일과 행번호를 인수로써 
호출됩니다.
반환값은 C<$@> 의 값을 바꿉니다.
즉 C<< $@ = eval { $@->PROPAGATE(__FILE__, __LINE__) }; >> 이 
호출되게 됩니다.

=begin original

If C<$@> is empty then the string C<"Died"> is used.

=end original

C<$@> 이 빌 경우 C<"Died"> 가 사용됩니다.

=begin original

die() can also be called with a reference argument.  If this happens to be
trapped within an eval(), $@ contains the reference.  This behavior permits
a more elaborate exception handling implementation using objects that
maintain arbitrary state about the nature of the exception.  Such a scheme
is sometimes preferable to matching particular string values of $@ using
regular expressions.  Because $@ is a global variable, and eval() may be
used within object implementations, care must be taken that analyzing the
error object doesn't replace the reference in the global variable.  The
easiest solution is to make a local copy of the reference before doing
other manipulations.  Here's an example:

=end original

die() 는 리퍼런스 인수와 함께 호출될 수도 있습니다.
eval() 내부에서 이렇게 호출된 경우, $@ 은 리퍼런스를 가집니다.
이 행동은 예외의 성질에 대해 임의의 상태를 관리하는 오브젝트를 사용한 
보다 복잡한 예외 핸들링의 구성을 가능하게 합니다.
이런 스키마는 $@ 의 특정 문자열값을 정규표현을 사용해서 매칭할 때에 
때때로 사용됩니다.
$@ 은 글로벌 변수로 eval() 은 오브젝트 구성의 내부에서 
사용될 수 있기 때문에 에러 오브젝트의 해석은 글로벌 변수의 
리퍼런스를 치환하지 않는 것에 주의를 기울이지 않으면 안됩니다.
제일 간단한 해결방법은 다른 조작을 하기 전에 리퍼런스의 로컬 카피를 
만드는 것입니다.
아래에 예가 있습니다:

    use Scalar::Util 'blessed';

    eval { ... ; die Some::Module::Exception->new( FOO => "bar" ) };
    if (my $ev_err = $@) {
        if (blessed($ev_err) && $ev_err->isa("Some::Module::Exception")) {
            # handle Some::Module::Exception
        }
        else {
            # handle all other possible exceptions
        }
    }

=begin original

Because perl will stringify uncaught exception messages before displaying
them, you may want to overload stringification operations on such custom
exception objects.  See L<overload> for details about that.

=end original

perl 은 확보되지 않은 예외의 메시지를 표시하기 전에 문자열이 되기 때문에,
이런 커스텀 예외 오브젝트의 문자열화를 오버라이드하고 싶다고 
생각할지도 모르겠습니다.
이것에 관한 상세한 내용은 L<overload> 를 참조해주세요.

=begin original

You can arrange for a callback to be run just before the C<die>
does its deed, by setting the C<$SIG{__DIE__}> hook.  The associated
handler will be called with the error text and can change the error
message, if it sees fit, by calling C<die> again.  See
L<perlvar/$SIG{expr}> for details on setting C<%SIG> entries, and
L<"eval BLOCK"> for some examples.  Although this feature was 
to be run only right before your program was to exit, this is not
currently the case--the C<$SIG{__DIE__}> hook is currently called
even inside eval()ed blocks/strings!  If one wants the hook to do
nothing in such situations, put

=end original

C<$SIG{__DIE__}> 후크를 설정하는 것으로 C<die> 가 그 행동을 수행하기 
직전에 실행되는 콜백을 설정할 수 있습니다.
연결된 핸들러는 에러 텍스트와 함께 호출되어 
필요하다면 다시 C<die> 를 호출하는 것으로 에러 텍스트를 변경할 수 있습니다.
C<%SIG> 의 엔트리를 설정하는 자세한 내용에 대해서는 L<perlvar/$SIG{expr}>를 
예제에 대해서는 L<"eval BLOCK"> 을 참조해주세요.
이 기능은 프로램이 종료하기 전에 한번만 실행되었지만, 
현재는 그렇지 않습니다 --
C<$SIG{__DIE__}> 후크는 eval() 된 블록/문자열의 안에서도 
호출되는 것입니다!
만약 그런 상황에서 아무것도 하지 않을 때는:

	die @_ if $^S;

=begin original

as the first line of the handler (see L<perlvar/$^S>).  Because
this promotes strange action at a distance, this counterintuitive
behavior may be fixed in a future release.

=end original

을 핸들러의 첫번째 줄에 놓아주세요(L<perlvar/$^S> 를 참조해주세요).
이것은 떨어진 곳에서 불가사의한 행동을 일으키기 때문에 ,
이 직감적이지 않은 행동은 장래의 릴리즈에서 수정될지도 모르겠습니다.

=item do BLOCK
X<do> X<block>

=begin original

Not really a function.  Returns the value of the last command in the
sequence of commands indicated by BLOCK.  When modified by the C<while> or
C<until> loop modifier, executes the BLOCK once before testing the loop
condition. (On other statements the loop modifiers test the conditional
first.)

=end original

실제는 함수가 아닙니다.
BLOCK 에서 나타내는 커맨드 열의 최후의 값을 반환합니다.
C<while> 이나 C<until> 루프 수식자로 수식하면 
루프 조건을 조사하기 전에 한번 BLOCK 을 실행합니다.
(이 이외의 실행문은 루프 수식자에 의해 조건이 최초에 조사됩니다.)

=begin original

C<do BLOCK> does I<not> count as a loop, so the loop control statements
C<next>, C<last>, or C<redo> cannot be used to leave or restart the block.
See L<perlsyn> for alternative strategies.

=end original

C<do BLOCK> 은 루프로써 I<취급되지 않습니다>.
따라서 C<next>, C<last>, C<redo> 같은 루프 제어문은 
블록에서 빠지거나 재개할 수는 없습니다.
그 밖의 전략에 대해서는 L<perlsyn> 을 참조해주세요.

=item do SUBROUTINE(LIST)
X<do>

=begin original

This form of subroutine call is deprecated.  See L<perlsub>.

=end original

이 형태의 서브루틴 호출은 비추천입니다.
L<perlsub> 를 참조해주세요.

=item do EXPR
X<do>

=begin original

Uses the value of EXPR as a filename and executes the contents of the
file as a Perl script.

=end original

EXPR 의 값을 파일 이름으로 사용하고 그 파일 안을 
Perl 스크립트로 실행합니다.

    do 'stat.pl';

=begin original

is just like

=end original

는 아래와 같은 것입니다만,

    eval `cat stat.pl`;

=begin original

except that it's more efficient and concise, keeps track of the current
filename for error messages, searches the @INC directories, and updates
C<%INC> if the file is found.  See L<perlvar/Predefined Names> for these
variables.  It also differs in that code evaluated with C<do FILENAME>
cannot see lexicals in the enclosing scope; C<eval STRING> does.  It's the
same, however, in that it does reparse the file every time you call it,
so you probably don't want to do this inside a loop.

=end original

보다 효율적이고 간단하고 에러메시지로 파일명을 알수 있는 
최근 디렉토리에서 파일이 발견되지 않을 때에 
@INC 디렉토리를 검색하고 파일이 있을 때에 C<%INC> 를 갱신하는 
것이 있습니다.
L<perlvar/Predefined Names> 을 참조해주세요.
C<do FILENAME> 에서 평가된 코드는 입력된 스코프에 있는 
렉시컬 변수를 볼 수 없는 것에 대해서, C<eval STRING> 로는 
가능하다는 차이가 있습니다.
그러나 호출할 때마다 파일을 다시 해석해야하는 점에서는 같기 때문에 
루프안에서 이것을 사용하거나 할 때는 틀려도 생각나지 않도록.

=begin original

If C<do> cannot read the file, it returns undef and sets C<$!> to the
error.  If C<do> can read the file but cannot compile it, it
returns undef and sets an error message in C<$@>.   If the file is
successfully compiled, C<do> returns the value of the last expression
evaluated.

=end original

C<do> 가 파일을 읽을 수 없을 경우, undef 를 반환하고 C<$!> 에 
어라를 설정합니다.
C<do> 가 파일을 읽을 수 있었지만, 컴파일할 수 없는 경우 
undef 를 반환해서 C<$@> 에 에러메시지를 설정합니다.
파일의 컴파일ㅔ 성공한 경우, C<do> 는 파지막에 평가한 표현의 값을 
반환합니다.

=begin original

Note that inclusion of library modules is better done with the
C<use> and C<require> operators, which also do automatic error checking
and raise an exception if there's a problem.

=end original

라이브러리 모듈의 Include 는 C<use> 연산자나 
C<require> 연산자를 사용하는 편이 좋다는 것에 주의해주세요.
이것들은 자동적으로 에러를 체크해서 문제가 있으면 
예외를 발생시킵니다.

=begin original

You might like to use C<do> to read in a program configuration
file.  Manual error checking can be done this way:

=end original

C<do> 를 프로그램 설정 파일을 읽어들이는 것에 사용하고 싶을지도 
모릅니다. 수동의 에러체크는 아래처럼 해서 수행할 수 있습니다.

    # read in config files: system first, then user
    for $file ("/share/prog/defaults.rc",
               "$ENV{HOME}/.someprogrc")
   {
	unless ($return = do $file) {
	    warn "couldn't parse $file: $@" if $@;
	    warn "couldn't do $file: $!"    unless defined $return;
	    warn "couldn't run $file"       unless $return;
	}
    }

=item dump LABEL
X<dump> X<core> X<undump>

=item dump

=begin original

This function causes an immediate core dump.  See also the B<-u>
command-line switch in L<perlrun>, which does the same thing.
Primarily this is so that you can use the B<undump> program (not
supplied) to turn your core dump into an executable binary after
having initialized all your variables at the beginning of the
program.  When the new binary is executed it will begin by executing
a C<goto LABEL> (with all the restrictions that C<goto> suffers).
Think of it as a goto with an intervening core dump and reincarnation.
If C<LABEL> is omitted, restarts the program from the top.

=end original

이 함수는 코어덤프를 수행합니다.
같은 것을 수행하는 L<perlrun> 의 B<-u> 옵션도 참조해주세요.
프그램의 맨앞에서, 모든 변수를 초기화한 뒤의 코어덤프를 B<undump>
프로그램(제공하지 않습니다)를 사용해서 실행파일로 반환할 수 있습니다.
이 새로운 바이너리가 실행되면 C<goto LABEL> 에서 시작합니다.
(C<goto> 에 관한 제한은 모두 적용됩니다). 코어덤프를 감싸서 
재생하는 goto 라고 생각해주세요.
C<LABEL> 이 생략되면 프로그램을 맨앞에서 재개합니다.

=begin original

B<WARNING>: Any files opened at the time of the dump will I<not>
be open any more when the program is reincarnated, with possible
resulting confusion on the part of Perl.

=end original

B<경고>: dump 시점에서 오픈된 파일은 프로그램이 재생된 때에는 
이미 오픈되어 있지 않은 상태입니다.
Perl 을 부분적으로 혼란시킬 가능성이 있습니다.

=begin original

This function is now largely obsolete, mostly because it's very hard to
convert a core file into an executable. That's why you should now invoke
it as C<CORE::dump()>, if you don't want to be warned against a possible
typo.

=end original

이 함수는 크게 시대에 뒤쳐진 것입니다; 주요한 이유로는 코어덤프를 
실행형식으로 변환하는 것이 꽤 곤란한 것입니다.
이것이 지금에서는 타이프미스의 가능성에 경고를 받고 싶지 않다면 
C<CORE::dump()> 로 기동해야하는 이유입니다.

=item each HASH
X<each> X<hash, iterator>

=begin original

When called in list context, returns a 2-element list consisting of the
key and value for the next element of a hash, so that you can iterate over
it.  When called in scalar context, returns only the key for the next
element in the hash.

=end original

리스트컨텍스트에서 호출되는 경우는 
해쉬의 다음 요소에 대해 key 와 요소를 합친 2 요소의 리스트를 반환하기에 
해쉬 상에서의 반복을 수행할 수 있습니다.
스칼라컨텍스트에서 호출한 경우는 해쉬의 다음 요소ㄹ 위한 key 를 반환합니다.

=begin original

Entries are returned in an apparently random order.  The actual random
order is subject to change in future versions of perl, but it is
guaranteed to be in the same order as either the C<keys> or C<values>
function would produce on the same (unmodified) hash.  Since Perl
5.8.1 the ordering is different even between different runs of Perl
for security reasons (see L<perlsec/"Algorithmic Complexity Attacks">).

=end original

엔트리는 보기보다 랜덤한 순서로 반환됩니다.
실제의 랜덤한 순서는 perl 의 장래의 버젼에서는 바뀔지도 모릅니다만, 
C<keys> 나 C<values> 함수가 같은(변경되지 않은) 해쉬에 대해 
생성하는 것과 같은 순서인 것은 보증됩니다.
Perl 5.8.1 이후에서는 보안상의 이유로 인해 실행될 때마다 순서는 바뀝니다.
(L<perlsec/"Algorithmic Complexity Attacks"> 를 참조해주세요)

=begin original

When the hash is entirely read, a null array is returned in list context
(which when assigned produces a false (C<0>) value), and C<undef> in
scalar context.  The next call to C<each> after that will start iterating
again.  There is a single iterator for each hash, shared by all C<each>,
C<keys>, and C<values> function calls in the program; it can be reset by
reading all the elements from the hash, or by evaluating C<keys HASH> or
C<values HASH>.  If you add or delete elements of a hash while you're
iterating over it, you may get entries skipped or duplicated, so
don't.  Exception: It is always safe to delete the item most recently
returned by C<each()>, which means that the following code will work:

=end original

해쉬를 모두 읽어버리면, 리스컨텍스트에서는 빈배열이 반환됩니다( 
이것은 대입되면, 거짓(C<0>) 이 됩니다).
스칼라컨텍스트에서는 C<undef> 가 반환됩니다.
그 뒤 한번 더 C<each> 를 호출하면, 다시 반복을 시작합니다.
해쉬마다 반복자가 하나가 있어, 프로그램 안의 모든 C<each> 함수, 
C<keys> 함수, C<values> 함수로 공용됩니다.
반복자는 배열의 요소를 모두 읽는 것에 의해, 또는 C<keys HASH>,
C<values HASH> 를 평가하는 것으로 리셋할 수 있습니다.
반복을 수행하고 있는 사이에 해쉬에 요소를 추가하거나 삭제하거나 하면,
요소가 무시되거나 중복될 수 있기 때문에 해서는 안됩니다.
예외: 제일 최근에 C<each()> 에서 반환된 것을 삭제하는 것은 항상 
안전합니다. 이것은 아래처럼 코드가 바르게 움직이는 것을 의미합니다:

        while (($key, $value) = each %hash) {
          print $key, "\n";
          delete $hash{$key};   # This is safe
        }

=begin original

The following prints out your environment like the printenv(1) program,
only in a different order:

=end original

아래의 프로그램은, 순서가 다른 printenv(1) 프로그램처럼 
환경변수를 표시합니다:

    while (($key,$value) = each %ENV) {
	print "$key=$value\n";
    }

=begin original

See also C<keys>, C<values> and C<sort>.

=end original

C<keys> 나 C<values> 나 C<sort> 도 참조해주세요.

=item eof FILEHANDLE
X<eof>
X<end of file>
X<end-of-file>

=item eof ()

=item eof

=begin original

Returns 1 if the next read on FILEHANDLE will return end of file, or if
FILEHANDLE is not open.  FILEHANDLE may be an expression whose value
gives the real filehandle.  (Note that this function actually
reads a character and then C<ungetc>s it, so isn't very useful in an
interactive context.)  Do not read from a terminal file (or call
C<eof(FILEHANDLE)> on it) after end-of-file is reached.  File types such
as terminals may lose the end-of-file condition if you do.

=end original

다음에 FILEHANDLE 위에서 읽기를 수행한 때에 EOF 가 반환될 때나,
FILEHANDLE 이 오픈되지 않으면 1을 반환합니다.
FILEHANDLE 은 값이 실제의 파일핸들을 나타내는 식이어도 상관없습니다.
(이 함수는 실제 문자를 일고, C<ungetc> 를 수행하기 때문에 
대화형의 경우에는 정유용이 아닙니다)
단말 파일은 EOF 에 도달한 뒤에 다시 읽어들이거나 C<eof(FILEHANDLE)> 을 
호출하거나 해서는 안됩니다. 그런 일을 하면, 단말처럼 파일타입은 
EOF 상태를 잃어버릴 지도 모릅니다.

=begin original

An C<eof> without an argument uses the last file read.  Using C<eof()>
with empty parentheses is very different.  It refers to the pseudo file
formed from the files listed on the command line and accessed via the
C<< <> >> operator.  Since C<< <> >> isn't explicitly opened,
as a normal filehandle is, an C<eof()> before C<< <> >> has been
used will cause C<@ARGV> to be examined to determine if input is
available.   Similarly, an C<eof()> after C<< <> >> has returned
end-of-file will assume you are processing another C<@ARGV> list,
and if you haven't set C<@ARGV>, will read input from C<STDIN>;
see L<perlop/"I/O Operators">.

=end original

인수를 생략한 C<eof> 는 마지막에 읽기를 수행한 파일을 사용합니다.
빈 괄호를 붙인 C<eof()> 는 크게 다릅니다.
이것은 커맨드라인의 파일리스트로 구성되어 C<< <> >> 연산자 경유로 
접근되는 유사파일을 나타내기위해 사용됩니다.
일반적인 파일핸들과는 다르게 C<< <> >> 는 명시적으로 오픈되지 않기에 
C<< <> >> 를 사용하기 전에 C<eof()> 를 사용하면 
입력이 정성적인지를 확인하기 위해 C<@ARGV> 가 테스트됩니다.
이처럼 C<< <> >> 의 뒤의 C<eof()> 에서 EOF 가 반환하는 것은 
다음의 C<@ARGV> 리스트를 처리한다고 가정하고 만약 C<@ARGV>를 
설정하지 않을 때는 C<STDIN> 에서 읽어들입니다.
L<perlop/"I/O Operators"> 를 참조해주세요.

=begin original

In a C<< while (<>) >> loop, C<eof> or C<eof(ARGV)> can be used to
detect the end of each file, C<eof()> will only detect the end of the
last file.  Examples:

=end original

C<< while (<>) >> 루프의 안에서는 각각의 파일의 끝을 조사하는 것에 
C<eof> 나 C<eof(ARGV)> 를 사용합니다.
C<eof()> 는 마지막의 파일의 끝만을 조사합니다.
예제:

    # reset line numbering on each input file
    while (<>) {
	next if /^\s*#/;	# skip comments
	print "$.\t$_";
    } continue {
	close ARGV  if eof;	# Not eof()!
    }

    # insert dashes just before last line of last file
    while (<>) {
	if (eof()) {		# check for end of last file
	    print "--------------\n";
	}
	print;
	last if eof();          # needed if we're reading from a terminal
    }

=begin original

Practical hint: you almost never need to use C<eof> in Perl, because the
input operators typically return C<undef> when they run out of data, or if
there was an error.

=end original

현실적인 힌트: Perl 에서 C<eof> 가 필요로 하는 것은 대부분 없습니다.
기본적으로는 데이터가 없어졌을 때나 에러가 있을 때에 입력 연산자가 
C<undef> 를 반환해주기 때문입니다.

=item eval EXPR
X<eval> X<try> X<catch> X<evaluate> X<parse> X<execute>
X<error, handling> X<exception, handling>

=item eval BLOCK

=item eval

=begin original

In the first form, the return value of EXPR is parsed and executed as if it
were a little Perl program.  The value of the expression (which is itself
determined within scalar context) is first parsed, and if there weren't any
errors, executed in the lexical context of the current Perl program, so
that any variable settings or subroutine and format definitions remain
afterwards.  Note that the value is parsed every time the C<eval> executes.
If EXPR is omitted, evaluates C<$_>.  This form is typically used to
delay parsing and subsequent execution of the text of EXPR until run time.

=end original

첫번째 형식에서는 EXPR 의 반환값이 Perl 의 프로그램인것으로 해석되어 실행됩니다.
식의 값(그 자신 스칼라 컨텍스트의 안에서 결정됩니다)은 우선 파싱되어 
에러가 없으면 Perl 프로그램의 렉시컬 컨텍스트의 안에서 실행되기 때문에, 
변수의 설정, 서브루틴이나 포맷의 정의는 그 뒤에도 남아 있습니다.
반환되는 값은 C<eval> 이 실행되는 것에 파싱되는 것에 주의해주세요.
EXPR 을 생략하면 C<$_> 을 평가합니다.
이 형식은 주로 EXPR 의 텍스트의 파싱과 실행을 실행시간까지 지연시킬때 
사용합니다.

=begin original

In the second form, the code within the BLOCK is parsed only once--at the
same time the code surrounding the C<eval> itself was parsed--and executed
within the context of the current Perl program.  This form is typically
used to trap exceptions more efficiently than the first (see below), while
also providing the benefit of checking the code within BLOCK at compile
time.

=end original

두번째 형식에서는 BLOCK 내부의 코드는 한번만 파싱되어 -- 코드를 
감싸는 C<eval> 자신이 파싱되는 것과 같은 시점입니다 -- 현재의 Perl 프로그램의
컨텍스트에서 실행됩니다.
이 형식은 전형적으로는 제일의 형식보다 효율적으로 예외를 트랩합니다(나중에 기술).
또 BLOCK 내부의 코드는 컴파일 시에 체크되는 시점을 제공합니다.

=begin original

The final semicolon, if any, may be omitted from the value of EXPR or within
the BLOCK.

=end original

마지막의 세미콜론은 만약 있다면 EXPR 의 값이나 BLOCK 의 내용에서 생략할 수 있습니다.

=begin original

In both forms, the value returned is the value of the last expression
evaluated inside the mini-program; a return statement may be also used, just
as with subroutines.  The expression providing the return value is evaluated
in void, scalar, or list context, depending on the context of the C<eval> 
itself.  See L</wantarray> for more on how the evaluation context can be 
determined.

=end original

어느쪽의 형식이라도 반환되는 값은 미니프로그램의 내부에서 마지막으로 평가된 
표현의 값입니다; 서브루틴처럼 return 문도 사용할 수 있습니다.
반환값으로써 제공되는 표현은 C<eval> 자신의 컨텍스트에 의존해서 
무효,스칼라,리스트중 하나의 컨텍스트로 평가됩니다.
평가 컨텍스ㅡ의 결정방법에 대한 자세한 내용은 L</wantarray> 를 참조해주세요.

=begin original

If there is a syntax error or runtime error, or a C<die> statement is
executed, an undefined value is returned by C<eval>, and C<$@> is set to the
error message.  If there was no error, C<$@> is guaranteed to be a null
string.  Beware that using C<eval> neither silences perl from printing
warnings to STDERR, nor does it stuff the text of warning messages into C<$@>.
To do either of those, you have to use the C<$SIG{__WARN__}> facility, or
turn off warnings inside the BLOCK or EXPR using S<C<no warnings 'all'>>.
See L</warn>, L<perlvar>, L<warnings> and L<perllexwarn>.

=end original

구문에러나 실행에러가 발생하거나 C<die> 문이 실행되면 
C<eval> 의 값으로 미정의값이 반환되고 C<$@> 에 에러메시지가 설정됩니다.
에러가 없으면 C<$@> 은 빈문자열인 것이 보증됩니다.
C<eval> 을 STDERR 에 경고메시지를 표시시키지 않는 목적이나 
경고메시지를 C<$@> 에 넣는 목적으로는 사용하지 말아주세요.
그런 용도에서는 C<$SIG{__WARN__}> 기능을 쓰거나 
S<C<no warnings 'all'>> 을 사용해서 BLOCK 이나 EXPR 의 내부에서 경고를 
꺼둘 필요가 있습니다.
L</warn>, L<perlvar>, L<warnings>, L<perllexwarn> 를 참조해주세요.

=begin original

Note that, because C<eval> traps otherwise-fatal errors, it is useful for
determining whether a particular feature (such as C<socket> or C<symlink>)
is implemented.  It is also Perl's exception trapping mechanism, where
the die operator is used to raise exceptions.

=end original

C<eval> 은 치명적인 에러가 될 것 같은 것을 트랩할 수 있기 때문에 
(C<socket> 이나 C<symlink> 같은) 특정의 기능이 구성되었는 가를 
조사기 위해 사용할 수 있다는 것에 주의해주세요.
die 연산자가 예외를 발생시키는 것이라면, 
이것은 또, Perl 의 예외보충기능으로 사용할 수도 있습니다.

=begin original

If the code to be executed doesn't vary, you may use the eval-BLOCK
form to trap run-time errors without incurring the penalty of
recompiling each time.  The error, if any, is still returned in C<$@>.
Examples:

=end original

실행하는 코드가 변하지 않는다면 매번 다량의 재 컴파일없이 
실행시 에러의 트랩을 수행하기 위해 eval-BLOCK 형식을 사용할 수 있습니다.
에러가 있다면 역시 $@ 로 반환됩니다.
예제:

    # make divide-by-zero nonfatal
    eval { $answer = $a / $b; }; warn $@ if $@;

    # same thing, but less efficient
    eval '$answer = $a / $b'; warn $@ if $@;

    # a compile-time error
    eval { $answer = };			# WRONG

    # a run-time error
    eval '$answer =';	# sets $@

=begin original

Using the C<eval{}> form as an exception trap in libraries does have some
issues.  Due to the current arguably broken state of C<__DIE__> hooks, you
may wish not to trigger any C<__DIE__> hooks that user code may have installed.
You can use the C<local $SIG{__DIE__}> construct for this purpose,
as shown in this example:

=end original

C<eval{}> 형식을 라이브리 예외를 트랩하기 위해 사용할 때에는 문제가 있습니다.
현재의 C<__DIE__> 후크의 상태는 거의 확실하게 무너진다는 이유로 
유저의 코드가 설정한 C<__DIE__> 후크를 설정하고 싶을지도 모ㅂ니다.
이 목적에는 아래의 예처럼, C<local $SIG{__DIE__}> 구조를 사용할 수 있습니다.

    # a very private exception trap for divide-by-zero
    eval { local $SIG{'__DIE__'}; $answer = $a / $b; };
    warn $@ if $@;

=begin original

This is especially significant, given that C<__DIE__> hooks can call
C<die> again, which has the effect of changing their error messages:

=end original

이것은 특히 원저입니다. 주어진 C<__DIE__> 후크는 C<die> 를 한번 더 
호출할 수 있고, 이것에 의해 에러 메시를 바꾸는 효과가 있습니다:

    # __DIE__ hooks may modify error messages
    {
       local $SIG{'__DIE__'} =
              sub { (my $x = $_[0]) =~ s/foo/bar/g; die $x };
       eval { die "foo lives here" };
       print $@ if $@;                # prints "bar lives here"
    }

=begin original

Because this promotes action at a distance, this counterintuitive behavior
may be fixed in a future release.

=end original

이것은 거리 먼 행동이기때문에 이 직감적이지 않은 행동은 
장래의 릴리즈에서는 수정될지도 모르겠습니다.

=begin original

With an C<eval>, you should be especially careful to remember what's
being looked at when:

=end original

C<eval> 에서는 아래처럼 할 경우는 
무엇이 조사되는 가에 특히 주의할 필요가 있습니다:

    eval $x;		# CASE 1
    eval "$x";		# CASE 2

    eval '$x';		# CASE 3
    eval { $x };	# CASE 4

    eval "\$$x++";	# CASE 5
    $$x++;		# CASE 6

=begin original

Cases 1 and 2 above behave identically: they run the code contained in
the variable $x.  (Although case 2 has misleading double quotes making
the reader wonder what else might be happening (nothing is).)  Cases 3
and 4 likewise behave in the same way: they run the code C<'$x'>, which
does nothing but return the value of $x.  (Case 4 is preferred for
purely visual reasons, but it also has the advantage of compiling at
compile-time instead of at run-time.)  Case 5 is a place where
normally you I<would> like to use double quotes, except that in this
particular situation, you can just use symbolic references instead, as
in case 6.

=end original

위의 CASE 1 과 CASE 2 의 동작은 같고, 변수 $x 안의 코드를 실행합니다.
(단, CASE 2 에서는 필요하지 않은 쌍따옴표에 의해 
읽는 사람이 뭔가 일어날지를 헷갈리게 됩니다(아무것도 일어나지 않지만).)
마찬가지로 CASE 3 와 CASE 4 의 동작도 같고 $x 의 값을 반환하는 이외에 
아무것도 하지않는 C<$x> 같은 코드를 실행합니다.
(순전히 겉보기의 문제로 CASE 4 가 선호되지만 실행시가 아닌 
컴파일 시에 컴파일된ㄴ 이점도 있습니다).
CASE 5 의 경우는 일반적으로 쌍따옴표를 사용합니다.
이 상황을 빼면 CASE 6 처럼 단순히 심볼릭 리퍼런스를 사용하면 됩니다.

=begin original

C<eval BLOCK> does I<not> count as a loop, so the loop control statements
C<next>, C<last>, or C<redo> cannot be used to leave or restart the block.

=end original

C<eval BLOCK> 은 루프로써 I<취급되지 않습니다>.
따라서, C<next>, C<last>, C<redo> 같은 루프 제어문에서 블록에서 떨어지거나
재실행하거나 할 수 없습니다.

=begin original

Note that as a very special case, an C<eval ''> executed within the C<DB>
package doesn't see the usual surrounding lexical scope, but rather the
scope of the first non-DB piece of code that called it. You don't normally
need to worry about this unless you are writing a Perl debugger.

=end original

매우 특수한 경우로써 C<DB> 패키지 안에서 C<eval ''> 을 실행하면 
일반적인 렉시컬 스코프가 아닌 이것을 호출한 첫번째의 비 DB 코드 편의 
영역이 됩니다.
Perl 디버거를 쓰는 것이 아닌 한, 보통은 이것ㅔ 대해서 걱정할 필요는 없습니다.

=item exec LIST
X<exec> X<execute>

=item exec PROGRAM LIST

=begin original

The C<exec> function executes a system command I<and never returns>--
use C<system> instead of C<exec> if you want it to return.  It fails and
returns false only if the command does not exist I<and> it is executed
directly instead of via your system's command shell (see below).

=end original

C<exec> 함수는 시스템 커맨드를 실행하고 I<돌아오지 않습니다>.
돌아오게 할 경우에는 C<exec> 가 아닌 C<system> 함수를 사용해세요.
커맨드가 존재하지 않고 I<거기에> 시스템의 커맨드 셸 경유가 아닌 
직접 커맨드를 실행하려고 한 경우에만 이 함수는 실패해서 거짓을 반환합니다.

=begin original

Since it's a common mistake to use C<exec> instead of C<system>, Perl
warns you if there is a following statement which isn't C<die>, C<warn>,
or C<exit> (if C<-w> is set  -  but you always do that).   If you
I<really> want to follow an C<exec> with some other statement, you
can use one of these styles to avoid the warning:

=end original

C<system> 대신에 C<exec> 를 사용하는 자주 있느 오용을 방지하기 위해
이어지는 구문이 C<die>, C<warn>, C<exit>(C<-w> 이 설정되어 있는 경우-
라도 항상 설정되어 있습니다) 이외의 경우, Perl 은 경고를 냅니다.
만약 I<정말로> C<exec> 의 뒤에 어떤 구문을 넣고 싶은 경우 
아래중 어느쪽의 스타일을 사용하는 것으로 경고를 피할 수 있습니다.

    exec ('foo')   or print STDERR "couldn't exec foo: $!";
    { exec ('foo') }; print STDERR "couldn't exec foo: $!";

=begin original

If there is more than one argument in LIST, or if LIST is an array
with more than one value, calls execvp(3) with the arguments in LIST.
If there is only one scalar argument or an array with one element in it,
the argument is checked for shell metacharacters, and if there are any,
the entire argument is passed to the system's command shell for parsing
(this is C</bin/sh -c> on Unix platforms, but varies on other platforms).
If there are no shell metacharacters in the argument, it is split into
words and passed directly to C<execvp>, which is more efficient.
Examples:

=end original

LIST 에 복수의 인수가 있는 경우나 LIST 가 복수의 값을 가진 배열인 경우에는
LIST 의 인수ㄹ 사용해서 execvp(3) 을 호출합니다.
하나의 스칼라변수만 똔느 요소가 하나의 배열의 경우에는 그 인수에서 
셸의 메타문자를 체크해서 만약 메타문자가 있으면, 
인수전체를 시스템의 커맨드셸(이것인 Unix 에서는 C</bin/sh -c> 입니다만
시스템에 따라 다릅니다)에 건내서 해석시킵니다.
만약 메타캐릭터가 없으면 그 인수를 단어로 나눠서 보다 효율적인 C<execvp>에
직접 건냅니다.
예제:

    exec '/bin/echo', 'Your arguments are: ', @ARGV;
    exec "sort $outfile | uniq";

=begin original

If you don't really want to execute the first argument, but want to lie
to the program you are executing about its own name, you can specify
the program you actually want to run as an "indirect object" (without a
comma) in front of the LIST.  (This always forces interpretation of the
LIST as a multivalued list, even if there is only a single scalar in
the list.)  Example:

=end original

첫번째 인수에 지정하는 것을 정말 실행하고 싶지만, 실행하는 프로그램에 대해
다른 이름을 가르쳐주고 싶은 경우에는 LIST 의 앞에 "간접오브젝트"(컴마없이)
로써 실제로 실행하고 싶은 프로그램을 지정할 수 있습니다.
(이것에 의해 LIST 에 단일의 스칼라밖에 없어도 복수 값의 리스트처럼 
LIST 해석을 수행합니다)
예제:

    $shell = '/bin/csh';
    exec $shell '-sh';		# pretend it's a login shell

=begin original

or, more directly,

=end original

혹은 보다 직접적으로,

    exec {'/bin/csh'} '-sh';	# pretend it's a login shell

=begin original

When the arguments get executed via the system shell, results will
be subject to its quirks and capabilities.  See L<perlop/"`STRING`">
for details.

=end original

인수가 시스템셸에서 실행될 때, 결과는 셸의 기벽과 능력에 의해 
바뀝니다.
자세한 내용은 L<perlop/" STRING "> 을 참조해주세요.

=begin original

Using an indirect object with C<exec> or C<system> is also more
secure.  This usage (which also works fine with system()) forces
interpretation of the arguments as a multivalued list, even if the
list had just one argument.  That way you're safe from the shell
expanding wildcards or splitting up words with whitespace in them.

=end original

C<exec> 나 C<system> 에서 간접오브젝트를 사용하는 것보다 안전합니다.
이 사용법(system() 에서도 마찬가지로 잘 움직입니다)은 설령 인수가 
하나인 경우도 복수의 값을 가지는 리스트로 인수를 해석하는 것을 강제합니다.
이 방법으로 셸에의한 와일드카드 전개나 공백에 의한 단어의 분할으로부터
지킬 수 있습니다.

    @args = ( "echo surprise" );

    exec @args;               # subject to shell escapes
                                # if @args == 1
    exec { $args[0] } @args;  # safe even with one-arg list

=begin original

The first version, the one without the indirect object, ran the I<echo>
program, passing it C<"surprise"> an argument.  The second version
didn't--it tried to run a program literally called I<"echo surprise">,
didn't find it, and set C<$?> to a non-zero value indicating failure.

=end original

간접오브젝트없는 첫번째의 바젼에서는 I<echo> 프로그램이 실행되고, 
C<"surprise"> 가 인수로써 넘겨집니다.
두번째의 버젼에서는 다릅니다 -- 문자대로 I<"echo surprise"> 라는 이름의
프로그램을 실행하려고해서 발견하지 못하기 때문에 실패한 일을 나타내기 위해
C<$?> 에 비 0가 설정됩니다.

=begin original

Beginning with v5.6.0, Perl will attempt to flush all files opened for
output before the exec, but this may not be supported on some platforms
(see L<perlport>).  To be safe, you may need to set C<$|> ($AUTOFLUSH
in English) or call the C<autoflush()> method of C<IO::Handle> on any
open handles in order to avoid lost output.

=end original

v5.6.0 에 Perl 은 exec 의 앞에 출력용으로 열려진 모든 파일을 
플래쉬하려고 하지만, 이것에 대응하지 않은 플랫폼도 있습니다
(L<perlport> 를 참조해주세요).
안전을 위해서는 출력이 중복하는 것을 피하기 위해 모든 오픈되어 있는
핸들에 대해 C<$|> (English 모듈에서는 $AUTOFLUSH) 를 설정하거나 
C<IO::Handle> 모듈의 C<autoflush()> 메소드를 호출할 필요가 
있을지도 모릅니다.

=begin original

Note that C<exec> will not call your C<END> blocks, nor will it call
any C<DESTROY> methods in your objects.

=end original

C<exec> 는 C<END> 블록이나 오브젝트의 C<DESTROY> 메소드를 
호출하지 않는 것에 주의해주세요.

=item exists EXPR
X<exists> X<autovivification>

=begin original

Given an expression that specifies a hash element or array element,
returns true if the specified element in the hash or array has ever
been initialized, even if the corresponding value is undefined.  The
element is not autovivified if it doesn't exist.

=end original

해쉬 요소가 배열요소를 나타내는 표현이 주어져, 설정된 요소가 
해쉬나 배열에 존재하ㄴ, 설령 대응하는 value 가 미정의라도 참을 반환합니다.
요소가 존재하지 않는 경우는 자동활성화되지 않습니다.

    print "Exists\n" 	if exists $hash{$key};
    print "Defined\n" 	if defined $hash{$key};
    print "True\n"      if $hash{$key};

    print "Exists\n" 	if exists $array[$index];
    print "Defined\n" 	if defined $array[$index];
    print "True\n"      if $array[$index];

=begin original

A hash or array element can be true only if it's defined, and defined if
it exists, but the reverse doesn't necessarily hold true.

=end original

해쉬 또는 배열요소는 정의되어 있을 때에만 참이 되고,
존재하고 있을 때에만 설정되지만, 그 반대는 반드시 참이 아닙니다.

=begin original

Given an expression that specifies the name of a subroutine,
returns true if the specified subroutine has ever been declared, even
if it is undefined.  Mentioning a subroutine name for exists or defined
does not count as declaring it.  Note that a subroutine which does not
exist may still be callable: its package may have an C<AUTOLOAD>
method that makes it spring into existence the first time that it is
called -- see L<perlsub>.

=end original

인수로써 서브루틴의 이름이 설정된 경우, 
지정된 서브루틴이 선언되어있으면(그게 미정의라도) 
참을 반환합니다.
exists 나 defined 를 위해 언급된 서브루틴 이름은 
선언으로써의 카운트에 들어가지 않습니다.
존재하지 않는 서브루틴에서도 호출가능할지도 모르는 것에 주의해주세요:
패키지가 C<AUTOLOAD> 메소드를 가지고 있고, 처음에 호출된 때에
존재를 만들어낼지도 모릅니다 -- L<perlsub> 를 참조해주세요.

    print "Exists\n" 	if exists &subroutine;
    print "Defined\n" 	if defined &subroutine;

=begin original

Note that the EXPR can be arbitrarily complicated as long as the final
operation is a hash or array key lookup or subroutine name:

=end original

최종적인 조작이 해쉬나 배열의 key 에 의해 검색 또는 서브루틴 이름인 한,
EXPR 에는 임의의 복잡한 식을 둘 수 있습니다:

    if (exists $ref->{A}->{B}->{$key}) 	{ }
    if (exists $hash{A}{B}{$key}) 	{ }

    if (exists $ref->{A}->{B}->[$ix]) 	{ }
    if (exists $hash{A}{B}[$ix]) 	{ }

    if (exists &{$ref->{A}{B}{$key}})   { }

=begin original

Although the deepest nested array or hash will not spring into existence
just because its existence was tested, any intervening ones will.
Thus C<< $ref->{"A"} >> and C<< $ref->{"A"}->{"B"} >> will spring
into existence due to the existence test for the $key element above.
This happens anywhere the arrow operator is used, including even:

=end original

중첩한 배열이나 해쉬의 제일 깊은 부분은 그 존재를 중첩한 것만으로는 
존재하게 되는 것은 아닙니다만 도중의 것은 존재하게 됩니다.
따라서 C<< $ref->{"A"} >> 와 C<< $ref->{"A"}->{"B"} >> 는 위의 $key 의
존재를 테스트한 것에 의해 존재하게 됩니다.
이것은 화살표 연산자가 사용되는 곳에서는 아래와 같은 것을 포함하는
어디에서라도 발생합니다.

    undef $ref;
    if (exists $ref->{"Some key"})	{ }
    print $ref; 	    # prints HASH(0x80d3d5c)

=begin original

This surprising autovivification in what does not at first--or even
second--glance appear to be an lvalue context may be fixed in a future
release.

=end original

한번 본 것만으로는 -- 혹은 두번 봐도 -- 놀라는 좌변치 컨텍스트에서의 
자동유효화는 앞으로의 릴리즈에서는 수정될 겁니다.

=begin original

Use of a subroutine call, rather than a subroutine name, as an argument
to exists() is an error.

=end original

exists() 의 인수로써 서브루틴 이름이 아닌 서브루틴 호출을 사용하면 
에러가 됩니다.

    exists &sub;	# OK
    exists &sub();	# Error

=item exit EXPR
X<exit> X<terminate> X<abort>

=item exit

=begin original

Evaluates EXPR and exits immediately with that value.    Example:

=end original

EXPR 을 평가해서 즉시 그 값을 가지고 종료합니다.
예제:

    $ans = <STDIN>;
    exit 0 if $ans =~ /^[Xx]/;

=begin original

See also C<die>.  If EXPR is omitted, exits with C<0> status.  The only
universally recognized values for EXPR are C<0> for success and C<1>
for error; other values are subject to interpretation depending on the
environment in which the Perl program is running.  For example, exiting
69 (EX_UNAVAILABLE) from a I<sendmail> incoming-mail filter will cause
the mailer to return the item undelivered, but that's not true everywhere.

=end original

C<die> 도 참조해주세요.
EXPR 이 생략된 경우에는 상태를 C<0> 로써 종료합니다.
EXPR 의 값으로써 넓게 이용가능한 것은 C<0> 이 성공으로 C<1> 이 에러라는 
것뿐입니다.
그 외의 값은 Perl 이 실행되는 환경에 의해 다른 해석이 될 가능성이 있습니다.
예를들어, I<sendmail> 도착 메일 필터에서 69 (EX_UNAVAILABLE) 로 
종료하면 메일러는 아이템을 배달하지 않고 되돌리지ㄴ, 
이것은 항상 참이 아닙니다.

=begin original

Don't use C<exit> to abort a subroutine if there's any chance that
someone might want to trap whatever error happened.  Use C<die> instead,
which can be trapped by an C<eval>.

=end original

누군가가 발생한 에러를 트랩하려고 생각할 가능성이 있는 경우는 
서브루틴의 중단에 C<exit> 를 사용하지 말아주세요.
대신에 C<eval> 로 트랩할 수 있는 C<die> 를 사용해주세요.

=begin original

The exit() function does not always exit immediately.  It calls any
defined C<END> routines first, but these C<END> routines may not
themselves abort the exit.  Likewise any object destructors that need to
be called are called before the real exit.  If this is a problem, you
can call C<POSIX:_exit($status)> to avoid END and destructor processing.
See L<perlmod> for details.

=end original

exit() 함수는 항상 바로 종료하는 것이 아닙니다.
우선 정의되어 있는 END 루틴을 호출하지만, C<END> 루틴 자신은 exit 를
멈출 수 없습니다.
마찬가지로 호출할 필요가 있는 오브젝트 파괴자는 모든 실제의 종료전에 
호출됩니다.
이것이 문제가 되는 경우는 END 나 파괴자가 실행되는 것을 
방지하기 위해 C<POSIX:_exit($status)> 를 호출해주세요.
자세한 내용은 L<perlmod> 를 참조해주세요.

=item exp EXPR
X<exp> X<exponential> X<antilog> X<antilogarithm> X<e>

=item exp

=begin original

Returns I<e> (the natural logarithm base) to the power of EXPR.
If EXPR is omitted, gives C<exp($_)>.

=end original

I<e> (자연대수의 기반) 의 EXPR 승을 반환합니다.
EXPR 을 생략한 경우에는, C<exp($_)> 를 반환합니다.

=item fcntl FILEHANDLE,FUNCTION,SCALAR
X<fcntl>

=begin original

Implements the fcntl(2) function.  You'll probably have to say

=end original

fcntl(2) 함수를 구성합니다.
바른 정수정의를 얻기 위해서는 우선,

    use Fcntl;

=begin original

first to get the correct constant definitions.  Argument processing and
value return works just like C<ioctl> below.
For example:

=end original

이라고 쓸 필요가 있습니다.
인수의 처리와 반환값에 대해서는 아래의 C<ioctl> 처럼 동작합니다.
예제:

    use Fcntl;
    fcntl($filehandle, F_GETFL, $packed_return_buffer)
	or die "can't fcntl F_GETFL: $!";

=begin original

You don't have to check for C<defined> on the return from C<fcntl>.
Like C<ioctl>, it maps a C<0> return from the system call into
C<"0 but true"> in Perl.  This string is true in boolean context and C<0>
in numeric context.  It is also exempt from the normal B<-w> warnings
on improper numeric conversions.

=end original

C<fcntl> 에서 반환값의 체크에 C<defined> 를 사용할 필요는 없습니다.
C<ioctl> 과는 달리 C<fnctl> 은 시스템 호출의 결과가 C<0> 인 경우는 
C<"0 이지만 참"> 을 반환합니다.
이 문자열은 참 거짓 값 컨텍스트에서는 참이기에 
숫자값 컨텍스트에서는 C<0> 이 됩니다.
이것은 또, 부적절한 숫자변환에 관해 일반적으로 B<-w> 경고를 회피합니다.

=begin original

Note that C<fcntl> will produce a fatal error if used on a machine that
doesn't implement fcntl(2).  See the Fcntl module or your fcntl(2)
manpage to learn what functions are available on your system.

=end original

fcntl(2) 이 구성되어 있지 않은 머신에서는 C<fcntl> 은 치명적인 에러를
발생시키는 것에 주의í세요.
시스템에서 어느 함수가 이용가능한 가에 대해서는 Fcntl 모듈나 
fcntl(2) man 페이지를 참조해주세요.

=begin original

Here's an example of setting a filehandle named C<REMOTE> to be
non-blocking at the system level.  You'll have to negotiate C<$|>
on your own, though.

=end original

이것은 C<REMOTE> 라는 파일핸들을 시스템레벨에서 
비 블록모드로 설정하는 예제입니다.
단, C<$|> 을 자신이 관리하지 않으면 안됩니다.

    use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);

    $flags = fcntl(REMOTE, F_GETFL, 0)
                or die "Can't get flags for the socket: $!\n";

    $flags = fcntl(REMOTE, F_SETFL, $flags | O_NONBLOCK)
                or die "Can't set flags for the socket: $!\n";

=item fileno FILEHANDLE
X<fileno>

=begin original

Returns the file descriptor for a filehandle, or undefined if the
filehandle is not open.  This is mainly useful for constructing
bitmaps for C<select> and low-level POSIX tty-handling operations.
If FILEHANDLE is an expression, the value is taken as an indirect
filehandle, generally its name.

=end original

파일핸들에 대한 파일 기술자를 반환합니다.
파일핸들이 오픈되어있지 않은 경우는 미정의값을 반환합니다.
이것은 주로 C<select> 나 저레벨 POSIX tty 조작에 대해 비트맵을 
구성할 때에 편리합니다.
파일핸들이 식이면 
그 값이 간접 파일핸들(보통은 이름)으로 사용됩니다.

=begin original

You can use this to find out whether two handles refer to the
same underlying descriptor:

=end original

이것은 두개의 핸들이 같은 식별자를 참조하고 있는지 어떤지 발견하는 것에
사용할 수 있습니다:

    if (fileno(THIS) == fileno(THAT)) {
	print "THIS and THAT are dups\n";
    }

=begin original

(Filehandles connected to memory objects via new features of C<open> may
return undefined even though they are open.)

=end original

(C<open> 의 신기능에 대해서 메모리에 접속된 파일핸들은 열려 있는 때에도
미정의 값을 반환합니다)

=item flock FILEHANDLE,OPERATION
X<flock> X<lock> X<locking>

=begin original

Calls flock(2), or an emulation of it, on FILEHANDLE.  Returns true
for success, false on failure.  Produces a fatal error if used on a
machine that doesn't implement flock(2), fcntl(2) locking, or lockf(3).
C<flock> is Perl's portable file locking interface, although it locks
only entire files, not records.

=end original

FILEHANDLE 에 대해서 flock(2) 또는 그 에뮬레이터를 호출합니다.
성공시에는 참을 실패시에는 거짓을 반환합니다.
flock(2), fcntl(2) ロック, lockf(3) 중 어느 것을 
구성하지 않은 머신을 사용하면 치명적인 에러가 발생합니다.
C<flock> 은 Perl 의 이식성 있는 파일잠금 인터페이스입니다.
그러나 레코드가 아닌 파일 전체만을 잠급니다.

=begin original

Two potentially non-obvious but traditional C<flock> semantics are
that it waits indefinitely until the lock is granted, and that its locks
B<merely advisory>.  Such discretionary locks are more flexible, but offer
fewer guarantees.  This means that programs that do not also use C<flock>
may modify files locked with C<flock>.  See L<perlport>, 
your port's specific documentation, or your system-specific local manpages
for details.  It's best to assume traditional behavior if you're writing
portable programs.  (But if you're not, you should as always feel perfectly
free to write for your own system's idiosyncrasies (sometimes called
"features").  Slavish adherence to portability concerns shouldn't get
in the way of your getting your job done.)

=end original

명백하지 않은, 전통적인 C<flock> 의 동작으로써는 잠금이 얻기 까지 
무한하게 계속 가ㄹ 수 있는 것과 B<단순히 권고적인> 잠그는 것이 두개 있습니다.
이런 자유재량의 록은 보다 유연하지만 보장되는 것은 더 작습니다.
이것은 C<flock> 을 사용하지 않는 프로그램이 C<flock> 에서 록된 파일을 
바꿀지도 모르는 것을 의미합니다.
자세한 내용에 대해서는 L<perlport>, 시스템 고유의 문서, 시스템 고유의 
로컬 man 페이지를 참조해주세요.
이식성 있는 프로그램을 쓰는 경우는 전통적인 행동을 가정하는 것이 
최고입니다.
(그러나 이식성 없는 프로그램을 쓸 경우는 자신의 시스템 성벽(때로는 사양이라고
불립니다) 에 맞춰서 ㄱ쓰는 것도 완전히 자유입니다.
맹목적으로 이식성을 고집하는 것으로 당신의 작업을 하는 것을 방해해야하는 것은
아닙니다)

=begin original

OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with
LOCK_NB.  These constants are traditionally valued 1, 2, 8 and 4, but
you can use the symbolic names if you import them from the Fcntl module,
either individually, or as a group using the ':flock' tag.  LOCK_SH
requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN
releases a previously requested lock.  If LOCK_NB is bitwise-or'ed with
LOCK_SH or LOCK_EX then C<flock> will return immediately rather than blocking
waiting for the lock (check the return status to see if you got it).

=end original

OPERATION 은 LOCK_SH, LOCK_EX, LOCK_UN 중에서 LOCK_NB 과 조합될 수도 있습니다.
이 정수들은 전통적으로는 1, 2, 8, 4 의 값을 가지지만, Fcntl 모듈에서는
심볼이름을 독립해서 임포트하거나 ':flock' 태그를 사용해 그룹으로써 
심볼이름을 사용할 수 있습니다.
LOCK_SH 는 공유 록을 요구하고, LOCK_EX 는 배타 록을 요구하며, LOCK_UN 은 
앞서 요구한 록을 개방합니다.
LOCK_NB 와 LOCK_SH 나 LOCK_EX 가 비트단위의 논리합되면 C<flock> 은 
록을 얻기까지 기다리는 것이 아니라 곧 반환합니다(록이 취득되었는지 
어떤지는 반환값을 조사합니다).

=begin original

To avoid the possibility of miscoordination, Perl now flushes FILEHANDLE
before locking or unlocking it.

=end original

불일치 가능성을 피하기 위해 Perl 은 파일을 록, 언록하기 전에 
FILEHANDLE 을 플러쉬ㅂ니다.

=begin original

Note that the emulation built with lockf(3) doesn't provide shared
locks, and it requires that FILEHANDLE be open with write intent.  These
are the semantics that lockf(3) implements.  Most if not all systems
implement lockf(3) in terms of fcntl(2) locking, though, so the
differing semantics shouldn't bite too many people.

=end original

lockf(3) 에서 작성한 에뮬레이션은 공유록을 제공하지 않고, 
FILEHANDLE 이 쓰기 모드에서 열려있는 것을 필요로 하는 것에 주의하세요.
이것은 lockf(3) 가 구성하고 있는 동작입니다.
그러나, 전부는 아니라고 해도 대부분의 시스템에서는 fcntl(2) 를 사용해서
lockf(3) 를 구성하고 있기 때문에, 다른 동작으로 많은 사람들을 혼란시키는
것은 없을 것입니다.

=begin original

Note that the fcntl(2) emulation of flock(3) requires that FILEHANDLE
be open with read intent to use LOCK_SH and requires that it be open
with write intent to use LOCK_EX.

=end original

flock(3) 의 fnctl(2) 에뮬레션은 LOCK_SH 를 사용하기위해 
FILEHANDLE 을 읽기에서 열려있을 필요가 있고, LOCK_EX 를 사용하기 위해 
쓰기에서 열려있을 필요가 있다는 것에 주의하세요.

=begin original

Note also that some versions of C<flock> cannot lock things over the
network; you would need to use the more system-specific C<fcntl> for
that.  If you like you can force Perl to ignore your system's flock(2)
function, and so provide its own fcntl(2)-based emulation, by passing
the switch C<-Ud_flock> to the F<Configure> program when you configure
perl.

=end original

네트워크를 넘어서는 록할수 없는 C<flock> 도 있는 것에 주의해주세요;
이 때문에 보다 시스템 의존적인 C<fcntl> 을 사용할 필요가 있습니다.
Perl 시스템의 flock(2) 함수를 무시시키고, 자신의 fcntl(2) 베이스의
에뮬레이션을 사용하는 경우는 Perl 을 설정할 대에 F<Configure> 
프로그램에 C<-Ud_flock> 옵션을 건네주세요.

=begin original

Here's a mailbox appender for BSD systems.

=end original

BSD 시스템에서의 메일박스로의 추가처리의 예제를 나타냅니다.

    use Fcntl ':flock'; # import LOCK_* constants

    sub lock {
	flock(MBOX,LOCK_EX);
	# and, in case someone appended
	# while we were waiting...
	seek(MBOX, 0, 2);
    }

    sub unlock {
	flock(MBOX,LOCK_UN);
    }

    open(MBOX, ">>/usr/spool/mail/$ENV{'USER'}")
	    or die "Can't open mailbox: $!";

    lock();
    print MBOX $msg,"\n\n";
    unlock();

=begin original

On systems that support a real flock(), locks are inherited across fork()
calls, whereas those that must resort to the more capricious fcntl()
function lose the locks, making it harder to write servers.

=end original

진정으로 flock() 에 대응하고 있는 시스템에서는 록은 fork() 를 통해서 
계승되는 것에 대해서 보다 불안전한 fcntl() 에 연결되지 않으면 안되는 경우
서버를 쓰는 것은 보다 힘들게 됩니다.

=begin original

See also L<DB_File> for other flock() examples.

=end original

그 밖의 flock() 의 예제로써는 L<DB_File> 도 참조해주세요.

=item fork
X<fork> X<child> X<parent>

=begin original

Does a fork(2) system call to create a new process running the
same program at the same point.  It returns the child pid to the
parent process, C<0> to the child process, or C<undef> if the fork is
unsuccessful.  File descriptors (and sometimes locks on those descriptors)
are shared, while everything else is copied.  On most systems supporting
fork(), great care has gone into making it extremely efficient (for
example, using copy-on-write technology on data pages), making it the
dominant paradigm for multitasking over the last few decades.

=end original

같은 프로그램의 같은 지점에서 개시하는 새로운 프로세스를 작성하기 위해 
시스템 호출 fork(2) 를 수행합니다.
부모 프로세스에는 자식 프로세스의 pid 를 
자식 프로세스에는 C<0> 을 반환하지만,
fork 에 실패한 때에는 C<undef> 를 반환합니다.
파일의 기술자(및 기술자에 관한 록)은 공유되어 
그 밖의 모든 것은 복사됩니다.
fork() 에 대응하는 대부분의 시스템에서는 
이것을 최대한 효율적으로 하기위해 많은 노력을 기울이고 있습니다
(예를 들어, 데이터베이스로의 copy-on-write 테크놀로지등입니다).
이것은 이 20년에 걸친 멀티태스크에 관한 주요한 패러다임이 되고 있습니다.

=begin original

Beginning with v5.6.0, Perl will attempt to flush all files opened for
output before forking the child process, but this may not be supported
on some platforms (see L<perlport>).  To be safe, you may need to set
C<$|> ($AUTOFLUSH in English) or call the C<autoflush()> method of
C<IO::Handle> on any open handles in order to avoid duplicate output.

=end original

v5.6.0 에서 Perl 은 자식프로스를 fork 하기 전에 출력용으로 오픈되어 있는 
모든 파일을 플러쉬하려고 합니다만, 이것에 대응하고 있지 않은 플랫폼도 
있습니다(L<perlport> 를 참조해주세요).
안전을 위해, 출력이 중복하는 것을 피하기 위해, 모든 오픈되어 있는 핸들에 대해 
C<$|> (English 모듈에서는 $AUTOFLUSE) 를 설정하거나 
C<IO::Handle> 모듈의 C<autoflush()> 메소드를 호출할 필요가 있을지도 모릅니다.

=begin original

If you C<fork> without ever waiting on your children, you will
accumulate zombies.  On some systems, you can avoid this by setting
C<$SIG{CHLD}> to C<"IGNORE">.  See also L<perlipc> for more examples of
forking and reaping moribund children.

=end original

자식 프로세스의 종료를 기다리지 않고, C<fork> 를 반복하면, 
좀비를 양산하게 됩니다. 
C<$SIG{CHLD*> 에 C<"IGNORE"> 를 지정하는 것으로 이것을 피할 수 있는 
시스템도 있습니다. fork 와 소멸에 걸친 자식 프로세스를 회수하기 위한
예제에 대해서는 L<perlpc> 도 참조해주세요.

=begin original

Note that if your forked child inherits system file descriptors like
STDIN and STDOUT that are actually connected by a pipe or socket, even
if you exit, then the remote server (such as, say, a CGI script or a
backgrounded job launched from a remote shell) won't think you're done.
You should reopen those to F</dev/null> if it's any issue.

=end original

fork 한 자식 프로세스가 STDIN 이나 STDOUT 같은 시스템 파일 기술자를 
상속하는 경우 (CGI 스크립트나 리모트 셸같은 백그라운드 잡 같은) 
리모트 서버는 생각한대로 움직이지 않을 것이라는 것에 주의해주세요.
이런 경우에서는 이것들을 F</dev/null> 로 다 오픈해야 합니다.

=item format
X<format>

=begin original

Declare a picture format for use by the C<write> function.  For
example:

=end original

C<write> 함수로 사용하는 그림 포맷을 선언합니다.
예제:

    format Something =
	Test: @<<<<<<<< @||||| @>>>>>
	      $str,     $%,    '$' . int($num)
    .

    $str = "widget";
    $num = $cost/$quantity;
    $~ = 'Something';
    write;

=begin original

See L<perlform> for many details and examples.

=end original

자세한 내용과 예제에 대해서는 L<perlform> 을 참조하세요.

=item formline PICTURE,LIST
X<formline>

=begin original

This is an internal function used by C<format>s, though you may call it,
too.  It formats (see L<perlform>) a list of values according to the
contents of PICTURE, placing the output into the format output
accumulator, C<$^A> (or C<$ACCUMULATOR> in English).
Eventually, when a C<write> is done, the contents of
C<$^A> are written to some filehandle.  You could also read C<$^A>
and then set C<$^A> back to C<"">.  Note that a format typically
does one C<formline> per line of form, but the C<formline> function itself
doesn't care how many newlines are embedded in the PICTURE.  This means
that the C<~> and C<~~> tokens will treat the entire PICTURE as a single line.
You may therefore need to use multiple formlines to implement a single
record format, just like the format compiler.

=end original

이것은 C<format> 이 사용하는 내부함수입니다만 직접 호출할 수도 있습니다.
이것은 PICTURE 의 내용에 따라서 LIST 의 값을 바꿔서 (L<perlform> 을 
참조하세요) 결과를 포맷출력 아큐물레이터 C<$^A> (English 모듈에서는 
C<$ACCUMULATOR>) 에 넣습니다.
최정적으로는 C<write> 가 실행되면 C<$^A> 의 내용이 
어떤 파일 핸들에 쓰여집니다.
또, 자신이 C<$^A> 를 읽고 C<$^A> 의 내용을 C<""> 에 돌아가도 상관없습니다.
format 은 일반적으로 한 줄마다 C<formline> 을 수행하지만, 
C<formline> 함수자신은 PICTURE 의 안에 몇개의 개행이 들어있는 가는 
관계가 없습니다.
이것은 C<~> 과 C<~~> 토큰은 PICTURE 전체를 한줄로써 다루는 것을 의미합니다.
따라서 한 레코드 포맷을 구성하기 위해서는 
포맷컴파일러 같은 복수 formline 을 사용할 필요가 있습니다.

=begin original

Be careful if you put double quotes around the picture, because an C<@>
character may be taken to mean the beginning of an array name.
C<formline> always returns true.  See L<perlform> for other examples.

=end original

쌍따옴표로 PICTURE 를 감싸는 경우에는 C<@> 같은 문자가 
배열이름의 시작으로 해석되기 때문에 주의해주세요.
C<formline> 은 항상 참을 반환합니다.
그외의 예제에 대해서는 L<perlform> 을 참조해주세요.

=item getc FILEHANDLE
X<getc> X<getchar> X<character> X<file, read>

=item getc

=begin original

Returns the next character from the input file attached to FILEHANDLE,
or the undefined value at end of file, or if there was an error (in
the latter case C<$!> is set).  If FILEHANDLE is omitted, reads from
STDIN.  This is not particularly efficient.  However, it cannot be
used by itself to fetch single characters without waiting for the user
to hit enter.  For that, try something more like:

=end original

FILEHANDLE 에 연결되어 있는 입력 파일에서 다음의 한문자를 반환합니다.
파일의 마지막 또는 에러가 발생한 경우는 미정의값을 반환합니다
(후자의 경우는 C<$!> 가 정의됩니다).
FILEHANDLE 이 생략된 경우에는 STDIN 에서 읽기를 수행합니다.
이것은 특히 효율적이지 않습니다.
그러나 이것은 유저가 리턴키를 누르는 것을 가지지 않고 
한문자를 읽는 용도로는 사용할 수 없습니다.
그런 경우에는 아래와 같은 것을 시험해주세요.

    if ($BSD_STYLE) {
	system "stty cbreak </dev/tty >/dev/tty 2>&1";
    }
    else {
	system "stty", '-icanon', 'eol', "\001";
    }

    $key = getc(STDIN);

    if ($BSD_STYLE) {
	system "stty -cbreak </dev/tty >/dev/tty 2>&1";
    }
    else {
	system "stty", 'icanon', 'eol', '^@'; # ASCII null
    }
    print "\n";

=begin original

Determination of whether $BSD_STYLE should be set
is left as an exercise to the reader.

=end original

$BSD_STYLE 을 설정하는 가 어떤가를 결정하는 방법에 대해서는 
독자에게 숙제로 남겨두겠습니다.

=begin original

The C<POSIX::getattr> function can do this more portably on
systems purporting POSIX compliance.  See also the C<Term::ReadKey>
module from your nearest CPAN site; details on CPAN can be found on
L<perlmodlib/CPAN>.

=end original

C<POSIX::getattr> 함수는 POSIX 에 준하는 처리를 주장하는 시스템으로 
이것을 보다 이석성있는 형태로 수행합니다.
가까운 CPAN 사이트에서 C<Term::ReadKey> 모듈도 참조해주세요;
CPAN 에 관한 자세한 내용은 L<perlmodlib/CPAN> 에 있습니다.

=item getlogin
X<getlogin> X<login>

=begin original

This implements the C library function of the same name, which on most
systems returns the current login from F</etc/utmp>, if any.  If null,
use C<getpwuid>.

=end original

이것은 같은 이름의 C 라이브러리 함수를 구성하고 있고,
많은 시스템에서는 만약있다면 /etc/utmp/ 에서 현재의 로그인이름을 반환합니다.
Null 이면 getpwuid() 를 사용해주세요.

    $login = getlogin || getpwuid($<) || "Kilroy";

=begin original

Do not consider C<getlogin> for authentication: it is not as
secure as C<getpwuid>.

=end original

C<getlogin> 을 인증에 사용해서는 안됩니다.
이것은 C<gwtpwuid> 처럼 안전하지 않습니다.

=item getpeername SOCKET
X<getpeername> X<peer>

=begin original

Returns the packed sockaddr address of other end of the SOCKET connection.

=end original

SOCKET 연결의 반대쪽의 pack 된 aockaddr 주소를 반환합니다.

    use Socket;
    $hersockaddr    = getpeername(SOCK);
    ($port, $iaddr) = sockaddr_in($hersockaddr);
    $herhostname    = gethostbyaddr($iaddr, AF_INET);
    $herstraddr     = inet_ntoa($iaddr);

=item getpgrp PID
X<getpgrp> X<group>

=begin original

Returns the current process group for the specified PID.  Use
a PID of C<0> to get the current process group for the
current process.  Will raise an exception if used on a machine that
doesn't implement getpgrp(2).  If PID is omitted, returns process
group of current process.  Note that the POSIX version of C<getpgrp>
does not accept a PID argument, so only C<PID==0> is truly portable.

=end original

지정된 PID 의 현재의 프로세스그룹을 반환합니다.
PID 에 C<0> 을 주면 최근 프로세스의 지정이 됩니다.
gerpgrp(2) 를 구성하고 있지 않은 머신에서 실행한 경우에는 예외가 발생합니다.
PID 를 생략하면 최근 프로세스의 프로세스 그룹을 반환합니다.
POSIX 판의 C<getpgrp> 는 PID 인수를 받지 않기 때문에, 
C<PID==0> 만이 완전히 이식성이 있습니다.

=item getppid
X<getppid> X<parent> X<pid>

=begin original

Returns the process id of the parent process.

=end original

부모 프로세스의 프로세스 id 를 반환합니다.

=begin original

Note for Linux users: on Linux, the C functions C<getpid()> and
C<getppid()> return different values from different threads. In order to
be portable, this behavior is not reflected by the perl-level function
C<getppid()>, that returns a consistent value across threads. If you want
to call the underlying C<getppid()>, you may use the CPAN module
C<Linux::Pid>.

=end original

Linux 유저에게 주의: Linux 에서는 C<getpid()> 와 C<getppid()> 의 C 함수는
스레드가 다르면 다른 값을 반환합니다.
이식성을 위해 이 행동은 perl 레벨의 함수 C<getppid()> 에는 
반영되지 않고, 스레드를 일관성있는 값을 반환합니다.
기초가 되는 C<getppid()> 를 호출하고 싶은 경우는 CPAN 모듈인 
C<Linux::Pid> 를 사용해주세요.

=item getpriority WHICH,WHO
X<getpriority> X<priority> X<nice>

=begin original

Returns the current priority for a process, a process group, or a user.
(See L<getpriority(2)>.)  Will raise a fatal exception if used on a
machine that doesn't implement getpriority(2).

=end original

프로세스, 프로세스그룹, 유저에 대한 현재의 우선도를 반환합니다.
( L<getpriority(2)> 를 참조해주세요.)
getpriority(2) 를 구성하지 않는 
머신에서 실행한 경우에는 치명적 예외가 발생합니다.

=item getpwnam NAME
X<getpwnam> X<getgrnam> X<gethostbyname> X<getnetbyname> X<getprotobyname>
X<getpwuid> X<getgrgid> X<getservbyname> X<gethostbyaddr> X<getnetbyaddr>
X<getprotobynumber> X<getservbyport> X<getpwent> X<getgrent> X<gethostent>
X<getnetent> X<getprotoent> X<getservent> X<setpwent> X<setgrent> X<sethostent>
X<setnetent> X<setprotoent> X<setservent> X<endpwent> X<endgrent> X<endhostent>
X<endnetent> X<endprotoent> X<endservent> 

=item getgrnam NAME

=item gethostbyname NAME

=item getnetbyname NAME

=item getprotobyname NAME

=item getpwuid UID

=item getgrgid GID

=item getservbyname NAME,PROTO

=item gethostbyaddr ADDR,ADDRTYPE

=item getnetbyaddr ADDR,ADDRTYPE

=item getprotobynumber NUMBER

=item getservbyport PORT,PROTO

=item getpwent

=item getgrent

=item gethostent

=item getnetent

=item getprotoent

=item getservent

=item setpwent

=item setgrent

=item sethostent STAYOPEN

=item setnetent STAYOPEN

=item setprotoent STAYOPEN

=item setservent STAYOPEN

=item endpwent

=item endgrent

=item endhostent

=item endnetent

=item endprotoent

=item endservent

=begin original

These routines perform the same functions as their counterparts in the
system library.  In list context, the return values from the
various get routines are as follows:

=end original

이 루틴들은 시스템 라이브러리의 같은 이름의 함수를 실행합니다.
리스트 컨텍스트에서는 여러가지 get 루틴에서의 반환값은 
다음과 같이 됩니다:

    ($name,$passwd,$uid,$gid,
       $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*
    ($name,$passwd,$gid,$members) = getgr*
    ($name,$aliases,$addrtype,$length,@addrs) = gethost*
    ($name,$aliases,$addrtype,$net) = getnet*
    ($name,$aliases,$proto) = getproto*
    ($name,$aliases,$port,$proto) = getserv*

=begin original

(If the entry doesn't exist you get a null list.)

=end original

(엔트리가 존재하지 않으면 빈 리스트가 반환됩니다)

=begin original

The exact meaning of the $gcos field varies but it usually contains
the real name of the user (as opposed to the login name) and other
information pertaining to the user.  Beware, however, that in many
system users are able to change this information and therefore it
cannot be trusted and therefore the $gcos is tainted (see
L<perlsec>).  The $passwd and $shell, user's encrypted password and
login shell, are also tainted, because of the same reason.

=end original

$gcos 필드의 정확한 의미는 여러가지 입니다만, 일반적으로는(로그인 이름이 아닌)
유저의 실제의 이름과 유저에 부합하는 정보를 포함합니다.
단, 많은 시스템에서는 유저가 이 정보를 변경할 수 있기때문에, 이 정보는 
신뢰할 수 없고, 따라서 $gcos 는 오염됩니다(L<perlsec> 를 참조해주세요).
유저의 암호화된 패스워드와 로그인셸인 $passwd 와 $shell 도 
같은 이유로 오염됩니다.

=begin original

In scalar context, you get the name, unless the function was a
lookup by name, in which case you get the other thing, whatever it is.
(If the entry doesn't exist you get the undefined value.)  For example:

=end original

스칼라 컨텍스트에서는 *name, *byname 같은 NAME 으로 검색하는 것 이외에는 
name 을 반환하고 NAME 로 검색하는 것은 뭔가 다른 것을 반환합니다.
(엔트리가 존재하지 않으면 미정의값을 반환합니다)
예제:

    $uid   = getpwnam($name);
    $name  = getpwuid($num);
    $name  = getpwent();
    $gid   = getgrnam($name);
    $name  = getgrgid($num);
    $name  = getgrent();
    #etc.

=begin original

In I<getpw*()> the fields $quota, $comment, and $expire are special
cases in the sense that in many systems they are unsupported.  If the
$quota is unsupported, it is an empty scalar.  If it is supported, it
usually encodes the disk quota.  If the $comment field is unsupported,
it is an empty scalar.  If it is supported it usually encodes some
administrative comment about the user.  In some systems the $quota
field may be $change or $age, fields that have to do with password
aging.  In some systems the $comment field may be $class.  The $expire
field, if present, encodes the expiration period of the account or the
password.  For the availability and the exact meaning of these fields
in your system, please consult your getpwnam(3) documentation and your
F<pwd.h> file.  You can also find out from within Perl what your
$quota and $comment fields mean and whether you have the $expire field
by using the C<Config> module and the values C<d_pwquota>, C<d_pwage>,
C<d_pwchange>, C<d_pwcomment>, and C<d_pwexpire>.  Shadow password
files are only supported if your vendor has implemented them in the
intuitive fashion that calling the regular C library routines gets the
shadow versions if you're running under privilege or if there exists
the shadow(3) functions as found in System V (this includes Solaris
and Linux.)  Those systems that implement a proprietary shadow password
facility are unlikely to be supported.

=end original

I<getpw*()> 에서는 $quota, $comment, $expire 필드는 많은 시스템에서는 
대응하지 않기에 특별한 처리가 됩니다.
$quota 가 비대응인 경우 빈 스칼라가 됩니다.
대응하고 있는 경우 일반적인 디스크쿼터의 값이 들어갑니다.
$comment 필드가 비대응일 경우, 빈 스칼라가 됩니다.
대응하고 있는 경우, 일반으로는 유저에 관한 관리상의 커멘트가 들어갑니다.
$quota 필드는 패스워드의 수명을 나타내고 $change 나 $age 인 시스템도 있습니다.
$comment 필드는 $class 인 시스템도 있습니다.
$expire 필드가 있는 경우는 계정이나 패스워드가 시간이 끊긴 기간이 들어갑니다.
동작시키는 시스템에서의 이 필드들의 유효성과 정확한 의미에 대해서는 
getpwnam(3) 의 문서와 F<pwd.h> 필드를 참조해주세요.
$quota 와 $comment 필드가 무엇을 의미하고 있는 가와 $expire 필드가 
있는 지 어떤지는 C<Config> 모듈을 사용해서 C<d_pwquota>, C<d_pwage>, 
C<d_pwchange>, C<d_pwcomment>, C<d_pwexpire> 의 값을 조사하는 것에 의해 
Perl 자신이 조사할 수 도 있습니다.
섀도우패스워드는 일반적인 C 라이브러리루틴을 권한이 있는 상태에서 
호출하는 것으로 섀도우 판을 얻을 수 있지만, System V 에 있는 
(Solaris 와 Linux 를 포함합니다) shadow(3) 함수가 있으면
직감적인 방법으로 구성되는 경우만 대응됩니다.
독점적인 섀도우패스워드 기능을 구성하고 잇는 시스템에서는 
그것에 대응되는 것은 없습니.

=begin original

The $members value returned by I<getgr*()> is a space separated list of
the login names of the members of the group.

=end original

I<getgr*()> 에 의해 반환되는 값 $members 는 그룹의 멤버의 로그인이름을 
스페이스로 구분한 것입니다.

=begin original

For the I<gethost*()> functions, if the C<h_errno> variable is supported in
C, it will be returned to you via C<$?> if the function call fails.  The
C<@addrs> value returned by a successful call is a list of the raw
addresses returned by the corresponding system library call.  In the
Internet domain, each address is four bytes long and you can unpack it
by saying something like:

=end original

I<gethost*()> 함수에서는 C 로 C<h_errno> 변수가 지원되면, 
함수호출이 실패한 때는 C<$?> 를 통해서 그 값이 반환됩니다.
성공시에 반환되는 C<@addrs> 값은 대응하는 시스템 호출이 반환한
raw address 의 리스트입니다.
인터넷도메인에서는 각각의 주소는 4바이트의 기리로 
아래처럼 해서 unpack 할 수가 있습니다.

    ($a,$b,$c,$d) = unpack('W4',$addr[0]);

=begin original

The Socket library makes this slightly easier:

=end original

Socket 라이브러리를 사용하면 조금 더 간단하게 됩니다.

    use Socket;
    $iaddr = inet_aton("127.1"); # or whatever address
    $name  = gethostbyaddr($iaddr, AF_INET);

    # or going the other way
    $straddr = inet_ntoa($iaddr);

=begin original

In the opposite way, to resolve a hostname to the IP address
you can write this:

=end original

거꾸로 호스트이름으로부터 IP 주소를 해결하기 위해서는 아래처럼 쓸 수 있습니다:
    use Socket;
    $packed_ip = gethostbyname("www.perl.org");
    if (defined $packed_ip) {
        $ip_address = inet_ntoa($packed_ip);
    }

=begin original

Make sure <gethostbyname()> is called in SCALAR context and that
its return value is checked for definedness.

=end original

C<gethostbyname()> 는 스칼라 컨텍스트에서 호출되게 해서 반환값이 
구성되는 지를 반드시 체크해주세요.

=begin original

If you get tired of remembering which element of the return list
contains which return value, by-name interfaces are provided
in standard modules: C<File::stat>, C<Net::hostent>, C<Net::netent>,
C<Net::protoent>, C<Net::servent>, C<Time::gmtime>, C<Time::localtime>,
and C<User::grent>.  These override the normal built-ins, supplying
versions that return objects with the appropriate names
for each field.  For example:

=end original

반환값의 리스트의 몇번째가 어떤 요소인가를 기억하는 것이 힘들다면 
이름 기반의 인터페이스가 표준 모듈로 제공되어 있습니다:
C<File::stat>, C<Net::hostent>, C<Net::netent>,
C<Net::protoent>, C<Net::servent>, C<Time::gmtime>, C<Time::localtime>,
C<User::grent> 입니다.
이것들은 통상의 일반 내장함수를 오버라이드해서 
각각의 필드에 적절한 이름을 붙인 오브젝트를 반환합니다.
예제:

   use File::stat;
   use User::pwent;
   $is_his = (stat($filename)->uid == pwent($whoever)->uid);

=begin original

Even though it looks like they're the same method calls (uid),
they aren't, because a C<File::stat> object is different from
a C<User::pwent> object.

=end original

같은 메소드(uid) 를 호출하는 듯이 보이지만, 다릅니.
왜냐면 C<File::stat> 오브젝트는 C<User::pwent> 오브젝트와는 
다르기 때문입니다.

=item getsockname SOCKET
X<getsockname>

=begin original

Returns the packed sockaddr address of this end of the SOCKET connection,
in case you don't know the address because you have several different
IPs that the connection might have come in on.

=end original

SOCKET 접속의 이쪽의 pakc 된 sockaddr 주소를 반환합니다.
복수의 다른 IP 에서 접속되기위해서 주소를 알 수 없을 경우에 사용합니다.

    use Socket;
    $mysockaddr = getsockname(SOCK);
    ($port, $myaddr) = sockaddr_in($mysockaddr);
    printf "Connect to %s [%s]\n",
       scalar gethostbyaddr($myaddr, AF_INET),
       inet_ntoa($myaddr);

=item getsockopt SOCKET,LEVEL,OPTNAME
X<getsockopt>

=begin original

Queries the option named OPTNAME associated with SOCKET at a given LEVEL.
Options may exist at multiple protocol levels depending on the socket
type, but at least the uppermost socket level SOL_SOCKET (defined in the
C<Socket> module) will exist. To query options at another level the
protocol number of the appropriate protocol controlling the option
should be supplied. For example, to indicate that an option is to be
interpreted by the TCP protocol, LEVEL should be set to the protocol
number of TCP, which you can get using getprotobyname.

=end original

주어진 레벨에서 SOCKET 에 관련된 OPTNAME 이라는 이름의 옵션을 질의합니다.
옵션은 소켓의 종류에 의존한 복수의 프로토콜레벨에 존재하는 것도 있습니다만, 
적어도 최상위 소켓레벨 SOL_SOCKET ( C<Socket> 모듈에서 정의됩니다)는 
존재합니다.
다른 레벨의 옵션을 질의하기에는 그 옵션을 제어하는 적절한 프로토콜의 
프로토콜의 번호를 지정합니다.
예를 들면, 옵션이 TCP 프로토콜로 해석되어야하는 것이라고 표시하기 위해서는 
LEVEL 은 getprotobyname 에서 얻어진 TCP 프로토콜 번호를 설정합니다.

=begin original

The call returns a packed string representing the requested socket option,
or C<undef> if there is an error (the error reason will be in $!). What
exactly is in the packed string depends in the LEVEL and OPTNAME, consult
your system documentation for details. A very common case however is that
the option is an integer, in which case the result will be a packed
integer which you can decode using unpack with the C<i> (or C<I>) format.

=end original

이 호출은 요구된 소켓옵션의 pack 된 문자열 표현인지,
혹은 에러가 있는 경우는 C<undef> 를 반환합니다(에러의 이유는 $! 에 있습니다).
pack 된 문자열의 정확한 내용은 LEVEL 과 OPTNAME 에 의존하기때문에, 
자세한 내용에 대해서는 시스템 문서를 확인해주세요.
그러나 매우 일반적인 경우라는 것은 옵션이 정수인 경우에서 이 경우 
결과는 unpack 의 C<i> (혹은 C<I>) 포맷에서 디코드되는 pack 된 정수입니다.

=begin original

An example testing if Nagle's algorithm is turned on on a socket:

=end original

어떤 소켓에서 Nagle 의 알고리즘 유효인지 어떤지를 조사하는 예제입니다:

    use Socket qw(:all);

    defined(my $tcp = getprotobyname("tcp"))
	or die "Could not determine the protocol number for tcp";
    # my $tcp = IPPROTO_TCP; # Alternative
    my $packed = getsockopt($socket, $tcp, TCP_NODELAY)
	or die "Could not query TCP_NODELAY socket option: $!";
    my $nodelay = unpack("I", $packed);
    print "Nagle's algorithm is turned ", $nodelay ? "off\n" : "on\n";


=item glob EXPR
X<glob> X<wildcard> X<filename, expansion> X<expand>

=item glob

=begin original

In list context, returns a (possibly empty) list of filename expansions on
the value of EXPR such as the standard Unix shell F</bin/csh> would do. In
scalar context, glob iterates through such filename expansions, returning
undef when the list is exhausted. This is the internal function
implementing the C<< <*.c> >> operator, but you can use it directly. If
EXPR is omitted, C<$_> is used.  The C<< <*.c> >> operator is discussed in
more detail in L<perlop/"I/O Operators">.

=end original

리스트 컨텍스트에서는, EXPR 의 값을 표준 Unix 셸 F</bin/csh> 이 수행되도록
파일이름의 전개를 수행한 결과 리스트(비어있을 지도 모르지만)를 반환합니다.
스칼라컨텍스트에서는 glob 는 이런 파일이름 전개를 반복해서 
리스트가 없어지면 undef 를 반환합니다.
이것은 C<< <*.c> >> 연산자를 구성하는 내부함수입니다만, 직접 사용할 수도 있습니다.
EXPR 을 생략하면 C<$_> 이 사용됩니다.
C<< <*.c> >> 연산자에 대해서는 
L<perlop/"I/O Operators"> 에서 보다 자세희 의논하고 있습니다.

=begin original

Beginning with v5.6.0, this operator is implemented using the standard
C<File::Glob> extension.  See L<File::Glob> for details.

=end original

v5.6.0 에서 이 연산자는 표준의 C<File::Glob> 확장을 사용해서 
구성되어 있습니다.
자세한 내용은 L<File:Glob> 를 참조해주세요.

=item gmtime EXPR
X<gmtime> X<UTC> X<Greenwich>

=item gmtime

=begin original

Works just like L<localtime> but the returned values are
localized for the standard Greenwich time zone.

=end original

L<localtime> 처럼 움직이지만, 반환값은 그리니치 표준시로 
로컬라이즈됩니다.

=begin original

Note: when called in list context, $isdst, the last value
returned by gmtime is always C<0>.  There is no
Daylight Saving Time in GMT.

=end original

주의: 리스트컨텍스트에서 호출한 때, gmtime 가 반환하는 끝단의 값인 
$isdst 는 항상 C<0> 입니다.
GMT 에는 Daylight Saving Time은 없습니다.

=begin original

See L<perlport/gmtime> for portability concerns.

=end original

이식성의 문제에 대해서는 L<perlport/gmtime> 을 참조해주세요.

=item goto LABEL
X<goto> X<jump> X<jmp>

=item goto EXPR

=item goto &NAME

=begin original

The C<goto-LABEL> form finds the statement labeled with LABEL and resumes
execution there.  It may not be used to go into any construct that
requires initialization, such as a subroutine or a C<foreach> loop.  It
also can't be used to go into a construct that is optimized away,
or to get out of a block or subroutine given to C<sort>.
It can be used to go almost anywhere else within the dynamic scope,
including out of subroutines, but it's usually better to use some other
construct such as C<last> or C<die>.  The author of Perl has never felt the
need to use this form of C<goto> (in Perl, that is--C is another matter).
(The difference being that C does not offer named loops combined with
loop control.  Perl does, and this replaces most structured uses of C<goto>
in other languages.)

=end original

C<goto-LABEL> 의 형식은 LABEL 이라는 라벨이 붙은 문으로 찾아서 거기에 실행을
넘기는 것입니다. 서브루틴이나 C<foreach> 루프등 뭔가의 초기화가 필요한 구조의
안으로 넣는 것은 허락되지 않습니다. 최적화에 의해 없어져버린 구조의 안에서도
goto 할 수는 없습니다.
또, C<sort> 로 주어진 블록이나 서브루틴에서 밖으로 나갈 수도 없습니다.
이 이외는 서브루틴의 밖을 포함, 동적 영ㅕㄱ 안의 대부분의 장소로 가기 위해서는
사용할 수 있지만, 보통은 C<last> 나 C<die> 같은 별도의 구조를 사용하는 
편이 좋을 겁니다.
Perl 을 만든 사람은 이 형식의 C<goto> 를 사용할 필요를 느낀 것은 
한번도 없습니다(Perl 에서는. C 와는 다른 이야기입니다).
(차이는 C 에는 루프제어와 ë은 이름붙은 루프가 없습니다.
Perl 에는 있고, 이것이 다른 언어에서의 대부분의 구조적은 C<goto> 의 
사용법을 치환할 수 있습니다).

=begin original

The C<goto-EXPR> form expects a label name, whose scope will be resolved
dynamically.  This allows for computed C<goto>s per FORTRAN, but isn't
necessarily recommended if you're optimizing for maintainability:

=end original

C<goto-EXPR> 의 형식은 라벨이름을 예측해서, 이 영역은 동적으로 해결됩니다.
이것에 의해 FORTRAN 같은 산술 C<goto> 가 가능하게 됩니다만, 
보수성을 중시한다면 추천하지 않겠습니다.

    goto ("FOO", "BAR", "GLARCH")[$i];

=begin original

The C<goto-&NAME> form is quite different from the other forms of
C<goto>.  In fact, it isn't a goto in the normal sense at all, and
doesn't have the stigma associated with other gotos.  Instead, it
exits the current subroutine (losing any changes set by local()) and
immediately calls in its place the named subroutine using the current
value of @_.  This is used by C<AUTOLOAD> subroutines that wish to
load another subroutine and then pretend that the other subroutine had
been called in the first place (except that any modifications to C<@_>
in the current subroutine are propagated to the other subroutine.)
After the C<goto>, not even C<caller> will be able to tell that this
routine was called first.

=end original

C<goto-&NAME> 형식은 그 외의 C<goto> 의 형식과는 꽤 다른 것입니다.
실제, 이것은 보통의 감각에서의 어딘가로 가기위한 것이 아니라,
다른 goto 가 기다리는 불명영을 가지고 있지 않습니다.
현재의 서브루틴을 종료하고 (local() 에 의해 변경은 잃습니다)
바로 현재의 @_ 의 값을 사용해서 지정된 이름의 서브루틴을 호출합니다.
이것은 C<AUTOLOAD> 서루틴이 다른 서브루틴을 불러 그 별도의 서브루틴이 
맨처음에 호출되기 위해 사용됩니다(단, 현재의 서브루틴에서 C<@_> 을 
수정한 경우에는 그 별도의 서브루틴에 전달됩니다). 
C<goto> 의 뒤는 C<caller> 에서도 현재의 서브루틴이 최초로 호출된 것이라고
할 수는 없습니다.

=begin original

NAME needn't be the name of a subroutine; it can be a scalar variable
containing a code reference, or a block that evaluates to a code
reference.

=end original

NAME 은 서브루틴의 이름일 필요는 없습니다; 코드리퍼런스를 포함한 스칼라값이나
코드 리퍼런스로 평가되는 블록이라도 상관없습니다.

=item grep BLOCK LIST
X<grep>

=item grep EXPR,LIST

=begin original

This is similar in spirit to, but not the same as, grep(1) and its
relatives.  In particular, it is not limited to using regular expressions.

=end original

이것은 grep(1) 과 그 부류와 같은 것입니다만, 꼭 같다고는 할 수 없습니다.
특히 정규표현의 사용에 제한받지 않습니다.

=begin original

Evaluates the BLOCK or EXPR for each element of LIST (locally setting
C<$_> to each element) and returns the list value consisting of those
elements for which the expression evaluated to true.  In scalar
context, returns the number of times the expression was true.

=end original

LIST 의 각각의 요소 대해 BLOCK 이나 EXPR 을 평가해서 
(C<$_> 은 로컬에 각각의 요소가 설정됩니다), 
그 요소의 안, 평가한 식이 참이 된 것에서의 리스트값이 반환됩니다.
스칼라컨텍스트에서는 식이 참인 횟수를 반환합니다.
예제:

    @foo = grep(!/^#/, @bar);    # weed out comments

=begin original

or equivalently,

=end original

혹은 같은 값인 예제로써:

    @foo = grep {!/^#/} @bar;    # weed out comments

=begin original

Note that C<$_> is an alias to the list value, so it can be used to
modify the elements of the LIST.  While this is useful and supported,
it can cause bizarre results if the elements of LIST are not variables.
Similarly, grep returns aliases into the original list, much as a for
loop's index variable aliases the list elements.  That is, modifying an
element of a list returned by grep (for example, in a C<foreach>, C<map>
or another C<grep>) actually modifies the element in the original list.
This is usually something to be avoided when writing clear code.

=end original

C<$_> 은 LIST 의 값으로의 Alias 이기에, LIST 의 요소를 변경하기 위해 
사용할 수 있습니다. 
이것은 편리하게 지원되지만, LIST 의 요소가 변수가 아니면, 
이상한 결과가 됩니다. 이처럼 grep 은 원래의 리스트로의 alias 를 반환합니다.
for 루프의 인덱스 변수가 리스트 요소의 alias 인 것과 같습니다.
즉, grep 에서 반환된 리스트의 요소를 (C<foreach>, C<map>, 또는 다른 
C<grep> 에서) 수정하면 원래의 리스트의 요소가 변경됩니다.
이것은 예쁜 코드를 쓸려고 하는 것에 짐이 될 때가 많습니다.

=begin original

If C<$_> is lexical in the scope where the C<grep> appears (because it has
been declared with C<my $_>) then, in addition to being locally aliased to
the list elements, C<$_> keeps being lexical inside the block; i.e. it
can't be seen from the outside, avoiding any potential side-effects.

=end original

(C<my $_> 로 선언되는 것에 의해) C<$_> 가 C<grep> 이 나타나는 영역안에서 
렉시컬한 경우는 로컬에서는 리스트 요소로의 alias 인 것에 더해서 
C<$_> 은 블록 안에서 계속 렉시컬입니다; 즉, 바깥에서 보이지않는 
발생될지 모르는 부작용을 회피합니다.

=begin original

See also L</map> for a list composed of the results of the BLOCK or EXPR.

=end original

BLOCK 이나 EXPR 의 결과를 리스트의 형태로 하고 싶은 경우는 L</map> 을 
참조해주세요.

=item hex EXPR
X<hex> X<hexadecimal>

=item hex

=begin original

Interprets EXPR as a hex string and returns the corresponding value.
(To convert strings that might start with either C<0>, C<0x>, or C<0b>, see
L</oct>.)  If EXPR is omitted, uses C<$_>.

=end original

EXPR 을 16진수의 문자열로 해석해서, 대응하는 값을 반환합니다.
(C<0>, C<0x>, C<0b> 로 시작하는 문자열의 변환에는 L</oct> 를 참조해주세요)
EXPR 이 생략되면 C<$_> 를 사용합니다.

    print hex '0xAf'; # prints '175'
    print hex 'aF';   # same

=begin original

Hex strings may only represent integers.  Strings that would cause
integer overflow trigger a warning.  Leading whitespace is not stripped,
unlike oct(). To present something as hex, look into L</printf>,
L</sprintf>, or L</unpack>.

=end original

16진수 문자열은 정수만을 표현합니다.
정수 오버플로를 발생하는 문자열은 경고를 일으킵니다.
oct() 와는 달리 맨 앞의 공백은 삭제되지 않습니다.
뭔가를 16진수로 표현하고 싶은 경우는 L</printf>, L</sprintf>, L</unpack> 을
참조해주세요.

=item import LIST
X<import>

=begin original

There is no builtin C<import> function.  It is just an ordinary
method (subroutine) defined (or inherited) by modules that wish to export
names to another module.  The C<use> function calls the C<import> method
for the package used.  See also L</use>, L<perlmod>, and L<Exporter>.

=end original

내장의 C<import> 함수라는 것은 없습니다.
이것은 단순히 다른 모듈에 이름을 export 하고 싶은 모듈이 정의한 
(또는 상속한) 일반적인 메소드(서브루틴)입니다.
C<use> 함수는 패키지를 사용하는 때에 C<import> 메소드를 호출합니다.
L</use>, L<perlmod>, L<Exporter> 도 참조해주세요.

=item index STR,SUBSTR,POSITION
X<index> X<indexOf> X<InStr>

=item index STR,SUBSTR

=begin original

The index function searches for one string within another, but without
the wildcard-like behavior of a full regular-expression pattern match.
It returns the position of the first occurrence of SUBSTR in STR at
or after POSITION.  If POSITION is omitted, starts searching from the
beginning of the string.  POSITION before the beginning of the string
or after its end is treated as if it were the beginning or the end,
respectively.  POSITION and the return value are based at C<0> (or whatever
you've set the C<$[> variable to--but don't do that).  If the substring
is not found, C<index> returns one less than the base, ordinarily C<-1>.

=end original

index 함수는 어떤 문자열을 다른 하나의 문자열에서 검색합니다만, 
완전정규표현패턴매치의 와일드카드적인 행동은 하지않습니다.
STR 안의 POSITION 의 위치이후에서 맨처음에 SUBSTR 이 발견된 위치를 반환합니다.
POSITION 이 생략된 경우에는 STR 의 처음에서 찾기시작합니다.
POSITION 이 문자열의 맨처음보다 앞 혹은 끝단보다 뒤를 지정한 경우는
각각의 앞과 끝을 지정한 것으로 취급돕니다.
POSITION 과 반환값의 베이스는 C<0> (혹은 변수 C<$[> 에 설정된 값입니다--
그러나 이것은 사용해서는 안됩니다).
SUBSTR 이 발견된 경우에는 C<index> 는 베이스보다도 1 작은 값, 
일반적인 C<-1> 이 반환됩니다.

=item int EXPR
X<int> X<integer> X<truncate> X<trunc> X<floor>

=item int

=begin original

Returns the integer portion of EXPR.  If EXPR is omitted, uses C<$_>.
You should not use this function for rounding: one because it truncates
towards C<0>, and two because machine representations of floating point
numbers can sometimes produce counterintuitive results.  For example,
C<int(-6.725/0.025)> produces -268 rather than the correct -269; that's
because it's really more like -268.99999999999994315658 instead.  Usually,
the C<sprintf>, C<printf>, or the C<POSIX::floor> and C<POSIX::ceil>
functions will serve you better than will int().

=end original

EXPR 의 정수부를 반환합니다.
EXPR 을 생략하면 C<$_> 을 사용합니다.
이 함수를 반올림으로 사용하는 것은 아닙니다.
첫번째 이유로써  C<0> 의 방향으로의 버리기 때문이고, 두번째 이유로 
부동소수점의 기계표현은 때때로 직감에 반한 결과를 내기 때문입니다.
예를 들어, C<int(-6.725/0.025)> 는 바른 결과인 -269 가 아닌 
-268 을 반환합니다.
이것은 실제로는 -268.99999999999994315658 같은 값이 되기 때문입니다.
보통 C<sprintf>, C<printf>, C<POSIX::floor>, C<POSIX::ceil> 쪽이 
int() 보다 편리합니다.

=item ioctl FILEHANDLE,FUNCTION,SCALAR
X<ioctl>

=begin original

Implements the ioctl(2) function.  You'll probably first have to say

=end original

ioctl(2) 함수를 구성합니다.
바른 함수의 정의를 얻기 위해 아마도 처음에

    require "sys/ioctl.ph";	# probably in $Config{archlib}/sys/ioctl.ph

=begin original

to get the correct function definitions.  If F<sys/ioctl.ph> doesn't
exist or doesn't have the correct definitions you'll have to roll your
own, based on your C header files such as F<< <sys/ioctl.h> >>.
(There is a Perl script called B<h2ph> that comes with the Perl kit that
may help you in this, but it's nontrivial.)  SCALAR will be read and/or
written depending on the FUNCTION--a pointer to the string value of SCALAR
will be passed as the third argument of the actual C<ioctl> call.  (If SCALAR
has no string value but does have a numeric value, that value will be
passed rather than a pointer to the string value.  To guarantee this to be
true, add a C<0> to the scalar before using it.)  The C<pack> and C<unpack>
functions may be needed to manipulate the values of structures used by
C<ioctl>.

=end original

이라고 해두지 않으면 안됩니다.
F<sys/ioctl.ph> 가 없거나 잘못된 정의를 하고 있는 경우에는 
F<< <sys/ioctl.ph> >> 같은 C 의 헤더파일을 기본으로  자신이 
만들지 않으면 안됩니다.
(Perl 의 배포킷에 들어있는 B<h2ph> 라는 Perl 스크립트가 이것을 도와주지만, 
이것은 중요합니다)
FUNCTION 에 대해 SCALAR 가 읽고쓰여집니다.
SCALAR 의 문자열값으로 포인터가 실제 C<ioctl> 호출의 3번째 인수로써 넘겨집니다.
이 것을 보증하기 위해서는 사용하기 전에 SCALAR에 C<0> 을 더해줍니다.)
C<ioctl> 으로 사용된 구조체 값을 조작하기에는 C<pack> 함수와 C<unpack> 함수가
필요로 합니다.

=begin original

The return value of C<ioctl> (and C<fcntl>) is as follows:

=end original

C<ioctl> (과 C<fcntl>) 의 반환값은 아래처럼 됩니다:

=begin original

	if OS returns:		then Perl returns:
	    -1	  		  undefined value
	     0	 		string "0 but true"
	anything else		    that number

=end original

	OS 가 반환하는 값:		  Perl 이 반환하는 값:
	    -1	  		     미정의값
	     0	 		「0 이지만 참」의 문자열
	  그외		  그 값 그것

=begin original

Thus Perl returns true on success and false on failure, yet you can
still easily determine the actual value returned by the operating
system:

=end original

즉 Perl 은 성공시에 "참", 실패할때는 "거짓"을 반환하게 되고,
OS 가 실제로 반환한 값도 아래처럼 간단히 알 수 있습니다.

    $retval = ioctl(...) || -1;
    printf "System returned %d\n", $retval;

=begin original

The special string C<"0 but true"> is exempt from B<-w> complaints
about improper numeric conversions.

=end original

특별한 문자열 C<"0 이지만 참"> 은, 부적절한 수치변환에 관한 
B<-w> 경고를 회피합니다.

=item join EXPR,LIST
X<join>

=begin original

Joins the separate strings of LIST into a single string with fields
separated by the value of EXPR, and returns that new string.  Example:

=end original

LIST 의 개별 문자열을 EXPR 의 값으로 구분하고 
하나의 문자열에 연결해서 그 문자열을 반환합니다.
예제:

    $rec = join(':', $login,$passwd,$uid,$gid,$gcos,$home,$shell);

=begin original

Beware that unlike C<split>, C<join> doesn't take a pattern as its
first argument.  Compare L</split>.

=end original

C<split> 와는 달리 C<join> 은 맨처음의 인수에 패턴은 얻을 수 없는 것에 
주의하세요.
L</split> 와 비교해주세요.

=item keys HASH
X<keys> X<key>

=begin original

Returns a list consisting of all the keys of the named hash.
(In scalar context, returns the number of keys.)

=end original

지정한 해쉬의 모든 key 로부터 리스트를 반환합니다.
(스칼라 컨텍스트에서는 key 의 수를 반환합니다)

=begin original

The keys are returned in an apparently random order.  The actual
random order is subject to change in future versions of perl, but it
is guaranteed to be the same order as either the C<values> or C<each>
function produces (given that the hash has not been modified).  Since
Perl 5.8.1 the ordering is different even between different runs of
Perl for security reasons (see L<perlsec/"Algorithmic Complexity
Attacks">).

=end original

키는 겉으로는 랜덤한 순서로 반환됩니다.
실제 랜덤한 순서는 perl 의 장래의 버젼에서는 바뀔지도 모릅니다만, 
C<values> 나 C<each> 함수가 같은(변경되지 않은) 해쉬에 대해서 
생성하는 것과 같은 순서인 것은 보증됩니다.
Perl 5.8.1. 이후에서는 보안상의 이유에 의해서, 실행될 때마다 
순서가 바뀝니다.
(L<perlsec/"Algorithmic Complexity Attacks"> 를 참조해주세요)

=begin original

As a side effect, calling keys() resets the HASH's internal iterator
(see L</each>).  In particular, calling keys() in void context resets
the iterator with no other overhead.

=end original

부작용으로 HASH 의 반복자를 초기화합니다(L</each>를 참조해주세요).
특히 무효 컨텍스트에서 keys() 를 호출하면 오버헤드 없이도 반복자를 
초기화합니다.

=begin original

Here is yet another way to print your environment:

=end original

환경변수를 표시하는 다른 예제입니다:

    @keys = keys %ENV;
    @values = values %ENV;
    while (@keys) {
	print pop(@keys), '=', pop(@values), "\n";
    }

=begin original

or how about sorted by key:

=end original

key 로 정렬해도 좋습니다:

    foreach $key (sort(keys %ENV)) {
	print $key, '=', $ENV{$key}, "\n";
    }

=begin original

The returned values are copies of the original keys in the hash, so
modifying them will not affect the original hash.  Compare L</values>.

=end original

반환된 값은 해쉬에 있는 원래의 키의 복사이기에 이것을 변경해도 
원래의 해쉬에는 형향을 끼치지 않습니다.
L</values> 와 비교해주세요.

=begin original

To sort a hash by value, you'll need to use a C<sort> function.
Here's a descending numeric sort of a hash by its values:

=end original

해쉬를 값으로 소트하기 위해서는 C<sort> 함수를 사용할 필요가 있습니다.
아래에서는 해쉬의 값을 수치의 내림차순으로 정렬합니다.

    foreach $key (sort { $hash{$b} <=> $hash{$a} } keys %hash) {
	printf "%4d %s\n", $hash{$key}, $key;
    }

=begin original

As an lvalue C<keys> allows you to increase the number of hash buckets
allocated for the given hash.  This can gain you a measure of efficiency if
you know the hash is going to get big.  (This is similar to pre-extending
an array by assigning a larger number to $#array.)  If you say

=end original

좌변값으로써는 C<keys> 를 사용하는 것으 주어진 해쉬에 할당된 
해쉬표의 크기를 늘릴 수 있습니다.
이것에 의해, 해쉬가 커지는 때의 효율의 측정이 가능합니다.
아래처럼 하면:

    keys %hash = 200;

=begin original

then C<%hash> will have at least 200 buckets allocated for it--256 of them,
in fact, since it rounds up to the next power of two.  These
buckets will be retained even if you do C<%hash = ()>, use C<undef
%hash> if you want to free the storage while C<%hash> is still in scope.
You can't shrink the number of buckets allocated for the hash using
C<keys> in this way (but you needn't worry about doing this by accident,
as trying has no effect).

=end original

C<%hash> 는 적어도 200 의 크기의 표가 할당됩니다 -- 
실제로는 2 승에 반올림되기에 256이 할당됩니다.
이 표는 예를들어 C<%hash = ()> 라고 해도 남기때문에 
만약 C<%hash> 가 영역에 있는 사이에 이 영역을 개방하고 싶은 경우는 
C<undef %hash> 를 사용합니다.
이 방법으로 C<keys> 를 사용하는 것으로 표의 크기를 작게할 수는 없습니다.
(잘못해서 그런 것을 해도 아무것도 일어나지 않기에, 신경쓸 것은 없습니다)

=begin original

See also C<each>, C<values> and C<sort>.

=end original

C<each>, C<values>, C<sort> 도 참조해주세요.

=item kill SIGNAL, LIST
X<kill> X<signal>

=begin original

Sends a signal to a list of processes.  Returns the number of
processes successfully signaled (which is not necessarily the
same as the number actually killed).

=end original

프로세스의 리스트에 시그널을 보냅니다. 시그널 송신에 성공한 프로세스의 
수를 반환합니다 (실제로 kill 에 성공한 프로세스와 같다고는 할 수 없습니다).

    $cnt = kill 1, $child1, $child2;
    kill 9, @goners;

=begin original

If SIGNAL is zero, no signal is sent to the process, but the kill(2)
system call will check whether it's possible to send a signal to it (that
means, to be brief, that the process is owned by the same user, or we are
the super-user).  This is a useful way to check that a child process is
alive (even if only as a zombie) and hasn't changed its UID.  See
L<perlport> for notes on the portability of this construct.

=end original

(TBT)
SIGNAL がゼロの場合、プロセスにシグナルは送られませんが、
but the kill(2)
system call will check whether it's possible to send a signal to it (that
means, to be brief, that the process is owned by the same user, or we are
the super-user)
これは子プロセスが(ゾンビとしてだけでも)生きていて、 UID が
変わっていないことを調べる時に有用です。
この構成の移植性に関する注意については L<perlport> を参照して下さい。

=begin original

Unlike in the shell, if SIGNAL is negative, it kills
process groups instead of processes.  (On System V, a negative I<PROCESS>
number will also kill process groups, but that's not portable.)  That
means you usually want to use positive not negative signals.  You may also
use a signal name in quotes.

=end original

셸과는 달리, 신호에 음의 수를 주면,
프로세스가 아닌 프로세스 그룹에 대해서 kill 을 수행합니다.
(System V 에서는 프로세스 번호로 음의 수를 주어도 
프로세스 그룹의 kill 을 수행하지만 이식성이 없습니다).
즉, 일반적으로는 음의 신호를 사용하지 않고, 정의 신호를 사용하게 됩니다.
신호이름을 인용해서 사용할 수도 있습니다.

=begin original

See L<perlipc/"Signals"> for more details.

=end original

자세한 내용은 L<perlipc/"Signals">을 참조해주세요.

=item last LABEL
X<last> X<break>

=item last

=begin original

The C<last> command is like the C<break> statement in C (as used in
loops); it immediately exits the loop in question.  If the LABEL is
omitted, the command refers to the innermost enclosing loop.  The
C<continue> block, if any, is not executed:

=end original

C<last> 커맨드는 (루프안에서 사용한) C 의 C<break> 문과 
같은 것으로, LABEL 에서 지정한 루프를 즉시 빠져나옵니다.
LABEL 이 생략되면, 제일 안쪽의 루프가 대상이 됩니다.
C<continue> 블록이 있어도 실행되지 않습니다:

    LINE: while (<STDIN>) {
	last LINE if /^$/;	# exit when done with header
	#...
    }

=begin original

C<last> cannot be used to exit a block which returns a value such as
C<eval {}>, C<sub {}> or C<do {}>, and should not be used to exit
a grep() or map() operation.

=end original

C<last> 는 C<eval {}>, C<sub {}>, C<do {}> 같은 값을 
반환하는 블록을 종료하는 것에는 사용할 수 없고, 
grep() 이나 map() 조작을 종료하는 것에 사용해야하는 것은 아닙니다.

=begin original

Note that a block by itself is semantically identical to a loop
that executes once.  Thus C<last> can be used to effect an early
exit out of such a block.

=end original

블록은 그 자체문법적으로는 한번만 실행되는 루프와 같은 것에 
주의해주세요. 따라서 C<last> 에서 그런 블록을 도중에 
빠져나올 수 있습니다.

=begin original

See also L</continue> for an illustration of how C<last>, C<next>, and
C<redo> work.

=end original

C<last>, C<next>, C<redo> 가 어떻게 움직이는 가에 대해서는 
L</continue> 를 참조해주세요.

=item lc EXPR
X<lc> X<lowercase>

=item lc

=begin original

Returns a lowercased version of EXPR.  This is the internal function
implementing the C<\L> escape in double-quoted strings.  Respects
current LC_CTYPE locale if C<use locale> in force.  See L<perllocale>
and L<perlunicode> for more details about locale and Unicode support.

=end original

EXPR 을 소문자로 변환한 것을 반환합니다.
이것은 쌍따옴표 문자열에 의한 
C<\L> 이스케이프를 구성ㅏ는 내부함수입니다.
C<use locale> 이 유효한 경우는 현재의 LC_CTYPE 로케일을 참조합니다.
로케일과 Unicode 의 지원에 관한 보다 자세한 내용에 대해서는
L<perllocale> 과 L<perlunicode> 를 참조해주세요.

=begin original

If EXPR is omitted, uses C<$_>.

=end original

EXPR 이 생략되면, C<$_> 를 사용합니다.

=item lcfirst EXPR
X<lcfirst> X<lowercase>

=item lcfirst

=begin original

Returns the value of EXPR with the first character lowercased.  This
is the internal function implementing the C<\l> escape in
double-quoted strings.  Respects current LC_CTYPE locale if C<use
locale> in force.  See L<perllocale> and L<perlunicode> for more
details about locale and Unicode support.

=end original

최초의 문자만을 소문자로한 EXPR 을 반환합니다.
이것은 쌍따옴표 문자열에 의한, C<\l> 이스케이프를 
구성하는 내부함수입니다.
C<use locale> 이 유효한 경우는 현재의 LC_CTYPE 로케일을 참조합니다.
로케일과 Unicode 의 지원에 관한 보다 자세한 내용에 대해서는 
L<perllocale> 과 L<perlunicode> 도 참조해주세요.

=begin original

If EXPR is omitted, uses C<$_>.

=end original

EXPR 이 생략되면, C<$_> 를 사용합니다.

=item length EXPR
X<length> X<size>

=item length

=begin original

Returns the length in I<characters> of the value of EXPR.  If EXPR is
omitted, returns length of C<$_>.  Note that this cannot be used on
an entire array or hash to find out how many elements these have.
For that, use C<scalar @array> and C<scalar keys %hash> respectively.

=end original

EXPR 의 값 I<문자> 의 길이를 반환합니다.
EXPR 이 생략된 때에는, C<$_> 의 길이를 반환합니다.
이것은 배열이나 해쉬전체애 대해서 어느정도의 요소를 포함하고 있는 가를 
조사하기 위해 사용할 수는 없습니다.
그런 용도로는 각각 C<scalar @array> 와 C<scalar keys %hash> 를 
이용해주세요.

=begin original

Note the I<characters>: if the EXPR is in Unicode, you will get the
number of characters, not the number of bytes.  To get the length
of the internal string in bytes, use C<bytes::length(EXPR)>, see
L<bytes>.  Note that the internal encoding is variable, and the number
of bytes usually meaningless.  To get the number of bytes that the
string would have when encoded as UTF-8, use
C<length(Encoding::encode_utf8(EXPR))>.

=end original

I<문자> 에 관한 주의:
EXPR 이 Unicode 인 경우, 바이트수가 아닌 문자수를 반환합니다.
내부문자열에 바이트수가 필요한 경우는 L<bytes> 를 참조해서 
C<do { use bytes; length(EXPR) }> 을 사용해주세요.
내부 인코딩은 여러가지이기에, 바이트수는 보통은 무의미합니다.
UTF-8 으로 인코드되어 이쓴 경우는 문자열의 바이트수를 얻고 싶은 경우는 
C<length(Encoding::encode_utf8(EXPR))> 를 사용해주세요.

=item link OLDFILE,NEWFILE
X<link>

=begin original

Creates a new filename linked to the old filename.  Returns true for
success, false otherwise.

=end original

OLDFILE 에 링크되어, 새로운 파일 NEWFILE 을 만듭니다.
성공시에 true 를, 실패시에는 false 를 반환합니다.

=item listen SOCKET,QUEUESIZE
X<listen>

=begin original

Does the same thing that the listen system call does.  Returns true if
it succeeded, false otherwise.  See the example in
L<perlipc/"Sockets: Client/Server Communication">.

=end original

listen 시스템 호출과 같은 일을 합니다. 성공시에는 참을 반환하고, 
실패시에는 거짓을 반환합니다.
L<perlipc/"Sockets: Client/Server Communication"> 의 예제를 참조해주세요.

=item local EXPR
X<local>

=begin original

You really probably want to be using C<my> instead, because C<local> isn't
what most people think of as "local".  See
L<perlsub/"Private Variables via my()"> for details.

=end original

당신이 정말로 원하는 것은 C<my> 일 겁니다.
C<local> 은 대부분의 사람들이 "로컬" 이라고 생각하는 것과 다르기 때문입니다.
자세한 내용은 L<perlsub/"Private Variables via my()"> 를 참조하세요.

=begin original

A local modifies the listed variables to be local to the enclosing
block, file, or eval.  If more than one value is listed, the list must
be placed in parentheses.  See L<perlsub/"Temporary Values via local()">
for details, including issues with tied arrays and hashes.

=end original

"local" 은 리스트업 된 변수를 감싸진 블록, 파일, eval 의 안에서, 로컬한 것으로
합니다. 복수의 값을 지정하는 경우는 리스트는 괄호로 감싸지 않으면 안됩니다.
tie 한 배열과 해쉬에 관한 사항을 포함한 상세한 내용에 대해서는 
L<perlsub/"Temporary Values via local()"> 를 참조하세요.

=item localtime EXPR
X<localtime> X<ctime>

=item localtime

=begin original

Converts a time as returned by the time function to a 9-element list
with the time analyzed for the local time zone.  Typically used as
follows:

=end original

time 함수가 반환하는 시각을 로컬한 타임존에서 측정한 시각으로써 
9가지 요소의 배열로 변환합니다.
일반적으로는 아래처럼 사용합니다.

    #  0    1    2     3     4    5     6     7     8
    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
                                                localtime(time);

=begin original

All list elements are numeric, and come straight out of the C `struct
tm'.  C<$sec>, C<$min>, and C<$hour> are the seconds, minutes, and hours
of the specified time.

=end original

모든 리스트 요소는 수치로, C 의 `struct tm` 구조체에서 직접 가지고 옵니다.
C<$sec>, C<$min>, C<$hour> 은 지정된 시각의 초, 분, 시간입니다.

=begin original

C<$mday> is the day of the month, and C<$mon> is the month itself, in
the range C<0..11> with 0 indicating January and 11 indicating December.
This makes it easy to get a month name from a list:

=end original

C<$mday> 은 그 달의 몇번째인가, C<$mon> 은 그 달의 값입니다.
달의 값은 C<0..11> 로, 0가 1월, 11이 12월 입니다.
이것에 의해, 리스트에서 달이 이름을 가지는 것이 간단하게 됩니다.

    my @abbr = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );
    print "$abbr[$mon] $mday";
    # $mon=9, $mday=18 gives "Oct 18"

=begin original

C<$year> is the number of years since 1900, not just the last two digits
of the year.  That is, C<$year> is C<123> in year 2023.  The proper way
to get a complete 4-digit year is simply:

=end original

C<$year> 는 1900 년에서의 년수이고, 단순히 서력의 아래 두자리를 표현하는 것이
아닙니다. 즉 $year 가 C<123> 이라면 2023 년입니다.
완전한 4자리의 서력을 얻기에는 그냥 아래처럼 해주세요:

    $year += 1900;

=begin original

Otherwise you create non-Y2K-compliant programs--and you wouldn't want
to do that, would you?

=end original

그렇지 않으면, Y2K 문제를 가진 프로그램을 가지는 것이 됩니다 --
그것은 원하는 것이 아니죠?

=begin original

To get the last two digits of the year (e.g., '01' in 2001) do:

=end original

서력의 아래 2자리(2001년에서는 '01') 을 원하는 경우는 아래처럼 해주세요:

    $year = sprintf("%02d", $year % 100);

=begin original

C<$wday> is the day of the week, with 0 indicating Sunday and 3 indicating
Wednesday.  C<$yday> is the day of the year, in the range C<0..364>
(or C<0..365> in leap years.)

=end original

C<$wday> 는 요일로, 0이 월요일, 3이 목요일입니다.
C<$yday> 는 그 년도의 몇번째인가로, C<0..364> 의 값을 얻습니다.
(윤년은 C<0..365> 입니다)

=begin original

C<$isdst> is true if the specified time occurs during Daylight Saving
Time, false otherwise.

=end original

C<$isdst> 는 지정된 시각이 여름시간일 경우는 참, 그렇지 않으면 거짓입니다.

=begin original

If EXPR is omitted, C<localtime()> uses the current time (C<localtime(time)>).

=end original

EXPR 이 생략되면, C<localtime()> 은 현재 시각을 사용합니다.
(C<localtime(time())>。

=begin original

In scalar context, C<localtime()> returns the ctime(3) value:

=end original

스칼라컨테스트에서는 C<localtime()> 은 ctime(3) 의 값을 반환합니다:

    $now_string = localtime;  # e.g., "Thu Oct 13 04:54:34 1994"

=begin original

This scalar value is B<not> locale dependent but is a Perl builtin. For GMT
instead of local time use the L</gmtime> builtin. See also the
C<Time::Local> module (to convert the second, minutes, hours, ... back to
the integer value returned by time()), and the L<POSIX> module's strftime(3)
and mktime(3) functions.

=end original

스칼라값은 로케일 의존이 B<아닙니다>, Perl 의 내장의 값입니다.
로케일 시각이 아닌 GMT 를 원하는 경우는 L/gttime> 내장함수를 사용해주세요.
또 (초, 분, 시 의 형태에서 time() 이 반환하는 값인 
1970 년 1월 1일의 한밤중에서의 초수로 변환하는) C<Time::Local> 모듈 및 
POSIX 모듈로 제공ㅚㄴ strftime(3) 과 mktime(3) 함수도 참조하세요.

=begin original

To get somewhat similar but locale dependent date strings, set up your
locale environment variables appropriately (please see L<perllocale>) and
try for example:

=end original

이와 비슷하게 로케일 의존의 날짜 문자열을 원하는 경우는 
로케일 환경변수를 적절하게 설정해서(L<perllocale> 을 사용해주세요),
아래의 예제를 시험해주세요.

    use POSIX qw(strftime);
    $now_string = strftime "%a %b %e %H:%M:%S %Y", localtime;
    # or for GMT formatted appropriately for your locale:
    $now_string = strftime "%a %b %e %H:%M:%S %Y", gmtime;

=begin original

Note that the C<%a> and C<%b>, the short forms of the day of the week
and the month of the year, may not necessarily be three characters wide.

=end original

요일과 달의 짧은 표현인 C<%a> 와 C<%b> 는 3문자로는 한정되지 않느 것에 주의.

=begin original

See L<perlport/localtime> for portability concerns.

=end original

이식성에 대해서는 L<perlport/localtime> 을 참조해주세요.

=begin original

The L<Time::gmtime> and L<Time::localtime> modules provides a convenient,
by-name access mechanism to the gmtime() and localtime() functions,
respectively.

=end original

L<Time::gmtime> 모듈과 L<Time::localtime> 모듈은 각각 
gmtime() 함수와 localtime() 함수에 이름으로 접근하는 기구를 제공하는 
편리한 모듈입니다.

=begin original

For a comprehensive date and time representation look at the
L<DateTime> module on CPAN.

=end original

포괄적인 날짜와 시각의 표현에 대해서는 CPAN 의 L<DateTime> 모듈을 
참조하세요.

=item lock THING
X<lock>

=begin original

This function places an advisory lock on a shared variable, or referenced
object contained in I<THING> until the lock goes out of scope.

=end original

이 함수는 I<THING> 이 포함하는 공유변수 또는 리퍼런스된 오브젝트에 
영역에서 나오기까지의 advisory lock 을 겁니다.

=begin original

lock() is a "weak keyword" : this means that if you've defined a function
by this name (before any calls to it), that function will be called
instead. (However, if you've said C<use threads>, lock() is always a
keyword.) See L<threads>.

=end original

lock() 는 "약한 키워드" 입니다: 만약 유저가 (호출하기 전에 )
이 이름으로 함수를 정의하면 정의된 함수가 호출됩니다.
(단, C<use threads> 를 하면, lock() 는 항상 키워드입니다).
L<threads> 를 참조하세요.

=item log EXPR
X<log> X<logarithm> X<e> X<ln> X<base>

=item log

=begin original

Returns the natural logarithm (base I<e>) of EXPR.  If EXPR is omitted,
returns log of C<$_>.  To get the log of another base, use basic algebra:
The base-N log of a number is equal to the natural log of that number
divided by the natural log of N.  For example:

=end original

EXPR 의 (I<e> 를 기반으로) 자연대수를 반환합니다.
EXPR 이 생략되면, C<$_> 의 대수를 반환합니다.
기반과 다른 대수를 구하기 위해서는 기초대수를 이용해주세요:
어떤 수 N 을 기반한 대수는 그 수의 자연대수를 N 의 자연대수로 나눈 것입니다.
예:

    sub log10 {
	my $n = shift;
	return log($n)/log(10);
    }

=begin original

See also L</exp> for the inverse operation.

=end original

역조작에 대해서는 L</expr> 을 참조하세요.

=item lstat EXPR
X<lstat>

=item lstat

=begin original

Does the same thing as the C<stat> function (including setting the
special C<_> filehandle) but stats a symbolic link instead of the file
the symbolic link points to.  If symbolic links are unimplemented on
your system, a normal C<stat> is done.  For much more detailed
information, please see the documentation for C<stat>.

=end original

(특별한 파일핸들인 C<_> 의 설정을 포함해)
C<stat> 함수와 같은 일을 합니다만, 심볼릭 링크가 
지정되어 있는 파일이 아닌, 심볼릭 링크자체의 stat 을 얻습니다.
심볼릭 링크가 시스템에 구성되어 있지 않다면, 일반적인 C<stat> 이 수행됩니다.
보다 더 자세한 정보에 대해서는 L<stat> 의 문서를 참조해주세요.

=begin original

If EXPR is omitted, stats C<$_>.

=end original

EXPR 이 생략되면, C<$_> 의 stat 을 얻습니다.

=item m//

=begin original

The match operator.  See L<perlop>.

=end original

매치연산자입니다.
L<perlop> 를 참조해주세요.

=item map BLOCK LIST
X<map>

=item map EXPR,LIST

=begin original

Evaluates the BLOCK or EXPR for each element of LIST (locally setting
C<$_> to each element) and returns the list value composed of the
results of each such evaluation.  In scalar context, returns the
total number of elements so generated.  Evaluates BLOCK or EXPR in
list context, so each element of LIST may produce zero, one, or
more elements in the returned value.

=end original

LIST 의 각각의 요소에 대해서, BLOCK 이 EXPR 을 평가해서 
(C<$_> 는 로컬에 각각의 요소가 설정됩니다), 
각각의 평가결과로부텅 리스트의 값이 반환됩니다.
스칼라 컨텍스트에서는 생성된 요소의 수를 반환합니다.
BLOCK 이나 EXPR 을 리스트컨텍스트에서 평가하기때문에, LIST 의 
각각의 요소에 따라 만들어지는 반환값인 리스트의 요소수는 
0개의 경우도 있으면 복수의 경우도 있습니다.

    @chars = map(chr, @nums);

=begin original

translates a list of numbers to the corresponding characters.  And

=end original

이것은 수의 리스트를 대응하는 문자로 변환합니다.
또:

    %hash = map { get_a_key_for($_) => $_ } @array;

=begin original

is just a funny way to write

=end original

이것은 아래의 것을 조금 바꾼 것입니다.

    %hash = ();
    foreach (@array) {
	$hash{get_a_key_for($_)} = $_;
    }

=begin original

Note that C<$_> is an alias to the list value, so it can be used to
modify the elements of the LIST.  While this is useful and supported,
it can cause bizarre results if the elements of LIST are not variables.
Using a regular C<foreach> loop for this purpose would be clearer in
most cases.  See also L</grep> for an array composed of those items of
the original list for which the BLOCK or EXPR evaluates to true.

=end original

C<$_> 은 LIST 의 값의 Alias 이기때문에 LIST 의 요소를 변경하기 위해서 
사용할 수 있습니다.
이것은 편리하고 서포트되지만, LIST 의 요소가 변수 아니면 이상한 결과가 됩니다.
이 목적으로는 일반적인 C<foreach> 루프를 사용하는 것으로 대부분의 경우는 
보다 명확하게 됩니다.
BLOCK 이나 EXPR 이 참이 되는 원래의 리스트의 요소로부터 배열에 대해서는 
L</grep> 도 참조해주세요.

=begin original

If C<$_> is lexical in the scope where the C<map> appears (because it has
been declared with C<my $_>), then, in addition to being locally aliased to
the list elements, C<$_> keeps being lexical inside the block; that is, it
can't be seen from the outside, avoiding any potential side-effects.

=end original

(C<my $_> 로써 선언된 것에 의해)  C<$_> 이 C<map> 이 나타난 영역안에서 
렉시컬한 경우는 로컬에서는 리스트 요소로의 alias 인 것에 더해서 
C<$_> 은 블록 안에서 렉시컬하게 됩니다; 즉, 외부로부터는 보이지않고,
발생할지도 모르는 부작용을 회피합니다.

=begin original

C<{> starts both hash references and blocks, so C<map { ...> could be either
the start of map BLOCK LIST or map EXPR, LIST. Because perl doesn't look
ahead for the closing C<}> it has to take a guess at which its dealing with
based what it finds just after the C<{>. Usually it gets it right, but if it
doesn't it won't realize something is wrong until it gets to the C<}> and
encounters the missing (or unexpected) comma. The syntax error will be
reported close to the C<}> but you'll need to change something near the C<{>
such as using a unary C<+> to give perl some help:

=end original

C<{> 은 해쉬리퍼런스와 블록의 양쪽의 개시문자이기에 
C<map { ...> 은 map BLOCK LISST 의 경우와 map EXPR, LIST 의 경우가 있습니다.
perl 은 종료문자의 C<}> 를 먼저 읽지않기 때문에, C<{> 의 직후의 문자를 보고 
어느쪽으로 취급할 것인가를 추측합니다.
일반적으로 이 추측은 정확하지만, 만약 잘못된 경우는 C<}> 까지 읽고 
콤마가 부족한(또는 많거나) 것을 알기까지 뭔가 이상한 것을 눈치채지 못합니다.
C<}> 의 가까이에서 문법 에러가 발생하지만, perl 을 지원하기 위해서는 단항의 
C<+> 를 사용하는 것처럼, C<{> 가까이의 뭔가를 바꿀 필요가 있습니다.

    %hash = map {  "\L$_", 1  } @array  # perl guesses EXPR.  wrong
    %hash = map { +"\L$_", 1  } @array  # perl guesses BLOCK. right
    %hash = map { ("\L$_", 1) } @array  # this also works
    %hash = map {  lc($_), 1  } @array  # as does this.
    %hash = map +( lc($_), 1 ), @array  # this is EXPR and works!

    %hash = map  ( lc($_), 1 ), @array  # evaluates to (1, @array)

=begin original

or to force an anon hash constructor use C<+{>:

=end original

또는 C<+{> 를 사용해서 이름없는 해쉬 생성자를 강제합니:

   @hashes = map +{ lc($_), 1 }, @array # EXPR, so needs , at end

=begin original

and you get list of anonymous hashes each with only 1 entry.

=end original

이렇게 하면 각각 1요소만의 이름해쉬의 리스트를 얻을 수 있습니다.

=item mkdir FILENAME,MASK
X<mkdir> X<md> X<directory, create>

=item mkdir FILENAME

=item mkdir

=begin original

Creates the directory specified by FILENAME, with permissions
specified by MASK (as modified by C<umask>).  If it succeeds it
returns true, otherwise it returns false and sets C<$!> (errno).
If omitted, MASK defaults to 0777. If omitted, FILENAME defaults
to C<$_>.

=end original

FILENAME 으로 지정한 디렉토리를 MASK 로 지정한 허가모드(를 
C<umask> 로 수정한 것) 으로 작성합니다.
성공시에는 참을 반환하, 실패시에는 거짓을 반환해서 C$!> (errno) 를 설정합니다.
MASK 를 생략하면 0777로 간주합니다.
FILENAME 을 생략하면, C<$_> 를 사용합니다.

=begin original

In general, it is better to create directories with permissive MASK,
and let the user modify that with their C<umask>, than it is to supply
a restrictive MASK and give the user no way to be more permissive.
The exceptions to this rule are when the file or directory should be
kept private (mail files, for instance).  The perlfunc(1) entry on
C<umask> discusses the choice of MASK in more detail.

=end original

일반적으로는 제한된 MASK 를 사용해서 유저가 보 실용적인 방법을 
주지않는 것보다 실용적인 MASK 로 디렉토리를 만들고, 유저가 자신의 C<umask>로
수정하게하는 것이 좋습니다.
예외는 (예를들어 메일 파일같은) 프라이베이트로 가져야하는 파일이나 
디렉토리를 쓰는 경입니다.
perlfunc(1) 의 C<umask> 로 MASK 의 선택에 관해서 상세하게 논의하고 있습니다.

=begin original

Note that according to the POSIX 1003.1-1996 the FILENAME may have any
number of trailing slashes.  Some operating and filesystems do not get
this right, so Perl automatically removes all trailing slashes to keep
everyone happy.

=end original

POSIX 1003.1-1996 에 의하면 FILENAME 에는 끝단에 임의의 수의 슬래쉬를 
붙일 수 있습니다.
이렇게는 움직이지 않는 OS 나 파일시스템도 있기때문에 Perl 은 모두가 
행복해지도록 자동으로 끝단의 슬래쉬를 제거합니다.

=begin original

In order to recursively create a directory structure look at
the C<mkpath> function of the L<File::Path> module.

=end original

디렉토리 구조를 재귀적으로 작성하기에는 L<File::Path> 모듈의 
C<makepath> 함수를 참조해주세요.

=item msgctl ID,CMD,ARG
X<msgctl>

=begin original

Calls the System V IPC function msgctl(2).  You'll probably have to say

=end original

System V IPC 함수 msgctl 을 호출합니다. 바른 정수ㅇ의를 얻기 위해서는 
우선:

    use IPC::SysV;

=begin original

first to get the correct constant definitions.  If CMD is C<IPC_STAT>,
then ARG must be a variable that will hold the returned C<msqid_ds>
structure.  Returns like C<ioctl>: the undefined value for error,
C<"0 but true"> for zero, or the actual return value otherwise.  See also
L<perlipc/"SysV IPC">, C<IPC::SysV>, and C<IPC::Semaphore> documentation.

=end original

이라고 선언할 필요가 있겠죠?
CMD 가 C<IPC_STAT> 이면, ARG 는 반환되는 C<msqid_ds> 구조체를 
넣을 수 있는 변수가 아니면 안됩니다.
ㅊ<ioctl> 처럼 에러 시에는 미정의 값, 0 일 때는 C<"0 이지만 참"> ,
그 이외라면, 그 값을 그대 반환합니다.
L<perlipc/"SysV IPC">, C<IPC::SysV>, C<IPC::Semaphore> 도 참조하세요.

=item msgget KEY,FLAGS
X<msgget>

=begin original

Calls the System V IPC function msgget(2).  Returns the message queue
id, or the undefined value if there is an error.  See also
L<perlipc/"SysV IPC"> and C<IPC::SysV> and C<IPC::Msg> documentation.

=end original

System V IPC 함수 msgget 을 호출합니다.
메세지 큐의 ID 나 에러시에는 미정의 값을 반환합니다.
L<perlipc/"SysV IPC">, C<IPC::SysV>, C<IPC::Msg> 도 참조하세요.

=item msgrcv ID,VAR,SIZE,TYPE,FLAGS
X<msgrcv>

=begin original

Calls the System V IPC function msgrcv to receive a message from
message queue ID into variable VAR with a maximum message size of
SIZE.  Note that when a message is received, the message type as a
native long integer will be the first thing in VAR, followed by the
actual message.  This packing may be opened with C<unpack("l! a*")>.
Taints the variable.  Returns true if successful, or false if there is
an error.  See also L<perlipc/"SysV IPC">, C<IPC::SysV>, and
C<IPC::SysV::Msg> documentation.

=end original

System V IPC 関数 msgrcv 를 호출하고, 메세지 큐 ID 에서 
변수 VAR 에 최대 메세지 길이 SIZE 의 메세지를 수신합니다.
메세지가 수신된 때, 네이티브한 long 변수의 메세지타입이 
VAR 의 맨 앞이 되고, 실제의 메세지가 계속됩니다.
이 패킹은 C<unpack("l! a*"> 로 전개할 수 있습니다.
변수는 오염됩니다.
성공시에는 참을 반환고, 에러시에는 거짓을 반환합니다.
L<perlipc/"SysV IPC">, C<IPC::SysV>, C<IPC::SysV::Msg> 도 참조해주세요.

=item msgsnd ID,MSG,FLAGS
X<msgsnd>

=begin original

Calls the System V IPC function msgsnd to send the message MSG to the
message queue ID.  MSG must begin with the native long integer message
type, and be followed by the length of the actual message, and finally
the message itself.  This kind of packing can be achieved with
C<pack("l! a*", $type, $message)>.  Returns true if successful,
or false if there is an error.  See also C<IPC::SysV>
and C<IPC::SysV::Msg> documentation.

=end original

System V IPC 함수 msgsnd 를 호출하고, 메세지 큐 ID 에 메세지 MSG 를 송신합니다.
MSG 의 앞은 네이티브한 long 정수의 메세지타입이 아니면 안되고 ,
메세지의 길이, 메세지본체로 이어집니다.
이것은 C<pack("l! a*", $type, $message)> 로 생성할 수 있습니다.
성공시에는 참을, 에러일 때는 거ㅅ을 반환합니다.
C<IPC::SysV> と C<IPC::SysV::Msg> 도 참조해주세요.

=item my EXPR
X<my>

=item my TYPE EXPR

=item my EXPR : ATTRS

=item my TYPE EXPR : ATTRS

=begin original

A C<my> declares the listed variables to be local (lexically) to the
enclosing block, file, or C<eval>.  If more than one value is listed,
the list must be placed in parentheses.

=end original

C<my> 는 리스트업된 변수를 감싸는 블럭, 파일, C<eval> 의 안에서 
로컬한 (렉시컬한) 것으로 합니다.
복수의 값을 나열하는 경우에는 괄호로 감쌀 필요가 있습니다.

=begin original

The exact semantics and interface of TYPE and ATTRS are still
evolving.  TYPE is currently bound to the use of C<fields> pragma,
and attributes are handled using the C<attributes> pragma, or starting
from Perl 5.8.0 also via the C<Attribute::Handlers> module.  See
L<perlsub/"Private Variables via my()"> for details, and L<fields>,
L<attributes>, and L<Attribute::Handlers>.

=end original

TYPE 과 ATTRS 의 정확한 문법과 인터페이스는 지금도 진화하고 있습니다.
현재, TYPE 은 C<fields> 프라그마의 사ㅇ과 결부되어 있고, 
속성은 C<attributes> 프라그마나 Perl 5.8.0 부터는 
C<Attribute::Handlers> 모듈과 결부되어 있습니다.
자세한 내용은 L<perlsub/"Private Variables via my()">, L<fields>,
L<attributes>, L<Attribute::Handlers> 를 참조해주세요.

=item next LABEL
X<next> X<continue>

=item next

=begin original

The C<next> command is like the C<continue> statement in C; it starts
the next iteration of the loop:

=end original

C<next> 커맨드는 C 에서의 C<continue> 문같은 것으로 
루프의 다음 반복을 시작합니다:

    LINE: while (<STDIN>) {
	next LINE if /^#/;	# discard comments
	#...
    }

=begin original

Note that if there were a C<continue> block on the above, it would get
executed even on discarded lines.  If the LABEL is omitted, the command
refers to the innermost enclosing loop.

=end original

C<continue> 블록이 존재하면, 설령 버러진 줄에 있어도 그것이 실행됩니다.
LABEL 이 생략되면 이 커맨드는 가장 안쪽의 루프를 참조합니다.

=begin original

C<next> cannot be used to exit a block which returns a value such as
C<eval {}>, C<sub {}> or C<do {}>, and should not be used to exit
a grep() or map() operation.

=end original

C<next>는 C<eval {}>, C<sub {}>, C<do {}> 같은 값을 반환하는 
블록에서 빠져나오는 것에는 사용할 수 없습니다.
또, grep() 이나 map() 조작에서 빠져나오는 것에 사용해야하는 것이 아닙니다.

=begin original

Note that a block by itself is semantically identical to a loop
that executes once.  Thus C<next> will exit such a block early.

=end original

블록 자신은 한번만 실행되는 루프와 문법적으로 같은 것에 주의해주세요.
따라서, C<next> 는 그런 블록에서 빨리 빠져나오는 것에 사용할 수 있습니다.

=begin original

See also L</continue> for an illustration of how C<last>, C<next>, and
C<redo> work.

=end original

C<last>, C<next>, C<redo> 가 어떻게 움직이는 가에 대해서는 
L</continue> 도 참조해주세요.

=item no Module VERSION LIST
X<no>

=item no Module VERSION

=item no Module LIST

=item no Module

=item no VERSION

=begin original

See the C<use> function, of which C<no> is the opposite.

=end original

L<use> 함수를 참조해주세요. C<no> 는 그 반대를 수행하는 것입니다.

=item oct EXPR
X<oct> X<octal> X<hex> X<hexadecimal> X<binary> X<bin>

=item oct

=begin original

Interprets EXPR as an octal string and returns the corresponding
value.  (If EXPR happens to start off with C<0x>, interprets it as a
hex string.  If EXPR starts off with C<0b>, it is interpreted as a
binary string.  Leading whitespace is ignored in all three cases.)
The following will handle decimal, binary, octal, and hex in the standard
Perl or C notation:

=end original

EXPR 을 8진수 문자열로 해석해서, 대응하는 값을 반환합니다.
(EXPR 이 C<0x> 로 시작할 때는 16진수 문자열로 해석합니다.
EXPR 이 C<0b> 로 시작할 때는 2진수 문자열로 해석합니다.
어떤 경우에도 맨앞의 공백은 무시됩니다.)
아래의 예제는 표준적인 Perl 이 C 기법에서의 
10 진수, 2진수, 8진수, 16진수를 다룹니다:

    $val = oct($val) if $val =~ /^0/;

=begin original

If EXPR is omitted, uses C<$_>.   To go the other way (produce a number
in octal), use sprintf() or printf():

=end original

EXPR 을 생략하면, C<$_> 을 사용합니다.
(8 진수를 다루는) 그 밖의 방법에 대해서는 sprintf() 또는 printf() 가 있습니다.

    $perms = (stat("filename"))[2] & 07777;
    $oct_perms = sprintf "%lo", $perms;

=begin original

The oct() function is commonly used when a string such as C<644> needs
to be converted into a file mode, for example. (Although perl will
automatically convert strings into numbers as needed, this automatic
conversion assumes base 10.)

=end original

oct() 함수는 예를들어, C<644> 같은 문자열을 파일모드로 변환할 때에 
자주 사용합니다.
(Perl 은 필요에 따라서 자동적으로 문자열을 수치로 변환합니다만, 
이 자동변환은 10진수를 가정하고 있습니다)

=item open FILEHANDLE,EXPR
X<open> X<pipe> X<file, open> X<fopen>

=item open FILEHANDLE,MODE,EXPR

=item open FILEHANDLE,MODE,EXPR,LIST

=item open FILEHANDLE,MODE,REFERENCE

=item open FILEHANDLE

=begin original

Opens the file whose filename is given by EXPR, and associates it with
FILEHANDLE.

=end original

EXPR 에서 주어진 파일이름의 파일을 열고 FILEHANDLE 과 겹부합니다.

=begin original

(The following is a comprehensive reference to open(): for a gentler
introduction you may consider L<perlopentut>.)

=end original

(아래는 총합적인 open() 의 리퍼런스입니다: 보다 친절한 설명에 대해서는 
L<perlopentut> 를 참조해주세요.)

=begin original

If FILEHANDLE is an undefined scalar variable (or array or hash element)
the variable is assigned a reference to a new anonymous filehandle,
otherwise if FILEHANDLE is an expression, its value is used as the name of
the real filehandle wanted.  (This is considered a symbolic reference, so
C<use strict 'refs'> should I<not> be in effect.)

=end original

FILEHANDLE 이 미정의 스칼라변수(또는 배열 해쉬의 요소)인 경우, 그 변수는 
새로운 이름없는 파일핸들로의 리퍼런스가 대입되고, 
그렇지 않으면, 만약 FILEHANDLE 이 식이라면, 그 값ㅡㄹ 구하는 실제의 
파일핸들의 이름으로 사용합니다.
(이것은 심볼릭 리퍼런스로 다루기 때문에, C<use strict 'refs'> 의 영향을 
I<받지 않습니다>.)

=begin original

If EXPR is omitted, the scalar variable of the same name as the
FILEHANDLE contains the filename.  (Note that lexical variables--those
declared with C<my>--will not work for this purpose; so if you're
using C<my>, specify EXPR in your call to open.)

=end original

EXPR 이 생략된 경우, FILEHANDLE 과 같은 이름의 스칼라 변수로 파일이름이 
들어갑니다.
(렉시컬 변수 -- C<my> 로 선언된 것 -- 는 이 용도로는 사용할 수 없다는 것에 
 주의해주세요; 따라서, C<my> 를 사용하는 경우는, open 을 호출할 때에 
EXPR 을 지정해주세요)

=begin original

If three or more arguments are specified then the mode of opening and
the file name are separate. If MODE is C<< '<' >> or nothing, the file
is opened for input.  If MODE is C<< '>' >>, the file is truncated and
opened for output, being created if necessary.  If MODE is C<<< '>>' >>>,
the file is opened for appending, again being created if necessary.

=end original

3 이상의 인수가 지정된 경우, 열 때의 모드와 파일이름은 분리됩니다.
MODE 가 C<< '<' >> 가 빈 경우, 파일은 입력용으로 열립니다.
MODE 가 C<< '>' >> 인 경우, 파일은 출력용으로 열려서 필요하면 작성됩니다.
MODE 가 C<<< '>>' >>> 인 경우, 파일은 추가용으로 열리고, 역시 필요하다면 
작성됩니다.

=begin original

You can put a C<'+'> in front of the C<< '>' >> or C<< '<' >> to
indicate that you want both read and write access to the file; thus
C<< '+<' >> is almost always preferred for read/write updates--the C<<
'+>' >> mode would clobber the file first.  You can't usually use
either read-write mode for updating textfiles, since they have
variable length records.  See the B<-i> switch in L<perlrun> for a
better approach.  The file is created with permissions of C<0666>
modified by the process' C<umask> value.

=end original

파일에 읽기 접근과 쓰기 접근 양쪽을 하고 싶다고 나타내기 위해서 
C<< '>' >> 나 C<< '<' >> 의 앞에  C<'+'> 를 붙일 수 있습니다.
따라서, C<< '+<' >> 대부분 항상 읽기 쓰기 변경을 위해 사용됩니다 --
C<< '+>' >> 모드는 우선 파일을 덮어기 합니다.
보통은 이 읽기 모드들을 텍스트파일의 갱신을 위해서는 사용할 수 없습니다;
왜냐면 가변 길이의 레코드에서 구성되어 있기 때문입니다.
보다 좋은 방법에 대해서는 L<perlrun> 의 B<-i> 옵션을 참조해주세요.
파일은 C<0666> 을 접근의 C<umask> 의 값으로 수정한 퍼미션으로 작성됩니다.

=begin original

These various prefixes correspond to the fopen(3) modes of C<'r'>,
C<'r+'>, C<'w'>, C<'w+'>, C<'a'>, and C<'a+'>.

=end original

이 다양한 전치사들은 fopen(3) 의 C<'r'>, C<'r+'>,
C<'w'>, C<'w+'>, C<'a'>, C<'a+'> 의 모드에 대응합니다.

=begin original

In the 2-arguments (and 1-argument) form of the call the mode and
filename should be concatenated (in this order), possibly separated by
spaces.  It is possible to omit the mode in these forms if the mode is
C<< '<' >>.

=end original

2 인수(와 1 인수) 의 형식으로는 모드와 파일이름은(이 순서로) 
결합됩니다(공백에 따라서 분할될지도 모릅니다).
이 형식으로 모드가 C<< '<' >> 의 경우는 모드를 생략할 수 있습니다.

=begin original

If the filename begins with C<'|'>, the filename is interpreted as a
command to which output is to be piped, and if the filename ends with a
C<'|'>, the filename is interpreted as a command which pipes output to
us.  See L<perlipc/"Using open() for IPC">
for more examples of this.  (You are not allowed to C<open> to a command
that pipes both in I<and> out, but see L<IPC::Open2>, L<IPC::Open3>,
and L<perlipc/"Bidirectional Communication with Another Process">
for alternatives.)

=end original

파일이름의 맨 앞에 C<'|'> 을 붙이면, 그 파일이름을 커맨드로 해석해서 
파일핸들로의 출력이 파이프를 통해서 그 커맨드로 입력됩니다.
거꾸로 파일이름의 끝에 C<'|'> 를 붙인 경우에는 마찬가지로 파일이름을 
커맨드로 해석해서 그 커맨드의 출력이 파이프를 통해서, 파일핸들에서 
입력으로써 읽어들일 수 있게 됩니다.
이것에 관한 예제에 대해서는 L<perlipc/"Using open() for IPC"> 를 참조해주세요.
(C<open> 을 입출력용으로 파이프하는 것을 불가능하지만 대신에
L<IPC::Open2>, L<IPC::Open3>,
L<perlipc/"Bidirectional Communication with Another Process">
를 참조해주세요.)

=begin original

For three or more arguments if MODE is C<'|-'>, the filename is
interpreted as a command to which output is to be piped, and if MODE
is C<'-|'>, the filename is interpreted as a command which pipes
output to us.  In the 2-arguments (and 1-argument) form one should
replace dash (C<'-'>) with the command.
See L<perlipc/"Using open() for IPC"> for more examples of this.
(You are not allowed to C<open> to a command that pipes both in I<and>
out, but see L<IPC::Open2>, L<IPC::Open3>, and
L<perlipc/"Bidirectional Communication"> for alternatives.)

=end original

3 인수 이상의 형식에서
MODE 가 C<'|-'> 인 경우, 파일이름이 출력이 파이프된 커맨드로 해석되어 MODE 가
C<'-|'> 인 경우, 파일이름은 출력이 이쪽에 파이프되는 커맨드로 해석됩니다.
2인수(와 1인수) 의 형식에서는 하이픈(C<'-'>) 을 커맨드 대신에 사용할 수 있습니다.
이것에 관한 보다 자세한 예제에 대해서는 L<perlipc/"Using open() for IPC"> 를 
참조해주세요.
(C<open> 을 입출력I<용> 으로 파이프할 수 없지만, 
대체안으로는 L<IPC::Open2>, L<IPC::Open3>,
L<perlipc/"Bidirectional Communication"> 를 참조해주세요.)

=begin original

In the three-or-more argument form of pipe opens, if LIST is specified
(extra arguments after the command name) then LIST becomes arguments
to the command invoked if the platform supports it.  The meaning of
C<open> with more than three arguments for non-pipe modes is not yet
specified. Experimental "layers" may give extra LIST arguments
meaning.

=end original

파이프에서의 3개 이상의 인수의 형식에서는 LIST( 커맨드 이름의 뒤의 추가 인수)
가 지정되면, 플랫폼이 대응하고 있으면,  LIST 는 기동되는 커맨드로의 인수가 
됩니다.
파이프 모드가 아닌 C<open> 에서의 3개 이상의 인수의 의미는 아직 미정의입니다.
실험적인 "계층"은 추가의 LIST 인수의 의미를 부여합니다.

=begin original

In the 2-arguments (and 1-argument) form opening C<'-'> opens STDIN
and opening C<< '>-' >> opens STDOUT.

=end original

2 인수(와 1인수) 에서 C<'-'> 를 open 하면 STDIN 이 오픈되어,
C<< '>-' >> 를 open 하면 STDOUT 이 오픈됩니다.

=begin original
You may use the three-argument form of open to specify IO "layers"
(sometimes also referred to as "disciplines") to be applied to the handle
that affect how the input and output are processed (see L<open> and
L<PerlIO> for more details). For example

=end original

open 의 3인수형식에서는 어떻게 입출력이 처리되는 가에 영향을 주는 
IO "계층" ("disciplines" 라고도 불립니다)를 지정할 수 있습니다
(자세한 내용에 대해서는 L<open> 과 L<PerlIO> 를 참조해주세요).
예를들어:

  open(FH, "<:encoding(UTF-8)", "file")

=begin original

will open the UTF-8 encoded file containing Unicode characters,
see L<perluniintro>. Note that if layers are specified in the
three-arg form then default layers stored in ${^OPEN} (see L<perlvar>;
usually set by the B<open> pragma or the switch B<-CioD>) are ignored.

=end original

는 Unicode 문자를 포함하는 UTF-8 인코드된 파일을 엽니다;
L<perlruniintro> 를 참조해주세요.
3 인수형식에서 계층을 지정하면 ${^OPEN} (L<perlvar> 를 참조해주세요;
일반적으로는 C<open> 프라그마가 B<-CioD> 옵션에서 설정됩니다)
에 보존된 기본 계층은 무시되는 것에 주의해주세요.

=begin original

Open returns nonzero upon success, the undefined value otherwise.  If
the C<open> involved a pipe, the return value happens to be the pid of
the subprocess.

=end original

open 은 성공시에는 0 이외를 반환하고, 실패시에는 미정의값을 반환합니다.
파이프에 관한 C<open> 시에는 반환값은 서브프로세스의 pid 가 됩니다.

=begin original

If you're running Perl on a system that distinguishes between text
files and binary files, then you should check out L</binmode> for tips
for dealing with this.  The key distinction between systems that need
C<binmode> and those that don't is their text file formats.  Systems
like Unix, Mac OS, and Plan 9, which delimit lines with a single
character, and which encode that character in C as C<"\n">, do not
need C<binmode>.  The rest need it.

=end original

텍스트파일과 바이너리 파일을 구별하는 시스템에서 Perl 을 실행하는 경우, 
이것을 다루기 위해 L</binmode> 를 체크해야합니다.
동작시키는 시스템에서는 C<binmode> 가 필수인가 불필요한가를 구별하는 
키는, 텍스트의 파일 형식입니다.
Unix, Mac OS, Plan 9 같은 행의 경계를 1문자로 표현하고, 그것이 C에서 
C<"\n"> 에서 인코드되는 경우, C<binmode> 는 필요없습니다.
그 이외에서는 필요합니다.

=begin original

When opening a file, it's usually a bad idea to continue normal execution
if the request failed, so C<open> is frequently used in connection with
C<die>.  Even if C<die> won't do what you want (say, in a CGI script,
where you want to make a nicely formatted error message (but there are
modules that can help with that problem)) you should always check
the return value from opening a file.  The infrequent exception is when
working with an unopened filehandle is actually what you want to do.

=end original

파일을 결때, 여는 것에 실패한 때에 일반적인 처리를 계속하는 것은 
보통은 나쁘게 생각하기에, C<open> 은 대부분 C<die> 로 묶어서 사용됩니다.
바라는 것이 C<die> 가 아닌 경우(예를 들어, CGI 스크립트처럼 
예븐 포맷의 에러 메시지를 만들고 싶은 경우 
(단, 이 문제를 도와줄 모듈이 있습니다))에서도,
파일을 연 때의 반환값을 항상 체크해야합니다.
쓸때없는 예외는 열지 않은 파일 핸들을 사용하는 것이 
정말로 하고 싶은 것일 경우입니다.

=begin original

As a special case the 3-arg form with a read/write mode and the third
argument being C<undef>:

=end original

특별한 경우로 3인수의 형식에서 읽고 쓰기 모드로 3번째의 인수가 
C<undef> 인 경우:

    open(TMP, "+>", undef) or die ...

=begin original

opens a filehandle to an anonymous temporary file.  Also using "+<"
works for symmetry, but you really should consider writing something
to the temporary file first.  You will need to seek() to do the
reading.

=end original

이름없는 일시 파일로 파일핸들을 엽니다.
또 "+<" 도 대칭성을 위해 동작하지만, 일시 파일에는 우선 
뭔가를 쓰고 싶을 겁니다.
읽기를 수행하기 위해서는 seek() 가 필요합니다.

=begin original

Since v5.8.0, perl has built using PerlIO by default.  Unless you've
changed this (i.e. Configure -Uuseperlio), you can open file handles to
"in memory" files held in Perl scalars via:

=end original

v.5.8.0 부터 perl 은 기본값으로 PerlIO 를 사용해서 빌드되어 있습니다.
이것(Configure -Uuseperlio) 를 변경하지 않는 한, 
아래처럼 해서, Perl 스칼라에 보존된 "in memory" 파일을 
파일핸들을 열 수 있습니다:

    open($fh, '>', \$variable) || ..

=begin original

Though if you try to re-open C<STDOUT> or C<STDERR> as an "in memory"
file, you have to close it first:

=end original

그러나, 만약 C<STDOUT> 이나 C<STDERR> 을 "in memory" 파일로써 
다시 열고 싶은 경우는 앞서 그것을 닫을 필요가 있습니다:

    close STDOUT;
    open STDOUT, '>', \$variable or die "Can't open STDOUT: $!";

=begin original

Examples:

=end original

예제:

    $ARTICLE = 100;
    open ARTICLE or die "Can't find article $ARTICLE: $!\n";
    while (<ARTICLE>) {...

    open(LOG, '>>/usr/spool/news/twitlog');	# (log is reserved)
    # if the open fails, output is discarded

    open(DBASE, '+<', 'dbase.mine')		# open for update
	or die "Can't open 'dbase.mine' for update: $!";

    open(DBASE, '+<dbase.mine')			# ditto
	or die "Can't open 'dbase.mine' for update: $!";

    open(ARTICLE, '-|', "caesar <$article")     # decrypt article
	or die "Can't start caesar: $!";

    open(ARTICLE, "caesar <$article |")		# ditto
	or die "Can't start caesar: $!";

    open(EXTRACT, "|sort >Tmp$$")		# $$ is our process id
	or die "Can't start sort: $!";

    # in memory files
    open(MEMORY,'>', \$var)
	or die "Can't open memory file: $!";
    print MEMORY "foo!\n";			# output will end up in $var

    # process argument list of files along with any includes

    foreach $file (@ARGV) {
	process($file, 'fh00');
    }

    sub process {
	my($filename, $input) = @_;
	$input++;		# this is a string increment
	unless (open($input, $filename)) {
	    print STDERR "Can't open $filename: $!\n";
	    return;
	}

	local $_;
	while (<$input>) {		# note use of indirection
	    if (/^#include "(.*)"/) {
		process($1, $input);
		next;
	    }
	    #...		# whatever
	}
    }

=begin original

See L<perliol> for detailed info on PerlIO.

=end original

PerlIO 에 관한 자세한 정보에 대해서는 L<perliol> 을 참조해주세요.

=begin original

You may also, in the Bourne shell tradition, specify an EXPR beginning
with C<< '>&' >>, in which case the rest of the string is interpreted
as the name of a filehandle (or file descriptor, if numeric) to be
duped (as L<dup(2)>) and opened.  You may use C<&> after C<< > >>,
C<<< >> >>>, C<< < >>, C<< +> >>, C<<< +>> >>>, and C<< +< >>.
The mode you specify should match the mode of the original filehandle.
(Duping a filehandle does not take into account any existing contents
of IO buffers.) If you use the 3-arg form then you can pass either a
number, the name of a filehandle or the normal "reference to a glob".

=end original

Bourne 셸의 관례에 따라서, EXPR 의 앞에 C<< '>&' >> 를 붙이면 
EXPR 의 남은 문자열을 파일핸들이름(숫자이면 파일 기술자) 로 해석하고 
그것을 (L<dup(2)> 에 의해) 복제해서 오픈합니다.
C<&> 는 C<< > >>, C<<< >> >>>, C<< < >>, C<< +> >>, C<<< +>> >>>,
C<< +< >> 같은 모드지정에 붙일 수 있습니다.
지정하는 모드 지정은 원래 파일핸들의 모드와 맞지 않으면 안됩니다.
(파일핸들의 복제는 이미 존재하는 IO 버퍼의 내용에 포함되지 않습니다.)
3 인수형식을 사용하는 경우느 수치를 넘기거나 파일핸들의 이름을 건내거나 
일반적인 "글로브로의 리퍼런스"를 넘깁니다.

=begin original

Here is a script that saves, redirects, and restores C<STDOUT> and
C<STDERR> using various methods:

=end original

C<STDOUT> 과 C<STDERR> 을 보존하고, 리다이렉트해서 원래로 돌아가는 
스크립트를 표시합니다:

    #!/usr/bin/perl
    open my $oldout, ">&STDOUT"     or die "Can't dup STDOUT: $!";
    open OLDERR,     ">&", \*STDERR or die "Can't dup STDERR: $!";

    open STDOUT, '>', "foo.out" or die "Can't redirect STDOUT: $!";
    open STDERR, ">&STDOUT"     or die "Can't dup STDOUT: $!";

    select STDERR; $| = 1;	# make unbuffered
    select STDOUT; $| = 1;	# make unbuffered

    print STDOUT "stdout 1\n";	# this works for
    print STDERR "stderr 1\n"; 	# subprocesses too

    open STDOUT, ">&", $oldout or die "Can't dup \$oldout: $!";
    open STDERR, ">&OLDERR"    or die "Can't dup OLDERR: $!";

    print STDOUT "stdout 2\n";
    print STDERR "stderr 2\n";

=begin original

If you specify C<< '<&=X' >>, where C<X> is a file descriptor number
or a filehandle, then Perl will do an equivalent of C's C<fdopen> of
that file descriptor (and not call L<dup(2)>); this is more
parsimonious of file descriptors.  For example:

=end original

C<X> 를 파일기술자의 번호화 파일핸들로써, 
C<< '<&=X' >> 로 지정하면, Perl 은 그 파일기술자에 대해서 
C 의 C<fdopen> 과 같은 것을 수행합니다(그리고 L<dup(2)> 는 호출하지 않습니다);
이것은 파일 기술자를 축약합니다.
예제:

    # open for input, reusing the fileno of $fd
    open(FILEHANDLE, "<&=$fd")

=begin original

or

=end original

또는

    open(FILEHANDLE, "<&=", $fd)

=begin original

or

=end original

또는

    # open for append, using the fileno of OLDFH
    open(FH, ">>&=", OLDFH)

=begin original

or

=end original

또는

    open(FH, ">>&=OLDFH")

=begin original

Being parsimonious on filehandles is also useful (besides being
parsimonious) for example when something is dependent on file
descriptors, like for example locking using flock().  If you do just
C<< open(A, '>>&B') >>, the filehandle A will not have the same file
descriptor as B, and therefore flock(A) will not flock(B), and vice
versa.  But with C<< open(A, '>>&=B') >> the filehandles will share
the same file descriptor.

=end original

파일핸들을 검약하는 것은 뭔가가 파일기술자에 의존하고 있는 경우,
예를들면 flock() 을 사용한 파일록인 경우에 유용합니다(그러나 검약할 수 있습니다)
C<< open(A, '>>&B') >> 라고 하면, 파일핸들 A 와 B 처럼 
파일기술자가 되지 않기에, flock(A) 와 flock(B) 는 별개가 됩니다.
그러나 C<< open(A, '>>&=B') >> 에서는 파일핸들은 같은 파일기술자를 
공유합니다.

=begin original

Note that if you are using Perls older than 5.8.0, Perl will be using
the standard C libraries' fdopen() to implement the "=" functionality.
On many UNIX systems fdopen() fails when file descriptors exceed a
certain value, typically 255.  For Perls 5.8.0 and later, PerlIO is
most often the default.

=end original

5.8.0 보다 앞의 Perl 을 사용하는 경우 "=" 기능의 구성은 
표준 C 라이브러리의 fdopen() 을 사용합니다.
많은 UNIX 시스템에서는 fdopen() 은 파일 기술자가 있는 값
(전형적으로는 255)를 넘는 경우에 실패하는 것을 알수 있습니다.
5.8.0 이후의 Perl 에서는 대부분의 경우 PerlIO 가 기본값입니다.

=begin original

You can see whether Perl has been compiled with PerlIO or not by
running C<perl -V> and looking for C<useperlio=> line.  If C<useperlio>
is C<define>, you have PerlIO, otherwise you don't.

=end original

Perl 이 PerlIO 에 붙은 채로 컴파일되는 지 어떤지를 확인하기 위해서는 
C<perl -V> 로 C<useperlio=> 의 줄을 봅니다.
C<useperlio> 가 C<define> 이라면 PerlIO 를 사용하고 있습니다.
그렇지 않으면 사용하고 있지 않습니다.

=begin original

If you open a pipe on the command C<'-'>, i.e., either C<'|-'> or C<'-|'>
with 2-arguments (or 1-argument) form of open(), then
there is an implicit fork done, and the return value of open is the pid
of the child within the parent process, and C<0> within the child
process.  (Use C<defined($pid)> to determine whether the open was successful.)
The filehandle behaves normally for the parent, but i/o to that
filehandle is piped from/to the STDOUT/STDIN of the child process.
In the child process the filehandle isn't opened--i/o happens from/to
the new STDOUT or STDIN.  Typically this is used like the normal
piped open when you want to exercise more control over just how the
pipe command gets executed, such as when you are running setuid, and
don't want to have to scan shell commands for metacharacters.
The following triples are more or less equivalent:

=end original

2 인수(또는 1인수)의 형태의 open() 에서 
C<'-|'> 나 C<'|-'> 같이 C<'-'> 라는 커맨드에 파이프를 오픈하면,
fork 가 수행되어 open 의 반환값으로 부모 프로세스에게는 자식프로세스의 
pid가 자식 프로세스에게는 C<0> 이 반환됩니다.
(open 이 성공했는지 어떤지는 C<defined($pid)> 처럼 해서 조사할 수 있습니다)
부모 프로세스에서는 이 파일핸들은 보통처럼 동작하지만, 수행되는 입출력은 
자식프로세스의 STDIN/STDOUT 에 파이프됩니다.
자식프로세스 측에서는 그 파일핸들은 오픈되지 않고, 입출력은 새로운 
STDOUT 이나 STDIN 에 대해 수행됩니다.
이것은 setuid 에서 실행하고 셸 커맨드의 메타 문자를 검색시키고 싶지 않은 
경우에 파이프커맨드의 기동의 방법을 제어하고 싶을 때, 보통의 파이프의 open처럼
사용합니다.
아래의 조합은 대개 같은 것입니다:

    open(FOO, "|tr '[a-z]' '[A-Z]'");
    open(FOO, '|-', "tr '[a-z]' '[A-Z]'");
    open(FOO, '|-') || exec 'tr', '[a-z]', '[A-Z]';
    open(FOO, '|-', "tr", '[a-z]', '[A-Z]');

    open(FOO, "cat -n '$file'|");
    open(FOO, '-|', "cat -n '$file'");
    open(FOO, '-|') || exec 'cat', '-n', $file;
    open(FOO, '-|', "cat", '-n', $file);

=begin original

The last example in each block shows the pipe as "list form", which is
not yet supported on all platforms.  A good rule of thumb is that if
your platform has true C<fork()> (in other words, if your platform is
UNIX) you can use the list form.

=end original

각각의 블록의 마지막의 예제에서는 파이프를 "리스트형식"으로 하고 있지만,
이것은 아직 모든 플랫폼에서 대응하고 있는 것은 아닙니다.
좋은 경험면에서는 만약 실행하고 있는 플랫폼에서 참의 C<fork()> 가 
있다면(바꿔 말하면 플랫폼이 UNIX 라면) 리스트 형식을 사용할 수 있습니다.

=begin original

See L<perlipc/"Safe Pipe Opens"> for more examples of this.

=end original

이에 관한 더 많은 예제에 대해서는 L<perlipc/"Safe Pipe Opens"> 를 참조하세요.

=begin original

Beginning with v5.6.0, Perl will attempt to flush all files opened for
output before any operation that may do a fork, but this may not be
supported on some platforms (see L<perlport>).  To be safe, you may need
to set C<$|> ($AUTOFLUSH in English) or call the C<autoflush()> method
of C<IO::Handle> on any open handles.

=end original

v5.6.0 에서 Perl 은 쓰기용으로 열려있는 모든 파일에 대해 
fork 를 수행하기 전에 플러쉬하려고 하지만, 이것을 지원하지 않는 
플랫폼도 있습니다(L<perlport> 를 참조해주세요).
안전을 위해 C<$|> (English 모듈에서는 $AUTOFLUSH) 를 정의하지만,
모든 열려있는 핸들에 대해서 C<IO::Handle> 의 C<autoflush()> 메소드를 
호출하도록 해주세요.

=begin original

On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptor as determined by the value
of $^F.  See L<perlvar/$^F>.

=end original

파일에 대해 close-on-exec 플래그를 지원하고 있는 시스템에서는 
플래그는 $^F 의 값으로 결정되고, 새롭게 오픈된 파일 기술자에 대해서 설정됩니다.
L<perlvar/$^F> 를 참조해주세요.

=begin original

Closing any piped filehandle causes the parent process to wait for the
child to finish, and returns the status value in C<$?> and
C<${^CHILD_ERROR_NATIVE}>.

=end original

파이프의 파일핸들을  close 하는 것으로 
부모 프로세스는 자식 프로세스의 종료를 기다리고, C<$?> 과
C<${^CHILD_ERROR_NATIVE}> 의 상태값을 반환합니다.

=begin original

The filename passed to 2-argument (or 1-argument) form of open() will
have leading and trailing whitespace deleted, and the normal
redirection characters honored.  This property, known as "magic open",
can often be used to good effect.  A user could specify a filename of
F<"rsh cat file |">, or you could change certain filenames as needed:

=end original

2인수(와 1인수) 형식의 open() 에 넘겨진 파일이름은 
처음과 끝의 공백을 빼고,
보통의 리다이렉트 문자열을 받습니다.
이 기능은 "magic open" 으 알려져 있지만, 보통 좋은 효과를 가지게 합니다.
유저는 F<"rsh cat file |"> 같은 파일이름을 지정할 수 있고,
특정 파일이름을 필요에 따라 변경할 수 있습니다.

    $filename =~ s/(.*\.gz)\s*$/gzip -dc < $1|/;
    open(FH, $filename) or die "Can't open $filename: $!";

=begin original

Use 3-argument form to open a file with arbitrary weird characters in it,

=end original

묘한 문자가 포함되어 있는 듯한 파일이름을 오픈할 때 3인수의 형식을 사용합니다.

    open(FOO, '<', $file);

=begin original

otherwise it's necessary to protect any leading and trailing whitespace:

=end original

혹은 다음처럼 해서 맨처음과 끝의 공백을 보호합니다:

    $file =~ s#^(\s)#./$1#;
    open(FOO, "< $file\0");

=begin original

(this may not work on some bizarre filesystems).  One should
conscientiously choose between the I<magic> and 3-arguments form
of open():

=end original

(이것은 기묘한 파일시스템에서는 동작하지 않을지도 모릅니다).
open() 의 I<magic> 과 3 인수형식을 성실하게 선택해야 합니다.

    open IN, $ARGV[0];

=begin original

will allow the user to specify an argument of the form C<"rsh cat file |">,
but will not work on a filename which happens to have a trailing space, while

=end original

라고 하면 유저는 C<"rsh cat file |"> 같은 형식의 인수를 지정할 수 있지만, 
끝단의 스페이스가 붙어버린 파일이름에서는 동작하지 않습니다. 한편:

    open IN, '<', $ARGV[0];

=begin original

will have exactly the opposite restrictions.

=end original

는 전혀 반대의 제한이 있습니다.

=begin original

If you want a "real" C C<open> (see L<open(2)> on your system), then you
should use the C<sysopen> function, which involves no such magic (but
may use subtly different filemodes than Perl open(), which is mapped
to C fopen()).  This is
another way to protect your filenames from interpretation.  For example:

=end original

만약 "진짜" C 언어의 C<open> (시스템의 L<open(2) 를 참조해주세요)가 
필요하다면 이런 부작용이 없는 C<sysopen> 함수를 사용해야 합니다
(단, C 의 fopen() 에 할부된 Perl 의 open() 과는 
확연히 다른 파일모드를 가집니다).
이것은 파일이름을 해석에서 지키는 다른 하나의 방법입니다.
예를들면:

    use IO::Handle;
    sysopen(HANDLE, $path, O_RDWR|O_CREAT|O_EXCL)
	or die "sysopen $path: $!";
    $oldfh = select(HANDLE); $| = 1; select($oldfh);
    print HANDLE "stuff $$\n";
    seek(HANDLE, 0, 0);
    print "File contains: ", <HANDLE>;

=begin original

Using the constructor from the C<IO::Handle> package (or one of its
subclasses, such as C<IO::File> or C<IO::Socket>), you can generate anonymous
filehandles that have the scope of whatever variables hold references to
them, and automatically close whenever and however you leave that scope:

=end original

C<IO::Handle> 패키지(또는 C<IO::File> 이나 C<IO::Socket> 같은 
서브패키지)의 생성자를 사용하는 것으로 
이것으로의 리퍼런스를 가지고 있는 변수의 영역을 가지고 
영역에서 떠나면 자동적으로 닫힌 이름없는 파일핸들를 작성할 수 있습니다:

    use IO::File;
    #...
    sub read_myfile_munged {
	my $ALL = shift;
	my $handle = new IO::File;
	open($handle, "myfile") or die "myfile: $!";
	$first = <$handle>
	    or return ();     # Automatically closed here.
	mung $first or die "mung failed";	# Or here.
	return $first, <$handle> if $ALL;	# Or here.
	$first;					# Or here.
    }

=begin original

See L</seek> for some details about mixing reading and writing.

=end original

읽기 쓰기를 섞는 경우의 자세한 내용에 대해서는 L</seek> 를 참조하세요.

=item opendir DIRHANDLE,EXPR
X<opendir>

=begin original

Opens a directory named EXPR for processing by C<readdir>, C<telldir>,
C<seekdir>, C<rewinddir>, and C<closedir>.  Returns true if successful.
DIRHANDLE may be an expression whose value can be used as an indirect
dirhandle, usually the real dirhandle name.  If DIRHANDLE is an undefined
scalar variable (or array or hash element), the variable is assigned a
reference to a new anonymous dirhandle.
DIRHANDLEs have their own namespace separate from FILEHANDLEs.

=end original

C<readdir>, C<telldir>, C<seekdir>, C<rewinddir>, C<closedir> 에서 
처리하기 위해, EXPR 에서 지정한 이름의 디렉토리를 오픈합니다.
성공시에는 참을 반환합니다.
DIRHANDLE 은 간접 디렉토리 핸들로써 사용할 수 있는 값(보통은 실제의 디렉토리
핸들의 이름)이 되는 식이라도 상관없습니다.
DIRHANDLE 이 미정의의 스칼라값(또는 배열이나 해쉬의 요소)의 경우, 그 변수는 
새로운 이름없는 디렉토리 핸들로의 리퍼런스가 대입됩니다.
DIRHANDLE 은 FILEHANDLE 과는 별도로 이름공간을 가지고 있습니다.

=item ord EXPR
X<ord> X<encoding>

=item ord

=begin original

Returns the numeric (the native 8-bit encoding, like ASCII or EBCDIC,
or Unicode) value of the first character of EXPR.  If EXPR is omitted,
uses C<$_>.

=end original

EXPR 의 맨처음의 문자를 수치로써 (ASCII, EBCDIC, Unicode 같은 8-bit 
네이티브인코딩의) 값을 반환합니다.
EXPR 을 생략한 경우에는 C<$_> 을 사용합니다.

=begin original

For the reverse, see L</chr>.
See L<perlunicode> for more about Unicode.

=end original

반대로 하기위해서는 L</chr> 을 참조해주세요.
Unicode 에 대해서는 L,perlunicode> 를 참조해주세요.

=item our EXPR
X<our> X<global>

=item our TYPE EXPR

=item our EXPR : ATTRS

=item our TYPE EXPR : ATTRS

=begin original

C<our> associates a simple name with a package variable in the current
package for use within the current scope.  When C<use strict 'vars'> is in
effect, C<our> lets you use declared global variables without qualifying
them with package names, within the lexical scope of the C<our> declaration.
In this way C<our> differs from C<use vars>, which is package scoped.

=end original

C<our> 는 둔순이름을 현재의 영역안에서 사용하기 위해 현재의 패키지의 패키지 
변수로 묶습니다.
C<use strict 'vars'> 가 유효한 경우는 C<our> 를 사용하는 것으로, C<our> 선언을
수식하는 것 없이 사용할 수 있습니다.
이 의미에서는 C<use vars> 는 패키지 영역이기에 C<our> 와는 다릅니다.

=begin original

Unlike C<my>, which both allocates storage for a variable and associates
a simple name with that storage for use within the current scope, C<our>
associates a simple name with a package variable in the current package,
for use within the current scope.  In other words, C<our> has the same
scoping rules as C<my>, but does not necessarily create a
variable.

=end original

기억영역을 변수에 할당하고, 단순이름을 현재의 영역 안에서 사용하기 위해 
그 기억영역에 할당된 C<my> 와 달리, C<our> 는 단순이름을 현재의 영역안에서 
사용하기 위해, 현재의 패키지의 패키지변수로 묶을 수 있습니다.
바꿔 말하면, C<our> 는 C<my> 와 같은 영역 룰을 가지지만, 
변수를 만들 필요는 없습니다.

=begin original

If more than one value is listed, the list must be placed
in parentheses.

=end original

두 개 이상의 값을 리스트하는 경우는 리스트는 괄호로 묶을 필요가 있습니다.

    our $foo;
    our($bar, $baz);

=begin original

An C<our> declaration declares a global variable that will be visible
across its entire lexical scope, even across package boundaries.  The
package in which the variable is entered is determined at the point
of the declaration, not at the point of use.  This means the following
behavior holds:

=end original

C<our> 선언은 렉시컬 영역 전체에 대해서(예를 들어 패키지 경계를 넘어도) 
보이는 글로벌 변수를 선언합니다.
이 변수가 들어가는 패키지는 선언한 시점에서 정의되지 사용한 시점이 아닙니다.
이것에 의해 아래와 같은 행동을 합니다.

    package Foo;
    our $bar;		# declares $Foo::bar for rest of lexical scope
    $bar = 20;

    package Bar;
    print $bar;		# prints 20, as it refers to $Foo::bar

=begin original

Multiple C<our> declarations with the same name in the same lexical
scope are allowed if they are in different packages.  If they happen
to be in the same package, Perl will emit warnings if you have asked
for them, just like multiple C<my> declarations.  Unlike a second
C<my> declaration, which will bind the name to a fresh variable, a
second C<our> declaration in the same package, in the same scope, is
merely redundant.

=end original

같은 렉시컬 영역에서도 패키지가 다르면, 같은 이름에서 여러 C<our> 선언을 
할 수 있습니다.
같은 패키지로 되어 있으면, 경고가 출력되게 되어 있다면, 복수의 C<my> 선언이 
있는 경우와 마찬가지로 경고가 출력됩니다.
새로운 변수를 이름으로 할당하는 것이 되는 2번째의 C<my> 선언과는 달리
같은 패키지의 같은 영역에서 2 번 C<our> 선언하는 것은 단순한 확장입니다.

    use warnings;
    package Foo;
    our $bar;		# declares $Foo::bar for rest of lexical scope
    $bar = 20;

    package Bar;
    our $bar = 30;	# declares $Bar::bar for rest of lexical scope
    print $bar;		# prints 30

    our $bar;		# emits warning but has no other effect
    print $bar;		# still prints 30

=begin original

An C<our> declaration may also have a list of attributes associated
with it.

=end original

C<our> 선언에는 그것과 묶을 수 있는 속성의 리스트를 가질 수도 있습니다.

=begin original

The exact semantics and interface of TYPE and ATTRS are still
evolving.  TYPE is currently bound to the use of C<fields> pragma,
and attributes are handled using the C<attributes> pragma, or starting
from Perl 5.8.0 also via the C<Attribute::Handlers> module.  See
L<perlsub/"Private Variables via my()"> for details, and L<fields>,
L<attributes>, and L<Attribute::Handlers>.

=end original

TYPE 과 ATTRS 의 정확한 문법과 인터페이스는 지금도 진화하고 있습니다.
현재, TYPE 은 C<fields> 프라그마의 사용과 결부되어 
속성은 C<attributes> 프라그마가 Perl 5.8.0 부터는 
C<Attribute::Handlers> 모듈로 결부됩니다.
자세한 내용은 L<perlsub"Private Variables via my()">, L<fields>, 
L<attributes>, L<Attribute::Handlers> 를 참조해주세요.

=item pack TEMPLATE,LIST
X<pack>

=begin original

Takes a LIST of values and converts it into a string using the rules
given by the TEMPLATE.  The resulting string is the concatenation of
the converted values.  Typically, each converted value looks
like its machine-level representation.  For example, on 32-bit machines
an integer may be represented by a sequence of 4 bytes that will be 
converted to a sequence of 4 characters.

=end original

LIST 의 값을 TEMPLATE 로 주어진 룰을 사용해 문자열로 변환합니다.
결과의 문자열은 변환한 값을 연결한 것입니다.
전형적으로는 각각의 변환된 값은 머신 레벨의 표현처럼 보입니다.
예를들어, 32-bit 머신에서는 4 바이트로 표현되는 정수를 변환하면 
4문자의 문자열로 변환됩니다.

=begin original

The TEMPLATE is a sequence of characters that give the order and type
of values, as follows:

=end original

TEMPLATE 는, 아래처럼 값의 형태와 순서를 지정하는 문자를 나열하는 것입니다:

=begin original

    a	A string with arbitrary binary data, will be null padded.
    A	A text (ASCII) string, will be space padded.
    Z	A null terminated (ASCIZ) string, will be null padded.

=end original

    a   임의의 바이너리 데이터를 포함한 문자열, null문자로 채워짐
    A   텍스트(ASCII)  문자열, 스페이스 문자로 채워짐
    Z	null 문자끝(ASCIZ) 문자열, null 문자로 채워짐

=begin original

    b	A bit string (ascending bit order inside each byte, like vec()).
    B	A bit string (descending bit order inside each byte).
    h	A hex string (low nybble first).
    H	A hex string (high nybble first).

=end original

    b   비트열(바이트마다 오름비트순, vec() 처럼) 
    B   비트열(바이트마다 내림비트순)
    h   16진수문자열(low nybble first)
    H   16진수문자열(high nybble first)

=begin original

    c	A signed char (8-bit) value.
    C	An unsigned char (octet) value.
    W   An unsigned char value (can be greater than 255).

=end original

    c   signed char (8 비트) 값
    C   unsigned char (8진수) 값
    W   unsigned char 값 (255 보다 클지도 모름)

=begin original

    s	A signed short (16-bit) value.
    S	An unsigned short value.

=end original

    s   signed short (16 비트) 값
    S   unsigned short 값

=begin original

    l	A signed long (32-bit) value.
    L	An unsigned long value.

=end original

    l   signed long (32 비트) 값
    L   unsigned long 값

=begin original

    q	A signed quad (64-bit) value.
    Q	An unsigned quad value.
	  (Quads are available only if your system supports 64-bit
	   integer values _and_ if Perl has been compiled to support those.
           Causes a fatal error otherwise.)

=end original

    q	부호붙은 64비트 정수
    Q	부호없는 64비트 정수
        (64비트 정수는, 시스템이 64비트정수를 지원하고, Perl 이 64 비트 정수를
        지원하도록 컴파일 되어 있는 경우에만 사용가능합니다.
        그 이외의 경우는 치명적인 에러가 발생합니다.)

=begin original

    i	A signed integer value.
    I	A unsigned integer value.
	  (This 'integer' is _at_least_ 32 bits wide.  Its exact
           size depends on what a local C compiler calls 'int'.)

=end original

    i   signed int 값
    I   unsigned int 값
        (여기에서의 'integer' 는 "최저" 32bits 입니다.
         정확한 시이즈는 로컬의 C 컴파일러의 'int' 사이즈에 의존합니다)

=begin original

    n	An unsigned short (16-bit) in "network" (big-endian) order.
    N	An unsigned long (32-bit) in "network" (big-endian) order.
    v	An unsigned short (16-bit) in "VAX" (little-endian) order.
    V	An unsigned long (32-bit) in "VAX" (little-endian) order.

=end original

    n   "network" 순서(big-endian) 의 unsigned short (16비트)
    N   "network" 순서(big-endian) 의 unsigned long (32비트)
    v   "VAX" 순서 (little-endian) 의 unsigned short (16 비트)
    V   "VAX" 순서 (little-endian) の unsigned long (32 비트)

=begin original

    j   A Perl internal signed integer value (IV).
    J   A Perl internal unsigned integer value (UV).

=end original

    j   Perl 내부 부호붙은 정수(IV)
    J   Perl 내부 부호없는 정수(UV)

=begin original

    f	A single-precision float in the native format.
    d	A double-precision float in the native format.

=end original

    f   기종의존의 단정도 부동소수점
    d   기종의존의 배정도 부동소수점

=begin original

    F	A Perl internal floating point value (NV) in the native format
    D	A long double-precision float in the native format.
	  (Long doubles are available only if your system supports long
	   double values _and_ if Perl has been compiled to support those.
           Causes a fatal error otherwise.)

=end original

    F	네이티브포맷의 Perl 내부 부동소수점 (NV)
    D	네이티브 포맷의 긴 배정도 부동소수점(long double)
        (long double 은 시스템이 long double 을 지원하고 Perl 이 long double 
        을 지원하게 컴파일되어 있을 때만 사용가능합니다.
        그 이외에는 치명적인 에러가 발생합니다.)

=begin original

    p	A pointer to a null-terminated string.
    P	A pointer to a structure (fixed-length string).

=end original

    p   null 문자에서 종단하는 문열로의 포인터
    P   구조체(고정길이 문자열)로의 포인터

=begin original

    u	A uuencoded string.
    U	A Unicode character number.  Encodes to a character in character mode
        and UTF-8 (or UTF-EBCDIC in EBCDIC platforms) in byte mode.

=end original

    u   uuencode 문자열
    U	Unicode 문자번호. 문자모드에서는 문자로, 바이트 모드라면 UTF-8 로 
        (EBCDIC 시스템ㅔ서는 UTF-EBCDIC 로) 인코드됩니다.

=begin original

    w	A BER compressed integer (not an ASN.1 BER, see perlpacktut for
	details).  Its bytes represent an unsigned integer in base 128,
	most significant digit first, with as few digits as possible.  Bit
	eight (the high bit) is set on each byte except the last.

=end original

    w	A BER 압축 변수(ASN.1 BER 이 아닙니다. 자세한 내용에 대해서는 
        perlpacktut 를 참조해주세요.) 이 바이트열은 가능한한 적은 자릿수로
        표현된 128 을 기본으로한 부호없는 정수로 최상위 비트에서 순서대로
        나열됩니다. 마지막의 바이트 이외의 각 바이트의 비트 8(상위 비트)가 
        설정됩니다.

=begin original

    x	A null byte.
    X	Back up a byte.
    @	Null fill or truncate to absolute position, counted from the
        start of the innermost ()-group.
    .   Null fill or truncate to absolute position specified by value.
    (	Start of a ()-group.

=end original

    x	null 바이트
    X	1 문자 후퇴
    @	제일 안쪽의 () 의 쌍의 개시위치에서 세서, 절대위치까지 null 문자로
        채우거나 자른다.
    .   값으로 지정한 절대위치까지 null 문자로 채우거나 자른다.
    (	() 의 쌍의 시작

=begin original

One or more of the modifiers below may optionally follow some letters in the
TEMPLATE (the second column lists the letters for which the modifier is
valid):

=end original

아래에 나타난 하나 또는 복수의 수식자를 TEMPLATE 의 문자의 몇개인가에 옵션으로
붙일 수 있습니다(표의 2줄째는 그 수식자가 유효한 문자입니다):

=begin original

    !   sSlLiI     Forces native (short, long, int) sizes instead
                   of fixed (16-/32-bit) sizes.

=end original

    !   sSlLiI     고정의 (16/32 비트) 사이즈가 아닌 네이티브한(short,long,int)
                   사이즈를 강제한다.

=begin original

        xX         Make x and X act as alignment commands.

=end original

        xX         x 와 X 를 alignment command 로 행동하게 합니다.

=begin original

        nNvV       Treat integers as signed instead of unsigned.

=end original

        nNvV       정수를 부호붙은 것으로 취급한다.

=begin original

        @.         Specify position as byte offset in the internal
                   representation of the packed string. Efficient but
                   dangerous.

=end original

        @.         pack 된 내부표현의 바이트오프셋으로 위치를 지정한다.
                   효율적이지만 위험합니다.

=begin original

    >   sSiIlLqQ   Force big-endian byte-order on the type.
        jJfFdDpP   (The "big end" touches the construct.)

=end original

    >   sSiIlLqQ   이 형태의 바이트 순서을 big-edian 으로 강제합니다
        jJfFdDpP   ("big end" 가 구조를 건드립니다) 

=begin original

    <   sSiIlLqQ   Force little-endian byte-order on the type.
        jJfFdDpP   (The "little end" touches the construct.)

=end original

    <   sSiIlLqQ   이 형태의 바이트 순서를 little-edian 으로 강제합니다
        jJfFdDpP   ("little end" 가 구조를 건드립니다) 

=begin original

The C<E<gt>> and C<E<lt>> modifiers can also be used on C<()>-groups,
in which case they force a certain byte-order on all components of
that group, including subgroups.

=end original

C<E<gt>> 와 C<E<lt>> 의 수식자는 C<()>- 그룹에서도 사용할 수 있습니다;
이 경우는 그 그룹과 부 그룹안의 모든 요소를 특정의 바이트순으로 강제합니다.

=begin original

The following rules apply:

=end original

아래의 조건이 적용됩니다:

=over 8

=item *

=begin original

Each letter may optionally be followed by a number giving a repeat
count.  With all types except C<a>, C<A>, C<Z>, C<b>, C<B>, C<h>,
C<H>, C<@>, C<.>, C<x>, C<X> and C<P> the pack function will gobble up
that many values from the LIST.  A C<*> for the repeat count means to
use however many items are left, except for C<@>, C<x>, C<X>, where it
is equivalent to C<0>, for <.> where it means relative to string start
and C<u>, where it is equivalent to 1 (or 45, which is the same).
A numeric repeat count may optionally be enclosed in brackets, as in
C<pack 'C[80]', @arr>.

=end original

이 문자의 끝에서는 반복수를 나타내는 숫자를 붙일 수 있습니다.
C<a>, C<A>, C<Z>, C<b>, C<B>, C<h>, C<H>, C<@>, C<.>, C<x>, C<X>, C<P>
이외의 모든 형태에서는 LIST 에서 그 숫자값을 뽑아내서 사용합니다.
반복 수에 C<*> 를 지정하면, 그 시점에서 남아있는 모든 요소를 의미합니다.
단, C<@>, C<x>, C<X> 에서는 C<0> 과 같고, 
C<.> 에서는 문자열의 시작에서 상대위치를 의미하고,
C<u> 에서는 1(혹은 45라도 같은) 과 같습니다.
숫자의 반본 수는 C<pack 'C[80]', @arr> 같은 대괄호로 묶을 수 있습니다.

=begin original

One can replace the numeric repeat count by a template enclosed in brackets;
then the packed length of this template in bytes is used as a count.
For example, C<x[L]> skips a long (it skips the number of bytes in a long);
the template C<$t X[$t] $t> unpack()s twice what $t unpacks.
If the template in brackets contains alignment commands (such as C<x![d]>),
its packed length is calculated as if the start of the template has the maximal
possible alignment.

=end original

대괄호로 묶은 템플레이트에서 수치의 반복수를 바꿀 수 있습니다;
이 템플레이트에서 pack 된 바이트 길이가 반복수로 사용됩니다.
예를 들면, C<x[L]> 는 long 을 스킵합니다(long 이 바이트수만 스킵합니다);
템플레이트 C<$t X[$t] $t> 는 $t 를 unpack 한 것의 2배를 unpack() 합니다.
(C<x![d] 처럼) 큰 괄호로 alignment command 가 포함된 경우, 
pack 된 길이는 템플레이트의 맨 앞에서 최대한 가능한 alignment 를 
가지고 있는 것으로 계산됩니다.

=begin original

When used with C<Z>, C<*> results in the addition of a trailing null
byte (so the packed result will be one longer than the byte C<length>
of the item).

=end original

C<*> 가 C<Z> 로 합께 사용된 경우, 끝단에 null 바이트를 붙입니다
(따라서 pack 된 결과는 요소의 C<length> 의 값보다 1 이 크게 됩니다).

=begin original

When used with C<@>, the repeat count represents an offset from the start
of the innermost () group.

=end original

C<@> 를 사용하면, 반복 수는 제일 안쪽의 () 그룹의 맨앞에서의 오프셋을 
표현합니다.

=begin original

When used with C<.>, the repeat count is used to determine the starting
position from where the value offset is calculated. If the repeat count
is 0, it's relative to the current position. If the repeat count is C<*>,
the offset is relative to the start of the packed string. And if its an
integer C<n> the offset is relative to the start of the n-th innermost
() group (or the start of the string if C<n> is bigger then the group
level).

=end original

C<.> 로 사용된 반복수는 값의 오프셋를 계산하기 위한 개시위치를 결정하기
위해 사용됩니.
반복수는 0 이라면, 현재위치에서 상대위치가 됩니다.
반복수가 C<*> 라면, 오프셋은 pack 된 문자열의 맨앞에서의 상대위치입니다.
그리고 정수 C<n> 이라면 오프셋은 제일 안쪽에서 n 번째의 () 그룹의 맨 앞
(또는 C<n> 이 그룹레벨보다 큰 경우는 문자열의 맨앞)에서의 상대위치입니다.

=begin original

The repeat count for C<u> is interpreted as the maximal number of bytes
to encode per line of output, with 0, 1 and 2 replaced by 45. The repeat 
count should not be more than 65.

=end original

C<u> 에서의 반복 횟수는 출력줄 마다 최대 몇 바이트까지를 인코드할 것인가를
나타냅니다. 0,1,2는 45로 취급됩니다.
반복수는 65를 넘어서는 안됩니다.

=item *

=begin original

The C<a>, C<A>, and C<Z> types gobble just one value, but pack it as a
string of length count, padding with nulls or spaces as necessary.  When
unpacking, C<A> strips trailing whitespace and nulls, C<Z> strips everything
after the first null, and C<a> returns data verbatim.

=end original

C<a>, C<A>, C<Z> 같은 형태를 사용하면, 값을 하나만 뽑아서 사용하지만, 
반복수로 나타내는 길이의 문자열이 되게 필요에 따라 null 문자나 
스페이스 문자를 붙입니다.
unpack 할 때, C<A> 는 나중에 읽는 공백이나 null 문자를 뺍니다.
C<Z> 은 최초의 null 문자이후의 모든 것을 뺍니다.
C<a> 는 데이터를 그대로 반환합니다.

=begin original

If the value-to-pack is too long, it is truncated.  If too long and an
explicit count is provided, C<Z> packs only C<$count-1> bytes, followed
by a null byte.  Thus C<Z> always packs a trailing null (except when the
count is 0).

=end original

pack 하는 값이 너무 긴 경우, 잘려집니다.
너무길고 명시적으로 갯수가 지정된 경우 
C<Z> 는 C<$count-1> 바이트까지 pack 하고, 그 뒤로 null 바이트가 붙습니다.
따라서 C<Z> 는 (반복수가 0인 경우를 빼고) 항상 끝단에 null 바이트가 붙습니다.

=item *

=begin original

Likewise, the C<b> and C<B> fields pack a string that many bits long.
Each character of the input field of pack() generates 1 bit of the result.
Each result bit is based on the least-significant bit of the corresponding
input character, i.e., on C<ord($char)%2>.  In particular, characters C<"0">
and C<"1"> generate bits 0 and 1, as do characters C<"\0"> and C<"\1">.

=end original

마찬가지로 C<b> 나 C<B> 는, 반복수로 나타내는 비트 길이의 비트열에 pack합니다.
pack() 의 입력 필드의 각 문자는 결과의 1비트를 생성합니다.
결과 비트의 각각은 대응하는 입력문자의 최하위 비트를 기반으로 합니다.
(즉 C<ord($char)%2>). 특히 문자 C<"0"> 와 C<"1"> 은 문자 C<"\0"> 와 
C<"\1"> 과 마찬가지로 비트 0과 1일 생성합니다.

=begin original

Starting from the beginning of the input string of pack(), each 8-tuple
of characters is converted to 1 character of output.  With format C<b>
the first character of the 8-tuple determines the least-significant bit of a
character, and with format C<B> it determines the most-significant bit of
a character.

=end original

pack() 의 입력문자열의 맨앞에서 시작해서 8 튜플 마다 1문자의 출력으로
변환됩니다.
C<b> 포맷에서는 8 튜플의 최초의 문자가 출력 최하위비트가 되고, 
C<B> 포맷에서는 출력의 최상위 비트가 됩니다.

=begin original

If the length of the input string is not exactly divisible by 8, the
remainder is packed as if the input string were padded by null characters
at the end.  Similarly, during unpack()ing the "extra" bits are ignored.

=end original

만약 입력문자열의 길이가 8로 나눠지지 않는 경우, 남은 부분은 입력문자열의
마지막에 null 문자가 padding 되는 것으로 pack 됩니다.
마찬가지로 unpack() 안은 "여분의" 비트는 무시됩니다.

=begin original

If the input string of pack() is longer than needed, extra characters are 
ignored. A C<*> for the repeat count of pack() means to use all the 
characters of the input field.  On unpack()ing the bits are converted to a 
string of C<"0">s and C<"1">s.

=end original

pack() 의 입력문자열이 필요한 분량보다 긴 경우, 여분의 문자는 무시됩니다.
pack() 의 반복수로써 C<*> 가 지정되면 입력 필드의 모든 문자가 사용됩니다.
unpack() 시에는 비트 열은 C<"0"> 과 C<"1"> 의 문자열로 변환됩니다.

=item *

=begin original

The C<h> and C<H> fields pack a string that many nybbles (4-bit groups,
representable as hexadecimal digits, 0-9a-f) long.

=end original

C<h> 나 C<H> 는 많은 nybble 길이(16 진수 문자인 0-9a-f 로 표현가능한 
4비트 그룹)의 nybble 열로 pack 합니다.

=begin original

Each character of the input field of pack() generates 4 bits of the result.
For non-alphabetical characters the result is based on the 4 least-significant
bits of the input character, i.e., on C<ord($char)%16>.  In particular,
characters C<"0"> and C<"1"> generate nybbles 0 and 1, as do bytes
C<"\0"> and C<"\1">.  For characters C<"a".."f"> and C<"A".."F"> the result
is compatible with the usual hexadecimal digits, so that C<"a"> and
C<"A"> both generate the nybble C<0xa==10>.  The result for characters
C<"g".."z"> and C<"G".."Z"> is not well-defined.

=end original

pack() 의 입력필드의 각문자는 결과의 4비트를 생성합니다.
영어가 아닌 문자인 경우 결과는 입력문자의 하위 4비트를 기반으로 합니다
(즉 C<ord($char)%16>).
특히 문자 C<"0"> 과 C<"1"> 은 바이트 C<"\0"> 과 C<"\1"> 처럼 
nybble 0 과 1을 생성합니다.
문자 C<"a".."f"> 와 C<"A".."F"> 인 경우는 결과는 일반적인 
nybble C<0xa==10> 을 생성합니다.
문자 C<"g".."z"> 와 C<"G".."Z"> 에 대한 결과는 미정의입니다.

=begin original

Starting from the beginning of the input string of pack(), each pair
of characters is converted to 1 character of output.  With format C<h> the
first character of the pair determines the least-significant nybble of the
output character, and with format C<H> it determines the most-significant
nybble.

=end original

pack() 의 입력문자열의 맨앞에서 시작해서 2문자마다 1문자의 출력으로 
변환됩니다.
C<h> 포맷에서는 1문자째가 출력의 최하위 nybble 이 되고
C<H> 포맷에서는 출력의 최상위 nybble 이 됩니다.

=begin original

If the length of the input string is not even, it behaves as if padded
by a null character at the end.  Similarly, during unpack()ing the "extra"
nybbles are ignored.

=end original

입력문자열의 길이가 허수가 아닌 경우, 마지막에 null 문자로 padding 되었는것
처럼 행동합니다.
마찬가지로 unpack() 안은 "여분의" nybble 은 무시됩니다.

=begin original

If the input string of pack() is longer than needed, extra characters are
ignored.
A C<*> for the repeat count of pack() means to use all the characters of
the input field.  On unpack()ing the nybbles are converted to a string
of hexadecimal digits.

=end original

pack() 의 입력문자열이 필요한 분량보다 긴 경우, 여분의 부분은 무시됩니다.
pack() 의 반복수로 C<*> 가 지정되면 입력 필드의 모든 문자가 사용됩니다.
unpack() 시에는 nybble 은 16진수의 문자열로 변환됩니다.

=item *

=begin original

The C<p> type packs a pointer to a null-terminated string.  You are
responsible for ensuring the string is not a temporary value (which can
potentially get deallocated before you get around to using the packed result).
The C<P> type packs a pointer to a structure of the size indicated by the
length.  A NULL pointer is created if the corresponding value for C<p> or
C<P> is C<undef>, similarly for unpack().

=end original

C<p> 는 null문자 종단문자열로의 포인터를 pack 합니다.
문자열이 일시적인 값이 아닌(즉 pack 된 결과를 사용하기 전에 문자열이
해방되지 않는) 것에 책임을 질 필요가 있습니다.
C<P> 는 지정한 길이의 구조체로 포인터를 pack 합니다.
C<p> 또는 C<P> 에 대응하는 값이 C<undef> 였을 경우 ,
unpack() 처럼 null 포인터가 작성됩니다.

=begin original

If your system has a strange pointer size (i.e. a pointer is neither as
big as an int nor as big as a long), it may not be possible to pack or
unpack pointers in big- or little-endian byte order.  Attempting to do
so will result in a fatal error.

=end original

시스템의 포인터가 변한 사이즈인 경우(즉, int 의 크기든 long 의 크기든 
상관없는 경우) 포인터를 big-endian 이나 little-endian 의 
바이트 순으로 pack 이나 unpack 할 수는 없습니다.
그렇게 하려고 하면 치명적인 에러가 됩니다.

=item *

=begin original

The C</> template character allows packing and unpacking of a sequence of
items where the packed structure contains a packed item count followed by 
the packed items themselves.

=end original

C</> 템플레이트 문자는 아이템 수의 뒤에 아이템 그 것이 들어있는 형태의 
아이템 열을 pack 및 unpack 합니다.

=begin original

For C<pack> you write I<length-item>C</>I<sequence-item> and the
I<length-item> describes how the length value is packed. The ones likely
to be of most use are integer-packing ones like C<n> (for Java strings),
C<w> (for ASN.1 or SNMP) and C<N> (for Sun XDR).

=end original

C<pack> 에서는 I<length-item>C</>I<string-item> 의 형태가 되고, 
더욱더 잘 알려진 것은 C<n>(Java 문자열), C<w>(SNMP), C<N>(Sun XDR) 같은 
정수형입니다.

=begin original

For C<pack>, the I<sequence-item> may have a repeat count, in which case
the minimum of that and the number of available items is used as argument
for the I<length-item>. If it has no repeat count or uses a '*', the number
of available items is used.

=end original

C<pac> 에서는 I<sequence-item> 은 반복수를 가질 수 있고, 그 경우는 
그 최소한으로 이용가능한 아이템의 수는 I<length-item> 을 위한 인수로 
사용됩니다.
반복수가 없거나 '*' 를 사용하면 이용가능한 아이템 수가 사용됩니다.

=begin original

For C<unpack> an internal stack of integer arguments unpacked so far is
used. You write C</>I<sequence-item> and the repeat count is obtained by
popping off the last element from the stack. The I<sequence-item> must not
have a repeat count.

=end original

C<unpack> 에서는 지금까지 unpack 한 숫자값인수의 내부 스택이 사용됩니다.
C</>I<sequence-item> 이라고 쓰고, 반복수는 스택에서 마지막 요소를 뽑아내는
것으로 얻습니다.
I<sequence-item> 은 반복수를 가지고 있어서는 안됩니다.

=begin original

If the I<sequence-item> refers to a string type (C<"A">, C<"a"> or C<"Z">),
the I<length-item> is a string length, not a number of strings. If there is
an explicit repeat count for pack, the packed string will be adjusted to that
given length.

=end original

I<sequence-item> 이 문자열형 (C<"A">, C<"a">, C<"Z">) 를 참조하고 있는 경우,
I<length-item> 은 문자열의 수가 아닌 문자열의 길이입니다.
pack 에서 명시적인 반복수가 있으면, pack 된 문자열은 주어진 길이로
조정됩니다.

    unpack 'W/a', "\04Gurusamy";            gives ('Guru')
    unpack 'a3/A A*', '007 Bond  J ';       gives (' Bond', 'J')
    unpack 'a3 x2 /A A*', '007: Bond, J.';  gives ('Bond, J', '.')
    pack 'n/a* w/a','hello,','world';       gives "\000\006hello,\005world"
    pack 'a/W2', ord('a') .. ord('z');      gives '2ab'

=begin original

The I<length-item> is not returned explicitly from C<unpack>.

=end original

I<legnth-item> 은 C<unpack> 에서 명시적으로는 반환되지 않습니다.

=begin original

Adding a count to the I<length-item> letter is unlikely to do anything
useful, unless that letter is C<A>, C<a> or C<Z>.  Packing with a
I<length-item> of C<a> or C<Z> may introduce C<"\000"> characters,
which Perl does not regard as legal in numeric strings.

=end original

I<length-item> 문자에 반복수를 붙이는 것은 
문자가 C<A>, C<a>, C<Z> 가 아닌 한은 유용하지 않습니다.
C<a> 나 C<Z> 를 I<length-item> 으로 pack 하면 C<"\000"> 문자가 
출력되는 수가 있고, Perl 은 이것을 유효한 숫자값 문자열로 인식하지 않습니다.

=item *

=begin original

The integer types C<s>, C<S>, C<l>, and C<L> may be
followed by a C<!> modifier to signify native shorts or
longs--as you can see from above for example a bare C<l> does mean
exactly 32 bits, the native C<long> (as seen by the local C compiler)
may be larger.  This is an issue mainly in 64-bit platforms.  You can
see whether using C<!> makes any difference by

=end original

C<s>, C<S>, C<l>, C<L> 의 정수타입에 이어서 C<!> 수식자를 붙이는 것으로 
네이티브의 short 나 long 을 지정할 수 있습니다 -- 
위에 기술한 것처럼, 예를들면 C<l> 은 정확하게 32비트이고, 네이티브한 
(로컬한 C 컴파일러에 의함) C<long> 은 더욱 클지도 모릅니다.
이것은 주로 64비트 플랫폼에서 의미가 있습니다.
C<!> 를 사용하는 것에 의해 차이가 있는지 없는 지는 아래처럼 해서 
조사할 수 있습니다:

	print length(pack("s")), " ", length(pack("s!")), "\n";
	print length(pack("l")), " ", length(pack("l!")), "\n";

=begin original

C<i!> and C<I!> also work but only because of completeness;
they are identical to C<i> and C<I>.

=end original

C<i!> 과 C<I!> 도 동작하지만, 단순히 완전성을 위해서만입니다;
이것은 C<i> 및 C<I> 와 같습니다.

=begin original

The actual sizes (in bytes) of native shorts, ints, longs, and long
longs on the platform where Perl was built are also available via
L<Config>:

=end original

Perl 이 빌드된 플랫폼에서의 short, int, long, long long 의 실제(바이트수에서의)
사이즈는 L<Config> 에서도 얻을 수 있습니다.

       use Config;
       print $Config{shortsize},    "\n";
       print $Config{intsize},      "\n";
       print $Config{longsize},     "\n";
       print $Config{longlongsize}, "\n";

=begin original

(The C<$Config{longlongsize}> will be undefined if your system does
not support long longs.)

=end original

(시스템이 long long 를 지원하지 않는 경우 C<$Config{longlongsize}> 는 
미정의값이 됩니다.)

=item *

=begin original

The integer formats C<s>, C<S>, C<i>, C<I>, C<l>, C<L>, C<j>, and C<J>
are inherently non-portable between processors and operating systems
because they obey the native byteorder and endianness.  For example a
4-byte integer 0x12345678 (305419896 decimal) would be ordered natively
(arranged in and handled by the CPU registers) into bytes as

=end original

정수 포맷 C<s>, C<S>, C<i>, C<I>, C<l>, C<L>, C<j>, C<J> 는 
네이티브한 바이트 순서와 에디안에 따르기 때문에, 본질적으로 
프로세서 사이나 OS 사이에서 이식성이 없습니다.
예를들면 4바이트의 정수 0x12345678 (10 준수에서는 305419896) 은 
내부에서는 (CPU 레지스터에 의해 변환되어 사용되는 형태에서는) 
아래와 같은 바이트열로 나열됩니다:

 	0x12 0x34 0x56 0x78	# big-endian
 	0x78 0x56 0x34 0x12	# little-endian

=begin original

Basically, the Intel and VAX CPUs are little-endian, while everybody
else, for example Motorola m68k/88k, PPC, Sparc, HP PA, Power, and
Cray are big-endian.  Alpha and MIPS can be either: Digital/Compaq
used/uses them in little-endian mode; SGI/Cray uses them in big-endian
mode.

=end original

기본적으로 Intel 과 VAX 의 CPU 는 little-edian 입니다.
한편 그 외, 예를들면 Motorola m68k/88k, PPC, Sparc, HP PA, Power, 
Cray 등은 big-edian 입니다.
Alpha 와 MIPS 는 양쪽다 있습니다:
Digital/Compaq 은 little-edian 모드로 사용하고 있습니다(있었습니다);
SGI/Cray 는 big-edian 모드에서 사용하고 있습니다.

=begin original

The names `big-endian' and `little-endian' are comic references to
the classic "Gulliver's Travels" (via the paper "On Holy Wars and a
Plea for Peace" by Danny Cohen, USC/ISI IEN 137, April 1, 1980) and
the egg-eating habits of the Lilliputians.

=end original

"big-edian" 과 "little-edian" 의 이름은 
고전에 있는 "걸리버 여행기" 와 리리파트족의 달걀을 먹는 습관에서 
따왔습니다.

=begin original

Some systems may have even weirder byte orders such as

=end original

아래와 같은 보다 바뀐 바이트순서를 가ㄴ 시스템도 있을 지도 모릅니다:

 	0x56 0x78 0x12 0x34
 	0x34 0x12 0x78 0x56

=begin original

You can see your system's preference with

=end original

시스템의 설정은 아래처럼 해서 볼 수 있습니다:

 	print join(" ", map { sprintf "%#02x", $_ }
                            unpack("W*",pack("L",0x12345678))), "\n";

=begin original

The byteorder on the platform where Perl was built is also available
via L<Config>:

=end original

Perl 이 빌드된 플랫폼에서의 바이트순서는 
L<Config> 에서도 알 수가 있습니다:

	use Config;
	print $Config{byteorder}, "\n";

=begin original

Byteorders C<'1234'> and C<'12345678'> are little-endian, C<'4321'>
and C<'87654321'> are big-endian.

=end original

C<'1234'> 과 C<'12345678'> 은 little-edian. 
C<'4321'> 과 C<'87654321'> 은 big-edian 입니다. 

=begin original

If you want portable packed integers you can either use the formats
C<n>, C<N>, C<v>, and C<V>, or you can use the C<E<gt>> and C<E<lt>>
modifiers.  These modifiers are only available as of perl 5.9.2.
See also L<perlport>.

=end original

이식성이 있는 pack 화된 정수가 필요한 경우는 
C<n>, C<N>, C<v>, C<V> 포맷을 사용하거나 C<E<gt>> 와 C<E<lt>> 
수식자를 쓸 수 있습니다.
이 수식자들은 perl 5.9.2 이후에서만 사용할 수 있습니다.
L<perlport> 도 참조해주세요.

=item *

=begin original

All integer and floating point formats as well as C<p> and C<P> and
C<()>-groups may be followed by the C<E<gt>> or C<E<lt>> modifiers
to force big- or little- endian byte-order, respectively.
This is especially useful, since C<n>, C<N>, C<v> and C<V> don't cover
signed integers, 64-bit integers and floating point values.  However,
there are some things to keep in mind.

=end original

C<p> 와 C<P> 와 C<()> 그룹처럼 모든 정수와 부동소수점수의 
포맷은 C<E<gt>> 나 C<E<lt>> 의 수식자를 붙이는 것으로 각각 
big-edian 과 little-edian 으로 강제시킬 수 있습니다.
C<n>, C<N>, C<v>, C<V> 는 부호붙은 정수, 64비트 정수, 부동소수점수를 
지원하지 않기때문에 이것은 특히 유용합니다.
그러나 신경쓰지 않으면 안되는 것이 몇가지 있습니다.

=begin original

Exchanging signed integers between different platforms only works
if all platforms store them in the same format.  Most platforms store
signed integers in two's complement, so usually this is not an issue.

=end original

다른 플랫폼에서 부호붙은 정수를 교환하는 것은 모든 플랫폼에서 같은 
포맷에서 보존되는 경우에만 잘 됩니다.
대부분의 플랫폼에서는 부호붙은 정수는 2 의 보수로 보존되기 때문에 
보통은 이것은 문제가 되지 않습니다.

=begin original

The C<E<gt>> or C<E<lt>> modifiers can only be used on floating point
formats on big- or little-endian machines.  Otherwise, attempting to
do so will result in a fatal error.

=end original

C<E<gt>> 나 C<E<lt>> 의 수식자는 big-edian 이나 little-edian 의 머신에서의 
부동소수점 포맷에서만 사용할 수 있습니다.
그 이외에서는 그런 시험은 치명적인 에러가 됩니다.

=begin original

Forcing big- or little-endian byte-order on floating point values for
data exchange can only work if all platforms are using the same
binary representation (e.g. IEEE floating point format).  Even if all
platforms are using IEEE, there may be subtle differences.  Being able
to use C<E<gt>> or C<E<lt>> on floating point values can be very useful,
but also very dangerous if you don't know exactly what you're doing.
It is definitely not a general way to portably store floating point
values.

=end original

데이터 교환을 위해 부동소수점수의 바이트순서를 big-edian 이나 little-edian
으 강제하는 것은 모든 플랫폼이 같은 바이너리 표현(예를 들면 IEEE 부동소수점
포맷)인 경우에만 잘 됩니다.
예를 들어 모든 플랫폼이 IEEE 를 사용하고 있어도 그곳에는 미묘한 차이가 있을
지도 모릅니다.
부동소수점수에 C<E<gt>> 나 C<E<lt>> 를 사용할 수 있는 매우 편리한 경우가 
있습니다만, 만약 자신이 무엇을 하는 가를 정확하게 이해하지 않으면, 매우 
위험합니다.
이석성이 있는 부동소수점의 보존을 위 일반적인 방법이 없는 것은 확실합니다.

=begin original

When using C<E<gt>> or C<E<lt>> on an C<()>-group, this will affect
all types inside the group that accept the byte-order modifiers,
including all subgroups.  It will silently be ignored for all other
types.  You are not allowed to override the byte-order within a group
that already has a byte-order modifier suffix.

=end original

C<()> 그룹에서 C<E<gt>> 나 C<E<lt>> 를 사용하면, 이것은 부 그룹을 
포함한 모든 형태 안에 바이트순서 수식자를 받아들이는 모든 것에 영향을 
줍니다. 그 외의 형태에 대해서는 침묵하며 무시됩니다.
이미 바이트순 접미사를 가지고 잇는 그룹안의 바이트순을 덮어쓸 수는 
없습니다.

=item *

=begin original

Real numbers (floats and doubles) are in the native machine format only;
due to the multiplicity of floating formats around, and the lack of a
standard "network" representation, no facility for interchange has been
made.  This means that packed floating point data written on one machine
may not be readable on another - even if both use IEEE floating point
arithmetic (as the endian-ness of the memory representation is not part
of the IEEE spec).  See also L<perlport>.

=end original

실수 (float 과 double) 은 기종의존의 포맷밖에 없습니다.
여러 부동소수점 수의 포맷이 있고, 표준적인 "network" 표현같은 것이
없기 때문에 데이터 교환을 위해 기능은 준비하지 않습니다.
즉, 어떤 머신에서 pack 한 부동소수점수는 다른 머신에서는 
읽을 수 없을 지도 모른다는 것입니다.
예를들어 양쪽이 IEEE 포맷의 부동소수점연산을 수행한다고 해도입니다.
(IEEE 의 스펙ㅔ서는 메모리 표현상의 바이트순서까지는, 지정되어있지 
않기때문입니다).
L<perlport> 도 참조해주세요.

=begin original

If you know exactly what you're doing, you can use the C<E<gt>> or C<E<lt>>
modifiers to force big- or little-endian byte-order on floating point values.

=end original

만약 무엇을 하려고 하는지를 확인하고 이해하고 있다면, 부동소수점수의 
바이트순을 big-edian 이나 little-edian 으로 강제하기 위해 
C<E<gt>> 와 C<E<lt>> 의 수식자를 쓸 수 있습니다.

=begin original

Note that Perl uses doubles (or long doubles, if configured) internally for
all numeric calculation, and converting from double into float and thence back
to double again will lose precision (i.e., C<unpack("f", pack("f", $foo)>)
will not in general equal $foo).

=end original

Perl 에서는 모든 숫자값 연산을 위해 내부적으로 double( 또는 
설정에 따라 long double) 을 사용하고 있습니다.
double 에서 float 으로 변환하고 그리고 다시 double 에 돌아오면 
정도가 떨어지게 됩니다 (즉, C<unpack("f", pack("f", $foo)>) 은, 
일반적으로는 $foo 와 같지 않다는 것입니다).

=item *

=begin original

Pack and unpack can operate in two modes, character mode (C<C0> mode) where
the packed string is processed per character and UTF-8 mode (C<U0> mode)
where the packed string is processed in its UTF-8-encoded Unicode form on
a byte by byte basis. Character mode is the default unless the format string 
starts with an C<U>. You can switch mode at any moment with an explicit 
C<C0> or C<U0> in the format. A mode is in effect until the next mode switch 
or until the end of the ()-group in which it was entered.

=end original

pack 과 unpack 은 두개의 모드에서 조작합니다; pack 된 문자열을 문자단위로 
처리하는 문자모드 (C<C0> 모드) 와, pack 된 문자열을 바이스다 
그 UTF-8 인코드된 형식으로 처리하는 UTF-8 모드 (C<U0> 모드) 입니다.
문자모드는 포맷 문자열이 C<U> 로 시작하지 않는 한은 기본값입니다.
모드는 포맷 안에 명시적으로 C<C0> 또는 C<U0> 이라고 쓰는 것으로 
언제나 바꿀 수 있습니다.
모드는 다음의 모드로 바꿀 수 있거나 현재의 () 그룹이 끝나기까지 유효합니다.

=item *

=begin original

You must yourself do any alignment or padding by inserting for example
enough C<'x'>es while packing.  There is no way to pack() and unpack()
could know where the characters are going to or coming from.  Therefore
C<pack> (and C<unpack>) handle their output and input as flat
sequences of characters.

=end original

pack 할 때에, 예를들어 충분한 수의 C<'x'> 를 삽입하는 것에 의해 
alignment 나 padding 을 수행하는 것은 모두 스스로 하지 않으면 안됩니다.
문자열이 어디로 가는 가, 어디에서 왔는가를 pack() 이나 unpack() 이 
아는 방법은 없습니다.
따라서 C<pack> (과 C<unpack>) 은 출력과 입력을 플랫한 문자열로 다룹니다.

=item *

=begin original

A ()-group is a sub-TEMPLATE enclosed in parentheses.  A group may
take a repeat count, both as postfix, and for unpack() also via the C</>
template character. Within each repetition of a group, positioning with
C<@> starts again at 0. Therefore, the result of

=end original

() 의 그룹은 괄호로 감싸진 부 템플레이트입니다.
그룹은 반복수를 얻을 수 있습니다;  접미사에 따르거나, unpack() 의 경우는 
C</> 템플레이트 문자에 따릅니다.
그룹의 반복마다 C<@> 단위는 0이 됩니다.
따라서 아래의 결과는 :

    pack( '@1A((@2A)@3A)', 'a', 'b', 'c' )

=begin original

is the string "\0a\0\0bc".

=end original

문자열 "\0a\0\0bc" 입니다.

=item *

=begin original

C<x> and C<X> accept C<!> modifier.  In this case they act as
alignment commands: they jump forward/back to the closest position
aligned at a multiple of C<count> characters. For example, to pack() or
unpack() C's C<struct {char c; double d; char cc[2]}> one may need to
use the template C<W x![d] d W[2]>; this assumes that doubles must be
aligned on the double's size.

=end original

C<x> 와 C<X> 에는 C<!> 수식자를 붙일 수 있습니다.
이 경우, 이것들은 alignment command 로 움직입니다:
C<count> 문자의 배수의 alignment 가 되고, 제일 가까운 위치로 이동합니다.
예를들면, C 의 C<struct {char c; double d; char cc[2]} 를 pack() 또는 
unpack() 하기 위해서는 C<W x![d] d W[2]> 라는 템플레이트를 사용할 필요가 
있을 지도 모릅니다;
가정하고 있습니다.

=begin original

For alignment commands C<count> of 0 is equivalent to C<count> of 1;
both result in no-ops.

=end original

alignment command 에 대해서는 C<count> 에 0 을 지정하는 것은 1을 지정하는 것과
같습니다; 어느쪽도 아무것도 하지 않습니다.

=item *

=begin original

C<n>, C<N>, C<v> and C<V> accept the C<!> modifier. In this case they
will represent signed 16-/32-bit integers in big-/little-endian order.
This is only portable if all platforms sharing the packed data use the
same binary representation for signed integers (e.g. all platforms are
using two's complement representation).

=end original

C<n>, C<N>, C<v>, C<V> 는 C<!> 수식자를 받아들이지 않습니다.
이 경우, 이것들은 big/little-edian 의 순서로 부호붙은 16 혹은 32비트 정수로 
표현됩니다.
이것은 pack 된 데이터를 공유하는 모든 플랫폼이 부호붙은 정수에 대해서 같은
바이너리 표현을 사용하는(즉, 모든 플랫폼에서 2의 보수표현을 사용) 경우에만
이식성이 있습니다.

=item *

=begin original

A comment in a TEMPLATE starts with C<#> and goes to the end of line.
White space may be used to separate pack codes from each other, but
modifiers and a repeat count must follow immediately.

=end original

TEMPLATE 의 안의 C<#> 에서 줄 끝까지는 커멘트입니다.
공백은 pack 코드를 각각 나누기 위해 사용할 수 있지만, 수식자와 
반복수는 직후에 놓지 않으면 안됩니다.

=item *

=begin original

If TEMPLATE requires more arguments to pack() than actually given, pack()
assumes additional C<""> arguments.  If TEMPLATE requires fewer arguments
to pack() than actually given, extra arguments are ignored.

=end original

TEMPLATE 가 요구하는 인수 수가 pack() 이 실제로 주는 수보다 많은 경우,
추가의 C<""> 인수가 있는 것으로 가정합니다.
TEMPLATE 가 요ê는 인수의 수 쪽이 적은 경우, 여분의 인수는 무시됩니다.

=back

=begin original

Examples:

=end original

예제:

    $foo = pack("WWWW",65,66,67,68);
    # foo eq "ABCD"
    $foo = pack("W4",65,66,67,68);
    # same thing
    $foo = pack("W4",0x24b6,0x24b7,0x24b8,0x24b9);
    # same thing with Unicode circled letters.
    $foo = pack("U4",0x24b6,0x24b7,0x24b8,0x24b9);
    # same thing with Unicode circled letters. You don't get the UTF-8
    # bytes because the U at the start of the format caused a switch to
    # U0-mode, so the UTF-8 bytes get joined into characters
    $foo = pack("C0U4",0x24b6,0x24b7,0x24b8,0x24b9);
    # foo eq "\xe2\x92\xb6\xe2\x92\xb7\xe2\x92\xb8\xe2\x92\xb9"
    # This is the UTF-8 encoding of the string in the previous example

    $foo = pack("ccxxcc",65,66,67,68);
    # foo eq "AB\0\0CD"

    # note: the above examples featuring "W" and "c" are true
    # only on ASCII and ASCII-derived systems such as ISO Latin 1
    # and UTF-8.  In EBCDIC the first example would be
    # $foo = pack("WWWW",193,194,195,196);

    $foo = pack("s2",1,2);
    # "\1\0\2\0" on little-endian
    # "\0\1\0\2" on big-endian

    $foo = pack("a4","abcd","x","y","z");
    # "abcd"

    $foo = pack("aaaa","abcd","x","y","z");
    # "axyz"

    $foo = pack("a14","abcdefg");
    # "abcdefg\0\0\0\0\0\0\0"

    $foo = pack("i9pl", gmtime);
    # a real struct tm (on my system anyway)

    $utmp_template = "Z8 Z8 Z16 L";
    $utmp = pack($utmp_template, @utmp1);
    # a struct utmp (BSDish)

    @utmp2 = unpack($utmp_template, $utmp);
    # "@utmp1" eq "@utmp2"

    sub bintodec {
	unpack("N", pack("B32", substr("0" x 32 . shift, -32)));
    }

    $foo = pack('sx2l', 12, 34);
    # short 12, two zero bytes padding, long 34
    $bar = pack('s@4l', 12, 34);
    # short 12, zero fill to position 4, long 34
    # $foo eq $bar
    $baz = pack('s.l', 12, 4, 34);
    # short 12, zero fill to position 4, long 34

    $foo = pack('nN', 42, 4711);
    # pack big-endian 16- and 32-bit unsigned integers
    $foo = pack('S>L>', 42, 4711);
    # exactly the same
    $foo = pack('s<l<', -42, 4711);
    # pack little-endian 16- and 32-bit signed integers
    $foo = pack('(sl)<', -42, 4711);
    # exactly the same

=begin original

The same template may generally also be used in unpack().

=end original

일반적으로는 pack 으로 사용한 것과 마찬가지로 템플레이트가 
unpack() 함수에서도 사용할 수 있습니다.

=item package NAMESPACE
X<package> X<module> X<namespace>

=item package

=begin original

Declares the compilation unit as being in the given namespace.  The scope
of the package declaration is from the declaration itself through the end
of the enclosing block, file, or eval (the same as the C<my> operator).
All further unqualified dynamic identifiers will be in this namespace.
A package statement affects only dynamic variables--including those
you've used C<local> on--but I<not> lexical variables, which are created
with C<my>.  Typically it would be the first declaration in a file to
be included by the C<require> or C<use> operator.  You can switch into a
package in more than one place; it merely influences which symbol table
is used by the compiler for the rest of that block.  You can refer to
variables and filehandles in other packages by prefixing the identifier
with the package name and a double colon:  C<$Package::Variable>.
If the package name is null, the C<main> package as assumed.  That is,
C<$::sail> is equivalent to C<$main::sail> (as well as to C<$main'sail>,
still seen in older code).

=end original

주어진 이름공간에서 컴파일 단위를 선언합니다.
패키지 서언의 스코프는 선언자체에서 닫힌 블록, 파일, 
eval 의 끝까지입니다(C<my> 연산자와 같습니다).
모든 수식되지 않은 동적식별자는 이 이름공간이 됩니다.
package 문은 동적변수에만 영향을 끼칩니다만 -- C<local> 에서 사용한 것도 
포함합니다 --, C<my> 로 작성된 렉시컬 변수에는 I<영향을 주지 않습니다>.
전형적으로는 이것은 C<require> 나 C<use> 연산자에서 include 된 파일의 
최초에 선언됩니다.
패키지를 복수의 장소에서 바꿀 수 있습니다;
이것은 단순히 컴파일러가 이 블록의 남은 것에 대해서 어느 심볼 테이블을 
사용하는 가에만 영향을 끼칩니다.
다른 패키지의 변수나 파일핸들은 식별자에 패지 이름과 콜론 2개를 붙이는 것으로
참조할 수 있습니다(C<$Package::Variable>).
패키지 이름이 빈문자열인 경우, C<main> 패키지가 가정됩니다.
즉, C<$::sail> 은 C<$main::sail> 과 같습니다(C<$main'sail> 도 
낡은 코드에서는 아직 볼 수 있습니다).

=begin original

If NAMESPACE is omitted, then there is no current package, and all
identifiers must be fully qualified or lexicals.  However, you are
strongly advised not to make use of this feature. Its use can cause
unexpected behaviour, even crashing some versions of Perl. It is
deprecated, and will be removed from a future release.

=end original

NAMESPACE 가 생략되면, 최근 패키지는 없어지기 때문에,
모든 식별자는 완전수식되거나 렉시컬이 아니면 안됩니다.
그러나, 이 기능을 사용하지 않는 것을 강력히 권합니다.
이 사용은 예상외의 행동을 일으킬 수 있고, Perl 의 버젼에 따라서는 
충돌할 지도 모릅니다.
이것은 비추천이고, 장래의 릴리즈에서는 제거됩니다.

=begin original

See L<perlmod/"Packages"> for more information about packages, modules,
and classes.  See L<perlsub> for other scoping issues.

=end original

패키지, 모듈, 클래스에 관한 보다 자세한 정보에 대해서는 
L<perlmod/"Packages"> 를 참조해주세요.
그 외의 영역에 관한 화제에 대해서는 L<perlsub> 를 참조해주세요.

=item pipe READHANDLE,WRITEHANDLE
X<pipe>

=begin original

Opens a pair of connected pipes like the corresponding system call.
Note that if you set up a loop of piped processes, deadlock can occur
unless you are very careful.  In addition, note that Perl's pipes use
IO buffering, so you may need to set C<$|> to flush your WRITEHANDLE
after each command, depending on the application.

=end original

대응하는 시스템 호출과 마찬가지로, 접속된 파이프의 쌍을 오픈합니다.
파이프로 프로세스를 루프할 때에는 보다 주의를 기울이지 않으면,
deadlock 이 발생할 수 있습니다.
그리고, Perl 의 파이프에서는 IO의 버퍼링을 사용하 때문에, 
어플리케이션에 따라서는 커맨드마다 WRITEHANDLE 을 flush 하도록
C<$!> 을 설정하는 것이 필요할 지도 모르겠습니다.

=begin original

See L<IPC::Open2>, L<IPC::Open3>, and L<perlipc/"Bidirectional Communication">
for examples of such things.

=end original

이것들에 관한 보다 자세한 예제에 대해서는 L<IPC::Open2>, L<IPC::Open3>,
L<perlipc/"Bidirectional Communication"> 를 참조해주세요.

=begin original

On systems that support a close-on-exec flag on files, the flag will be set
for the newly opened file descriptors as determined by the value of $^F.
See L<perlvar/$^F>.

=end original

파일에 대한 close-on-exec 플래그를 지원하고 있는 시스템에서는 
플래그는 $^F 의 값으로 결정되는 새롭게 오픈된 파일기술자에 대해서
설정됩니다.
L<perlvar/$^F> 를 참조해주세요.

=item pop ARRAY
X<pop> X<stack>

=item pop

=begin original

Pops and returns the last value of the array, shortening the array by
one element.

=end original

벼열의 마지막의 값을 pop해서 반환하고 배열의 크기를 1만큼 작게 합니다.

=begin original

If there are no elements in the array, returns the undefined value
(although this may happen at other times as well).  If ARRAY is
omitted, pops the C<@ARGV> array in the main program, and the C<@_>
array in subroutines, just like C<shift>.

=end original

지정된 배열에 요소가 없으면, 미정의값이 반환됩니다.
(그러나 이것은 다른 경우에도 발생할 수 있습니다)
ARRAY 가 생략되면, C<shift> 와 마찬가지로 메인 프로그램에서는 C<@ARGV>가 
서브루틴에서는 C<@_> 가 사용됩니다.

=item pos SCALAR
X<pos> X<match, position>

=item pos

=begin original

Returns the offset of where the last C<m//g> search left off for the variable
in question (C<$_> is used when the variable is not specified).  Note that
0 is a valid match offset.  C<undef> indicates that the search position
is reset (usually due to match failure, but can also be because no match has
yet been performed on the scalar). C<pos> directly accesses the location used
by the regexp engine to store the offset, so assigning to C<pos> will change
that offset, and so will also influence the C<\G> zero-width assertion in
regular expressions. Because a failed C<m//gc> match doesn't reset the offset,
the return from C<pos> won't change either in this case.  See L<perlre> and
L<perlop>.

=end original

대상의 변수에 대해서 앞의 C<m//g> 가 종료한 장소의 offset 을 반환합니다(
변수가 지정되지 않은 경우는 C<$_> 가 사용됩니다).
0은 유효한 매치 오프셋인 것에 주의해주세요.
C<undef> 는 검색위치가 리셋되는 것을 의미합니다(보통은 매치 실패가 원인입니다만
이 스칼라 값에 아직 매칭이 수행되지 않았기 때문일지도 모릅니다).
C<pos> 는 정규표현엔진이 대입은 offset 을 변경해서, 그런 변경은 
정규표현에 의한 C<\G> 제로폭 Assert 에도 영향을 줍니다.
C<m//gc> 매치에 실패해도 offset 은 리셋하지않기에, 
C<pos> 에서의 반환값은 어느쪽의 경우도 변경되지 않습니다.
L<perlre> 와 L<perlop> 를 참조해주세요.

=item print FILEHANDLE LIST
X<print>

=item print LIST

=item print

=begin original

Prints a string or a list of strings.  Returns true if successful.
FILEHANDLE may be a scalar variable name, in which case the variable
contains the name of or a reference to the filehandle, thus introducing
one level of indirection.  (NOTE: If FILEHANDLE is a variable and
the next token is a term, it may be misinterpreted as an operator
unless you interpose a C<+> or put parentheses around the arguments.)
If FILEHANDLE is omitted, prints by default to standard output (or
to the last selected output channel--see L</select>).  If LIST is
also omitted, prints C<$_> to the currently selected output channel.
To set the default output channel to something other than STDOUT
use the select operation.  The current value of C<$,> (if any) is
printed between each LIST item.  The current value of C<$\> (if
any) is printed after the entire LIST has been printed.  Because
print takes a LIST, anything in the LIST is evaluated in list
context, and any subroutine that you call will have one or more of
its expressions evaluated in list context.  Also be careful not to
follow the print keyword with a left parenthesis unless you want
the corresponding right parenthesis to terminate the arguments to
the print--interpose a C<+> or put parentheses around all the
arguments.

=end original

문자열이 문자열의 리스트를 출력합니다.
성공시에는 참을 반환합니다. FILEHANDLE 은 스칼라 변수이름이어도 되고, 
그 경우에는 그 겹누세 파일핸들 이름 또는 그 리퍼런스가 들어 있는 것으로 
취급되기 때문에, 일단계의 간접지정을 수행할 수 있습니다.
(주: FILEHANDLE 에 변수를 사용하고 다음 토큰이 "항"일 때에는 
 사이에 C<+> 을 놓든가, 인수의 앞뒤를 괄호로 감싸지 않으면 
잘못 해석될 수 있습니다).
FILEHANDLE 을 생략한 경우에는 표준출력(이나 마지막에 선택된 출력채널
-- L</select> 를 참조)에 출력합니다.
LIST 를 생략하면, C<$_> 를 현재 선택된 출력채널에 출력하는 것이 됩니다.
기본값의 출력 채널을 STDOUT 이외에 하고 싶다면, select 연산자를 
사용해주세요.
C<$,> 의 값이(만약 있다면) 각 LIST 요소의 사이에 출력됩니다.
print 의 인수는 LIST 이기때문에 LIST 안의 것은 
모든 리스트 컨텍스에서 평가됩니다.
서브루틴의 호출이 있으면, 리스트 컨텍스트에서 복수의 값을 반환할지도 모릅니다.
또, 모든 인수를 괄호로 감싸지 않으면, print 라는 키워드의 다음에 
열린괄호를 써서는 안됩니다.
"print" 와 인수의 사이에 C<+> 를 쓰거나 모든 인수를 괄호로 묶어주세요.

=begin original

Note that if you're storing FILEHANDLEs in an array, or if you're using
any other expression more complex than a scalar variable to retrieve it,
you will have to use a block returning the filehandle value instead:

=end original

만약 FILEHANDLE 을 배열에 보존하거나, 그것을 얻기위해 스칼라 변수보다 
복잡한 표현을 사용하고 있는 경우, 
대신에 그 값을 반환하ㄴ 블록을 사용할 필요가 있습니다:

    print { $files[$i] } "stuff\n";
    print { $OK ? STDOUT : STDERR } "stuff\n";

=item printf FILEHANDLE FORMAT, LIST
X<printf>

=item printf FORMAT, LIST

=begin original

Equivalent to C<print FILEHANDLE sprintf(FORMAT, LIST)>, except that C<$\>
(the output record separator) is not appended.  The first argument
of the list will be interpreted as the C<printf> format. See C<sprintf>
for an explanation of the format argument.  If C<use locale> is in effect,
and POSIX::setlocale() has been called, the character used for the decimal
separator in formatted floating point numbers is affected by the LC_NUMERIC
locale.  See L<perllocale> and L<POSIX>.

=end original

C<$\>(출력 레코드 구분자)를 추가하지 않는 것을 빼면, 
C<print FILEHANDLE sprintf(FORMAT, LIST)> 와 같습니다.
리스트의 맨처음 요소는 C<printf> 포맷으로 해석됩니다.
포맷 인수의 설명에 대해서는 C<sprintf> 를 참조해주세요.
C<use locale> 이 효력을 가지고 있어도, POSIX::setlocale() 이 호출되면,
소수점으로 사용된 문자는 LC_NUMERIC 로케일의 영향을 받습ㅣ다.
L<perllocale> 과 L<POSIX> 를 참조해주세요.

=begin original

Don't fall into the trap of using a C<printf> when a simple
C<print> would do.  The C<print> is more efficient and less
error prone.

=end original

단순한 C<print> 를 사용해야 하는 곳에서 C<printf> 를 사용해버리는 
함정에 걸리지 않도록 해주세요.
C<print> 는 보다 효율적이고, 잘못된 행동이 일어나기 어렵습니다.

=item prototype FUNCTION
X<prototype>

=begin original

Returns the prototype of a function as a string (or C<undef> if the
function has no prototype).  FUNCTION is a reference to, or the name of,
the function whose prototype you want to retrieve.

=end original

간접 프로토타입을 문자열로 반환합니다(함수에 프로토타입이 없는 경우는 
C<undef> 를 반환합니다).
FUNCTION 은 프로토타입을 얻고 싶은 함수의 이름, 또는 리퍼런스입니다.

=begin original

If FUNCTION is a string starting with C<CORE::>, the rest is taken as a
name for Perl builtin.  If the builtin is not I<overridable> (such as
C<qw//>) or if its arguments cannot be adequately expressed by a prototype
(such as C<system>), prototype() returns C<undef>, because the builtin
does not really behave like a Perl function.  Otherwise, the string
describing the equivalent prototype is returned.

=end original

FUNCTION 이 C<CORE::> 로 시작되는 경우, 남은 Perl 빌드인 이름으로 
취급됩니다.
이 빌드인이(C<qw//> 처럼) I<오버라이드가 가능하지 않은>,
또는 이 인수가(C<system>처럼) 프로토타입으로 적절히 기술할 수 없는 경우,
prototype() 은 C<undef> 를 반환합니다;
왜냐면 빌드인은 실제로 Perl 함수처럼 행동하지 않기때문입니다.
그 외에는 같은 프로토타입을 표현한 문자열이 반환됩니다.

=item push ARRAY,LIST
X<push> X<stack>

=begin original

Treats ARRAY as a stack, and pushes the values of LIST
onto the end of ARRAY.  The length of ARRAY increases by the length of
LIST.  Has the same effect as

=end original

ARRAY 를 스택으로 취급하고 LIST 안의 값을 ARRAY 의 끝에 푸쉬합니다.
ARRAY 의 크기는 LIST 의 길이의 분량만큼 크게 됩니다.
이것은,

    for $value (LIST) {
	$ARRAY[++$#ARRAY] = $value;
    }

=begin original

but is more efficient.  Returns the number of elements in the array following
the completed C<push>.

=end original

라고 하는 것과 같은 효과가 있습니다만, 보다 효율적입니다.
C<push> 의 처리종료 뒤의 배열의 요소수를 반환합니다.

=item q/STRING/

=item qq/STRING/

=item qr/STRING/

=item qx/STRING/

=item qw/STRING/

=begin original

Generalized quotes.  See L<perlop/"Regexp Quote-Like Operators">.

=end original

범용 인용입니다.
L<perlop"Regexp Quote-Like Operators"> 를 참조해주세요.

=item quotemeta EXPR
X<quotemeta> X<metacharacter>

=item quotemeta

=begin original

Returns the value of EXPR with all non-"word"
characters backslashed.  (That is, all characters not matching
C</[A-Za-z_0-9]/> will be preceded by a backslash in the
returned string, regardless of any locale settings.)
This is the internal function implementing
the C<\Q> escape in double-quoted strings.

=end original

EXPR 의 안의 모든 영숫자 캐릭터가 아닌 것을 백슬래쉬롤 
이스케이프한 것을 반환합니다
(즉, C</[A-Za-z_0-9]/> 에 매치하지 않은 모든 문자의 앞에는 
로케일에 상관없이 백슬래쉬가 전치됩니다).
이것은 쌍따옴표문자열로의 C<\Q> 이스케이프를 
구성하기 위한 내부함수입니다.

=begin original

If EXPR is omitted, uses C<$_>.

=end original

EXPR 이 생략되면, C<$_> 를 사용합니다.

=item rand EXPR
X<rand> X<random>

=item rand

=begin original

Returns a random fractional number greater than or equal to C<0> and less
than the value of EXPR.  (EXPR should be positive.)  If EXPR is
omitted, the value C<1> is used.  Currently EXPR with the value C<0> is
also special-cased as C<1> - this has not been documented before perl 5.8.0
and is subject to change in future versions of perl.  Automatically calls
C<srand> unless C<srand> has already been called.  See also C<srand>.

=end original

C<0> 이상 EXPR 의 값미만의 소수의 난수값을 반환합니다.
(EXPR 은 정수일 필요가 있습니다.)
EXPR 을 생략하면, C<!> 로 간주합니다.
현재, EXPR 에 값 C<0> 을 설정하면 C<1> 로 특별취급됩니다 - 
이것은 perl 5.8.0 이전에는 문서화되지 않고, 장래의 버젼의 Perl 에서는 
변경될 가능성이 있습니다.
C<srand> 가 이미 호출된 경우 이외는 자동적으로 C<srand> 함수르 호출합니다.
C<srand> 도 참조해주세요.

=begin original

Apply C<int()> to the value returned by C<rand()> if you want random
integers instead of random fractional numbers.  For example,

=end original

랜덤한 소수가 아닌, 랜덤한 정수가 필요한 경우,  C<rand()> 에서 
반환된 값에 C<int()> 를 적용해주세요.

    int(rand(10))

=begin original

returns a random integer between C<0> and C<9>, inclusive.

=end original

이것은 C<0> 에서 C<9> 의 값을 랜덤하게 반환합니다.

=begin original

(Note: If your rand function consistently returns numbers that are too
large or too small, then your version of Perl was probably compiled
with the wrong number of RANDBITS.)

=end original

(주: 만약 rand 함수가 이미 큰값만이나 작은 값만을 반환하려면, 
사용하고 있는 Perl 이 좋지 않은 RANDBITS 를 사용해서 컴파일 되어있을 
가능성이 있습니다)

=item read FILEHANDLE,SCALAR,LENGTH,OFFSET
X<read> X<file, read>

=item read FILEHANDLE,SCALAR,LENGTH

=begin original

Attempts to read LENGTH I<characters> of data into variable SCALAR
from the specified FILEHANDLE.  Returns the number of characters
actually read, C<0> at end of file, or undef if there was an error (in
the latter case C<$!> is also set).  SCALAR will be grown or shrunk 
so that the last character actually read is the last character of the
scalar after the read.

=end original

지정한 FILEHANDLE 에서 변수 SCALAR 에 LENGTH I<문자> 의 
데이터를 읽어들입니다.
실제로 읽어들인 문자수, 파일끝단의 경우는 C<0>, 에러의 경우는 undef 중 
어느것을 반환합니다(후자의 경우 C<$!> 도 설정됩니다).
SCALAR 는 늘어지고 작아지고 하기 때문에, 읽은 뒤에는 
실제로 읽어들인 마지막의 문자가 스칼라의 마지막의 문자가 됩니다.

=begin original

An OFFSET may be specified to place the read data at some place in the
string other than the beginning.  A negative OFFSET specifies
placement at that many characters counting backwards from the end of
the string.  A positive OFFSET greater than the length of SCALAR
results in the string being padded to the required size with C<"\0">
bytes before the result of the read is appended.

=end original

OFFSET 을 지정하면, 문자열의 맨앞 이외의 장소에서 읽기를 수행할 수 있습니다.
음수의 OFFSET을 지정하면 문자열을 마지막부터 약방향으로 몇 문자째인가를 셉니다.
SCALAR 의 길이보다 크고, 양수의 OFFSET 을 지정하면 문자열은 
읽기의 결과가 추가되기 전에, 필요한 사이즈까지 C<"\0"> 의 바이트로 
Padding 됩니다.

=begin original

The call is actually implemented in terms of either Perl's or system's
fread() call.  To get a true read(2) system call, see C<sysread>.

=end original

이 함수는 Perl 이 시스템의 fread() 함수를 사용해서 구성했습니다.
진짜 read(2) 시스템 호출을 이용하기위해서는 C<sysread> 를 참조해주세요.

=begin original

Note the I<characters>: depending on the status of the filehandle,
either (8-bit) bytes or characters are read.  By default all
filehandles operate on bytes, but for example if the filehandle has
been opened with the C<:utf8> I/O layer (see L</open>, and the C<open>
pragma, L<open>), the I/O will operate on UTF-8 encoded Unicode
characters, not bytes.  Similarly for the C<:encoding> pragma:
in that case pretty much any characters can be read.

=end original

I<문자> 에 관한 주의: 파일핸들의 상태에 의해 (8비트의) 바이트나 문자가 
읽혀집니다.
기본값으로는 모든 파일핸들은 바이트를 처리합니다만, 예를들어 파일핸들이
C<:utf8> I/O 층(L</open>, C<open> 프라그마, L<open> 을 참조해주세요)에서
열린 경우, I/O 는 바이트가 아니라 UTF-8 인코드된 Unicode 문자를 조작합니다.
C<:encoding> 프라그마도 같습니다: 
이 경우, 대부분 모든 문자를 읽어들일 수 있습니다.

=item readdir DIRHANDLE
X<readdir>

=begin original

Returns the next directory entry for a directory opened by C<opendir>.
If used in list context, returns all the rest of the entries in the
directory.  If there are no more entries, returns an undefined value in
scalar context or a null list in list context.

=end original

C<opendir> 로 오픈한 디렉토리에서 다음의 디렉토리 엔트리를 반환합니다.
리스트 컨텍스트로 사용하면, 그 디렉토리의 남의 엔트리를 반환합니다.
엔트리가 남아있지 않은 경우에는 스칼라 컨텍스트에서는 미정의값을,
리스트 컨텍스트에서는 빈 리스트를 반환합니다.

=begin original

If you're planning to filetest the return values out of a C<readdir>, you'd
better prepend the directory in question.  Otherwise, because we didn't
C<chdir> there, it would have been testing the wrong file.

=end original

C<readdir> 의 반환값을 파일테스트로 사용하려고 계획하고 있다면, 
맨 앞에 디렉토리를 붙일 필요가 있습니다.
그렇지 않으면, 여기에서는 C<chdir> 은 하지 않기때문에,
틀린 파일을 테스트해버릴 수 있을 겁니다.

    opendir(DIR, $some_dir) || die "can't opendir $some_dir: $!";
    @dots = grep { /^\./ && -f "$some_dir/$_" } readdir(DIR);
    closedir DIR;

=item readline EXPR

=item readline
X<readline> X<gets> X<fgets>

=begin original

Reads from the filehandle whose typeglob is contained in EXPR (or from
*ARGV if EXPR is not provided).  In scalar context, each call reads and
returns the next line, until end-of-file is reached, whereupon the
subsequent call returns undef.  In list context, reads until end-of-file
is reached and returns a list of lines.  Note that the notion of "line"
used here is however you may have defined it with C<$/> or
C<$INPUT_RECORD_SEPARATOR>).  See L<perlvar/"$/">.

=end original

형태 글로브가 EXPR(EXPR 이 없는 경우는 *ARGV) 에 포함된 파일핸들에서 
읽어들입니다.
스칼라 컨텍스트에서는 호출마다 한줄 읽어서 반환합니다.
파일의 마지막까지 읽어들였으면, 이후의 호출에서는 undef 를 반환합니다.
리스트 컨텍스트에서는 파일의 마지막까지 읽어들여서 줄의 리스트를 반환합니다.
여기에서의 "줄" 이라는 것은 C<$/> 또는 C<$INPUT_RECORD_SEPARATOR> 로 
정의되는 것에 주의해주세요. L<perlvar/"$/"> 도 참조해주세요.

=begin original

When C<$/> is set to C<undef>, when readline() is in scalar
context (i.e. file slurp mode), and when an empty file is read, it
returns C<''> the first time, followed by C<undef> subsequently.

=end original

C<$/> 에 C<undef> 를 설정한 경우는 readline() 은 스칼라 컨텍스트
(즉 파일흡입모드)가 되고, 
빈 파일을 읽어들인 경우는 맨처음은 C<''> 를 반환하고, 
그 이후는 C<undef> 를 반환합니다.

=begin original

This is the internal function implementing the C<< <EXPR> >>
operator, but you can use it directly.  The C<< <EXPR> >>
operator is discussed in more detail in L<perlop/"I/O Operators">.

=end original

이것은 C<< <EXPR> >> 연산자를 구성하고 있는 내부함수입니다만, 
직접 사용할 수도 있습니다.
C<< <EXPR> >> 연산자에 대해서 보다 자세한 내용에 대해서는 
L<perlop/"I/O Operators"> 에서 의논되어 있습니다.

    $line = <STDIN>;
    $line = readline(*STDIN);		# same thing

=begin original

If readline encounters an operating system error, C<$!> will be set with the
corresponding error message.  It can be helpful to check C<$!> when you are
reading from filehandles you don't trust, such as a tty or a socket.  The
following example uses the operator form of C<readline>, and takes the necessary
steps to ensure that C<readline> was successful.

=end original

readline 이 OS 의 시스템 에러가 되면 C<$!> 에 대응하는 에러 메시지가 
설정됩니다.
tty 나 소켓같은 신뢰할 수 없는 파일핸들에서 읽을 때에는 C<$!> 를 
체크하는 것이 도움이 됩니다.
아래의 예제는 연산자의 형태의 c<readline> 를 사용하고 있고, C<readline> 이
성공한 것을 확실히 하기 위해 필요한 스텝을 실행하고 있습니다.

    for (;;) {
        undef $!;
        unless (defined( $line = <> )) {
            die $! if $!;
            last; # reached EOF
        }
        # ...
    }

=item readlink EXPR
X<readlink>

=item readlink

=begin original

Returns the value of a symbolic link, if symbolic links are
implemented.  If not, gives a fatal error.  If there is some system
error, returns the undefined value and sets C<$!> (errno).  If EXPR is
omitted, uses C<$_>.

=end original

심볼릭 링크가 구성되어 있으면, 
심볼릭 링크의 값을 반환합니다.
구성되어 있지 않은 때에는 치명적인 에러가 됩니다.
뭔가의 시스템 에러가 검출되면, 미정의값을 반환하고 C<$!> (errno) 를 설정합니다.
EXPR 을 생략하면, C<$_> 를 사용합니다.

=item readpipe EXPR

=item readpipe
X<readpipe>

=begin original

EXPR is executed as a system command.
The collected standard output of the command is returned.
In scalar context, it comes back as a single (potentially
multi-line) string.  In list context, returns a list of lines
(however you've defined lines with C<$/> or C<$INPUT_RECORD_SEPARATOR>).
This is the internal function implementing the C<qx/EXPR/>
operator, but you can use it directly.  The C<qx/EXPR/>
operator is discussed in more detail in L<perlop/"I/O Operators">.
If EXPR is omitted, uses C<$_>.

=end original

EXPR 이 시스템커맨드로 실행됩니다.
커맨드의 표준출력의 내용이 반환됩니다.
스칼라 컨텍스트에서는 단일의 (내부적으로 복수행의) 문자열을 반환합니다.
리스트 컨텍스트에서는 줄의 리스트를 반환합니다.
(단, 줄은 C<$/> 또는 C<$INPUT_RECORD_SEPARATOR> 로 정의됩니다).
이것은 C<qw/EXPR/> 연산자를 구성하는 내부함수이지만, 직접 사용할 수도 있습니다.
C<qw/EXPR/> 연산자는 L<perlop/"I/O Operators"> 보다 자세하게 기술되어 있습니다.
EXPR 을 생략하면 C<$_> 를 사용합니다.

=item recv SOCKET,SCALAR,LENGTH,FLAGS
X<recv>

=begin original

Receives a message on a socket.  Attempts to receive LENGTH characters
of data into variable SCALAR from the specified SOCKET filehandle.
SCALAR will be grown or shrunk to the length actually read.  Takes the
same flags as the system call of the same name.  Returns the address
of the sender if SOCKET's protocol supports this; returns an empty
string otherwise.  If there's an error, returns the undefined value.
This call is actually implemented in terms of recvfrom(2) system call.
See L<perlipc/"UDP: Message Passing"> for examples.

=end original

소켓 상에서의 메시지를 수신합니다.
지정된 파일핸들 SOCKET 에서 변수 SCALAR 에 
LENGTH 문자의 데이터를 읽어들이려고 합니다.
SCALAR 는 실제로 읽혀진 길이에 의해 커지거나 작아지거나합니다.
같은 이름의 시스템 호출과 마찬가지로 FLAGS 를 사용합니다.
SOCKET 의 프르토콜을 지원하고 있으면, 수신측의 주소를 반환합니다.
에러 발생시에는 미정의값을 반환합니다.
실제로는 C 의 recvfrom(2) 를 반환합니다.
예제에 대해서는 L<perlipc"UDP: Message Passing"> 을 참조해주세요.

=begin original

Note the I<characters>: depending on the status of the socket, either
(8-bit) bytes or characters are received.  By default all sockets
operate on bytes, but for example if the socket has been changed using
binmode() to operate with the C<:encoding(utf8)> I/O layer (see the
C<open> pragma, L<open>), the I/O will operate on UTF-8 encoded Unicode
characters, not bytes.  Similarly for the C<:encoding> pragma: in that
case pretty much any characters can be read.

=end original

I<문자> 에 관한 주의: 소켓의 상태에 따라, (8비트의) 바이트나 문자ㄹ 수신합니다.
기본값으로는 모든 소켓은 바이트를 수신하지만, 예를들어 소켓이 binmode() 로
C<:encoding(utf8)> I/O 층(C<open> 프라그마, L<open> 을 참조해주세요) 을 
사용하도록 지정된 경우, I/O 는 바이트가 아닌 UTF-8 인코드된 Unicode 를
조작합니다. C<:encoding> 프라그마도 마찬가지입니다:
이 경우, 대부분 모든 문자를 읽을 수 있습니다.

=item redo LABEL
X<redo>

=item redo

=begin original

The C<redo> command restarts the loop block without evaluating the
conditional again.  The C<continue> block, if any, is not executed.  If
the LABEL is omitted, the command refers to the innermost enclosing
loop.  Programs that want to lie to themselves about what was just input 
normally use this command:

=end original

C<redo> 커맨드는 조건을 재평가하지않고, 루프 블록의 시작부터 한번 더 실행을 
시작합니다.
C<continue> 블록이 있어도 실행되지 않습니다.
LABEL 이 생략되면, 이 커맨드는 제일 안쪽의 루프를 참조합니다.
이 커맨드는 통상, 자신으로의 입력을 속이기 위해 사용합니다.

    # a simpleminded Pascal comment stripper
    # (warning: assumes no { or } in strings)
    LINE: while (<STDIN>) {
	while (s|({.*}.*){.*}|$1 |) {}
	s|{.*}| |;
	if (s|{.*| |) {
	    $front = $_;
	    while (<STDIN>) {
		if (/}/) {	# end of comment?
		    s|^|$front\{|;
		    redo LINE;
		}
	    }
	}
	print;
    }

=begin original

C<redo> cannot be used to retry a block which returns a value such as
C<eval {}>, C<sub {}> or C<do {}>, and should not be used to exit
a grep() or map() operation.

=end original

C<redo> 은 C<eval {}>, C<sub {}>, C<do {}> 처럼 값을 반환하는 블록을 
반환하는 것에는 사용할 수 없습니다. 또, grep() 이나 map() 조작에서 
빠지는 것에 사용해야하는 것도 아닙니다.

=begin original

Note that a block by itself is semantically identical to a loop
that executes once.  Thus C<redo> inside such a block will effectively
turn it into a looping construct.

=end original

블록 자신은 한번만 실행되는 루프와 문법적으로 같은 것에 주의해주세요.
따라서, 블록 안에서 C<redo> 를 사용하는 것으로 효과적으로 루프구조로 
변환합니다.

=begin original

See also L</continue> for an illustration of how C<last>, C<next>, and
C<redo> work.

=end original

C<last>, C<next>, C<redo> 가 어떻게 움직이는 가에 대해서는 
L</continue> 를 참조해주세요.

=item ref EXPR
X<ref> X<reference>

=item ref

=begin original

Returns a non-empty string if EXPR is a reference, the empty
string otherwise. If EXPR
is not specified, C<$_> will be used.  The value returned depends on the
type of thing the reference is a reference to.
Builtin types include:

=end original

EXPR 이 리퍼런스라면, 공백이 아닌 문자열을 반환하고, 그렇지 않으면 빈문자열을
반환합니. EXPR 이 지정되지 않으면, C<$_> 이 사용됩니다.
반환되는 값은, 리퍼런스가 참조하는 것의 형태에 의존합니다.
내장 형태에는 아래와 같은 것들이 있습니다.

    SCALAR
    ARRAY
    HASH
    CODE
    REF
    GLOB
    LVALUE
    FORMAT
    IO
    VSTRING
    Regexp

=begin original

If the referenced object has been blessed into a package, then that package
name is returned instead.  You can think of C<ref> as a C<typeof> operator.

=end original

참조된 오브젝트가 어떤 패키지에 bless 된 것이면 이 대입에는 
그 패키지 이름이 반환됩니다.
C<ref> 는 C<typeof> 연산자처럼 생각할 수 있습니다.

    if (ref($r) eq "HASH") {
	print "r is a reference to a hash.\n";
    }
    unless (ref($r)) {
	print "r is not a reference at all.\n";
    }

=begin original

The return value C<LVALUE> indicates a reference to an lvalue that is not
a variable. You get this from taking the reference of function calls like
C<pos()> or C<substr()>. C<VSTRING> is returned if the reference points
to a L<version string|perldata/"Version Strings">.

=end original

반환값 C<LVALUE> 는 변수가 아닌 좌변치로의 리퍼런스를 나냅니다.
이것은 C<pos()> 나 c<substr()> 처럼 함수호출의 리퍼런스에서 얻을 수 있습니다.
C<VSTRING> 은 리퍼런스가 L<version string|perldata/"Version Strings"> 을 
지정하는 경우에 반환됩니다.

=begin original

The result C<Regexp> indicates that the argument is a regular expression
resulting from C<qr//>.

=end original

C<Regexp> 라는 결과는 h 기수가 C<qr//> 에서의 결과인 정규표현인 것을 
의미합니다.

=begin original

See also L<perlref>.

=end original

L<perlref> 도 참조해주세요.

=item rename OLDNAME,NEWNAME
X<rename> X<move> X<mv> X<ren>

=begin original

Changes the name of a file; an existing file NEWNAME will be
clobbered.  Returns true for success, false otherwise.

=end original

파일의 이름을 변경합니다.
NEWNAME 이라는 파일이 이미 존재한 경우, 덮어쓰여질 지도 모릅니다.
성공시에는 참, 실패시에는 거짓을 반환합니다.

=begin original

Behavior of this function varies wildly depending on your system
implementation.  For example, it will usually not work across file system
boundaries, even though the system I<mv> command sometimes compensates
for this.  Other restrictions include whether it works on directories,
open files, or pre-existing files.  Check L<perlport> and either the
rename(2) manpage or equivalent system documentation for details.

=end original

이 함수의 행동은 시스템의 구성에 크게 의존해서 달라집니다.
보통은 파일시스템에 따라 경로이름을 바꿔 붙일 수는 없습니다.
시스템의 I<mv> 가 이것을 보완하고 있는 경우에도 그렇습니다.
그 외의 제한에는 디렉토리, 오픈하고 있는 파일, 이미 존재하고 있는 
파일에 대해서 사용할 수 있는 가 등을 포함합니다.
자세한 내용은 L<perlport> 및 rename(2) man 페이지 또는 같은 시스템 문서를 
참조해주세요.

=begin original

For a platform independent C<move> function look at the L<File::Copy>
module.

=end original

플랫폼에 의존하지 않는 C<move> 함수에 대해서는 L<File::Copy> 모듈을 
참조해주세요.

=item require VERSION
X<require>

=item require EXPR

=item require

=begin original

Demands a version of Perl specified by VERSION, or demands some semantics
specified by EXPR or by C<$_> if EXPR is not supplied.

=end original

VERSION 에서 지정된 Perl 의 버젼을 요구하거나 
EXPR (생략시에는 C<$_>) 에 따라 지정된 몇개의 동작을 요구합니다.

=begin original

VERSION may be either a numeric argument such as 5.006, which will be
compared to C<$]>, or a literal of the form v5.6.1, which will be compared
to C<$^V> (aka $PERL_VERSION).  A fatal error is produced at run time if
VERSION is greater than the version of the current Perl interpreter.
Compare with L</use>, which can do a similar check at compile time.

=end original

VERSION 은 5.006 같은 숫자값(C<$]> 와 비교됩니다)이나 v5.6.1 의 형태
(C<$^V ($PERL_VERSION) 과 비교됩니다)로 지정합니다.
VERSION 이 Perl 의 현재의 버젼보다 크면 실행시에 치명적 에러가 발생합니다.
L</use> 와 닯아 있지만, 이것은 컴파일 시에 체크됩니다.

=begin original

Specifying VERSION as a literal of the form v5.6.1 should generally be
avoided, because it leads to misleading error messages under earlier
versions of Perl that do not support this syntax.  The equivalent numeric
version should be used instead.

=end original

VERSION 에 v5.6.1 의 형태의 리터럴을 지정하는 것은 일반적으로 피해야합니다;
왜냐면, 이 문법을 지원하지 않는 Perl 의 초기버젼에서는 오해할 수 있는 
에러메시지가 나오기 때문입니다.
대신에 같은 숫자표현을 사용해야합니다.

    require v5.6.1;	# run time version check
    require 5.6.1;	# ditto
    require 5.006_001;	# ditto; preferred for backwards compatibility

=begin original

Otherwise, C<require> demands that a library file be included if it
hasn't already been included.  The file is included via the do-FILE
mechanism, which is essentially just a variety of C<eval> with the
caveat that lexical variables in the invoking script will be invisible
to the included code.  Has semantics similar to the following subroutine:

=end original

그 이외의 경우에는 C<require> 는 이미 읽어들이지 않은 때에 읽어들인 
라이브러리 파일을 요구하는 것이 됩니다.
그 파일은 기본적으로는 c<eval> 의 일종이고, do-FILE 에 따라 
읽혀지지만, 기동한 스크립트의 렉시컬 변수는 읽어들인 코드에서 
보이지 않는다는 결점이 있습니다.
의미적으로는 다음과 같은 서브루틴과 같은 것입니다;

    sub require {
       my ($filename) = @_;
       if (exists $INC{$filename}) {
           return 1 if $INC{$filename};
           die "Compilation failed in require";
       }
       my ($realfilename,$result);
       ITER: {
           foreach $prefix (@INC) {
               $realfilename = "$prefix/$filename";
               if (-f $realfilename) {
                   $INC{$filename} = $realfilename;
                   $result = do $realfilename;
                   last ITER;
               }
           }
           die "Can't find $filename in \@INC";
       }
       if ($@) {
           $INC{$filename} = undef;
           die $@;
       } elsif (!$result) {
           delete $INC{$filename};
           die "$filename did not return true value";
       } else {
           return $result;
       }
    }

=begin original

Note that the file will not be included twice under the same specified
name.

=end original

파일은 같은 이름에서 2번 읽어들이지는 않는 다는 것에도 주의해주세요.

=begin original

The file must return true as the last statement to indicate
successful execution of any initialization code, so it's customary to
end such a file with C<1;> unless you're sure it'll return true
otherwise.  But it's better just to put the C<1;>, in case you add more
statements.

=end original

초기화 코드의 실행이 잘 된 것을 나타내기 위해서는 파일은 참을 반환하지 
않으면 안되기때문에, 참을 반환하도록 되어 있는 자신이 있는 경우를 빼고는
파일의 마지막에 C<1;> 라고 쓰는 것이 습관입니다.
실행문을 추가하는 경우에 대비해서 C<1;> 라고 쓰는 편이 좋을 겁니다.

=begin original

If EXPR is a bareword, the require assumes a "F<.pm>" extension and
replaces "F<::>" with "F</>" in the filename for you,
to make it easy to load standard modules.  This form of loading of
modules does not risk altering your namespace.

=end original

EXPR 이 bareword 인 때에는 표준 모듈의 로드를 간단히 하다록 
require 는 확장자가 "F<.pm>" 이고, "F<::>" 를 "F</>" 로 바꾼 것이 
파일이름인 것으로 가정합니다. 이 형식의 모듈로드는 이름공간을 
변경해버리는 위험은 없습니다.

=begin original

In other words, if you try this:

=end original

바꿔말해서, 아래처럼 하면:

        require Foo::Bar;    # a splendid bareword

=begin original

The require function will actually look for the "F<Foo/Bar.pm>" file in the
directories specified in the C<@INC> array.

=end original

require 함수는 C<@INC> 배열에서 지정된 디렉토리에 있는 "F<Foo/Bar.pm>" 
파일을 찾습니다.

=begin original

But if you try this:

=end original

그러나 아래처럼 하면:

        $class = 'Foo::Bar';
        require $class;	     # $class is not a bareword
    #or
        require "Foo::Bar";  # not a bareword because of the ""

=begin original

The require function will look for the "F<Foo::Bar>" file in the @INC array and
will complain about not finding "F<Foo::Bar>" there.  In this case you can do:

=end original

require 함수는 @INC 배열의 "F<Foo:;Bar>" 파일을 찾고, 
아마 그곳에 "F<Foo::Bar>" 가 없으면 투정를 부릴지도 모르겠죠.
이런 경우에는 아래처럼 합니다:

        eval "require $class";

=begin original

Now that you understand how C<require> looks for files in the case of a
bareword argument, there is a little extra functionality going on behind
the scenes.  Before C<require> looks for a "F<.pm>" extension, it will
first look for a similar filename with a "F<.pmc>" extension. If this file
is found, it will be loaded in place of any file ending in a "F<.pm>"
extension.

=end original

인수가 bareword 인 경우, C<require> 가 어떻게 파일을 찾는 가를 이해해 주세요;
보이지 않는 곳에 조금 추가한 기능이 있습니다.
C<require> 가 확장자 "F<.pm>"의 파일을 찾기 전에, 우선 확장자 "F<.pmc>" 를
가진 파일을 탐색합니다.
이 파일을 찾으면, 이 파일이 확장자 "F<.pm>" 대신에 읽혀집니다.

=begin original

You can also insert hooks into the import facility, by putting directly
Perl code into the @INC array.  There are three forms of hooks: subroutine
references, array references and blessed objects.

=end original

@INC 배열에 직접 Perl 코드를 넣음으로 임포트 기능에 후크를 투입할 수 있습니다.
3 종료의 후크가 있습니다: 서브루틴 리퍼런스, 배열 리퍼런스, bless 된 
오브젝트입니다.

=begin original

Subroutine references are the simplest case.  When the inclusion system
walks through @INC and encounters a subroutine, this subroutine gets
called with two parameters, the first being a reference to itself, and the
second the name of the file to be included (e.g. "F<Foo/Bar.pm>").  The
subroutine should return nothing, or a list of up to three values in the
following order:

=end original

서브루틴으로의 리퍼런스는 제일 단순한 경우입니다.
include 기능이 @INC 를 통해서 서브루틴과 만난 경우, 이 서브루틴은 
2개의 인수와 함께 호출됩니다;
첫번째는 자신의 리퍼런스, 두번째는 include 된 파일이름("F<Foo/Bar.pm>" 등)
입니다. 서브루틴은 C<undef> 나, include 하는 파일이 읽혀지는 파일핸들을 
반환합니다.
서브루틴은 아무것도 반환하지 않든가, 아래의 순서로 최대 3개의 값을 가진 
리스트를 반환합니다.

=over

=item 1

=begin original

A filehandle, from which the file will be read.  

=end original

파일이 읽혀지는 파일핸들.

=item 2

=begin original

A reference to a subroutine. If there is no filehandle (previous item),
then this subroutine is expected to generate one line of source code per
call, writing the line into C<$_> and returning 1, then returning 0 at
"end of file". If there is a filehandle, then the subroutine will be
called to act a simple source filter, with the line as read in C<$_>.
Again, return 1 for each valid line, and 0 after all lines have been
returned.

=end original

서브루틴으로의 리퍼런스.
(하나 앞의 아이템인) 파일핸들이 없는 경우, 1 을 써넣어서 반환하고, 
그리고 "파일끝단"에서 0을 반환하는 것으로 상정됩니다.
파일핸들이 있는 경우, 서브루틴은 단순한 소스필터로 행동하도록 호출되고,
줄은 C<$_> 에서 읽혀집니다.
다시, 유효한 행마다 1을 반환하고, 모든 행을 반환한 뒤에는 0을 반환합니다.

=item 3

=begin original

Optional state for the subroutine. The state is passed in as C<$_[1]>. A
reference to the subroutine itself is passed in as C<$_[0]>.

=end original

서브루틴을 위한 상태(옵션).
상태는 C<$_[1]> 로 건네집니다.
서브루틴으로의 리퍼런스 자신은 C<$_[0]> 으로 건네집니다.

=back

=begin original

If an empty list, C<undef>, or nothing that matches the first 3 values above
is returned then C<require> will look at the remaining elements of @INC.
Note that this file handle must be a real file handle (strictly a typeglob,
or reference to a typeglob, blessed or unblessed) - tied file handles will be
ignored and return value processing will stop there.

=end original

빈리스트, C<undef> 또는 위의 최초의 3개의 값 중 어느것도 일치하지 않는 것이
반환되면, C<require> 는 @INC 의 남은 요소를 봅니다.
이 파일핸들은 실제 파일핸들(엄밀하게는 형태 glob, 형태 glob 로의 리퍼런스,
bless 되어 있는지 아닌지)일 필요가 있습니다.
tie 된 파일핸들은 무시되고, 반환값의 처리는 거기서 정지합니다.

=begin original

If the hook is an array reference, its first element must be a subroutine
reference.  This subroutine is called as above, but the first parameter is
the array reference.  This enables to pass indirectly some arguments to
the subroutine.

=end original

후크가 배열의 리퍼런스인 경우, 그 최초의 요소는 서브루틴으로의 리퍼런스가 
아니면 안됩니다.
이 서브루틴은 위에 기술한 것처럼 호출되지만, 첫번째 인수는 배열의 리퍼런스
입니다. 이에 따라 간접적으로 서브루틴에 인수를 넘길 수 있습니다.

=begin original

In other words, you can write:

=end original

바꿔말해서, 아래처럼 쓰거나:

    push @INC, \&my_sub;
    sub my_sub {
	my ($coderef, $filename) = @_;	# $coderef is \&my_sub
	...
    }

=begin original

or:

=end original

또는 아래처럼 쓸 수 있습니다:

    push @INC, [ \&my_sub, $x, $y, ... ];
    sub my_sub {
	my ($arrayref, $filename) = @_;
	# Retrieve $x, $y, ...
	my @parameters = @$arrayref[1..$#$arrayref];
	...
    }

=begin original

If the hook is an object, it must provide an INC method that will be
called as above, the first parameter being the object itself.  (Note that
you must fully qualify the sub's name, as unqualified C<INC> is always forced
into package C<main>.)  Here is a typical code layout:

=end original

후크가 오브젝트인 경우, INC 메소드를 제공할 필요가 있습니다;
그것이 첫번째 인수를 오브젝트 자신으로 위에 기술한 대로 호출됩니다.
(수식되어 있지 않은 C<INC> 는 항상 패키지 C<main> 으로 강제되기 때문에 
서브루틴 이름은 완전수식할 필요가 있는 것에 주의해주세요.)
아래는 전형적인 코드 레이아웃입니다:

    # In Foo.pm
    package Foo;
    sub new { ... }
    sub Foo::INC {
	my ($self, $filename) = @_;
	...
    }

    # In the main program
    push @INC, new Foo(...);

=begin original

Note that these hooks are also permitted to set the %INC entry
corresponding to the files they have loaded. See L<perlvar/%INC>.

=end original

이 후크들은 읽혀진 파일에 대한 %INC 엔트리를 설정하는 것도 허가하는 것에 
주의하세요.
L<perlvar/%INC> 를 참조해주세요.

=begin original

For a yet-more-powerful import facility, see L</use> and L<perlmod>.

=end original

보다 강력한 import 기능에 대해서는 이 문서의 L</use> 의 항과 
L<perlmod> 를 참조해주세요.

=item reset EXPR
X<reset>

=item reset

=begin original

Generally used in a C<continue> block at the end of a loop to clear
variables and reset C<??> searches so that they work again.  The
expression is interpreted as a list of single characters (hyphens
allowed for ranges).  All variables and arrays beginning with one of
those letters are reset to their pristine state.  If the expression is
omitted, one-match searches (C<?pattern?>) are reset to match again.  Resets
only variables or searches in the current package.  Always returns
1.  Examples:

=end original

통상, 루프의 끝에 변수를 클리어해서 C<??> 검색을 다시 동작하도록 리셋하기위해
C<continue> 블록에서 사용됩니다.
EXPR 은 문자를 나열한 것(범위를 지정하는 것에 하이픈을 사용할 수 있습니다)으로
해석됩니다.
이름이 그 문자중 어느 것으로 시작되는 변수나 배열은 최초의 상태로 리셋됩니다.
EXPR 을 생략하면, 첫번째 검색 (C<?PATTERN?>) 을 다시 매치하도록 리셋할 수 있습니다.
최근 패키지의 변수 혹은 검색만이 리셋됩니다.
항상 1을 반환합니다.
예제:

    reset 'X';		# reset all X variables
    reset 'a-z';	# reset lower case variables
    reset;		# just reset ?one-time? searches

=begin original

Resetting C<"A-Z"> is not recommended because you'll wipe out your
C<@ARGV> and C<@INC> arrays and your C<%ENV> hash.  Resets only package
variables--lexical variables are unaffected, but they clean themselves
up on scope exit anyway, so you'll probably want to use them instead.
See L</my>.

=end original

reset C<"A-Z"> 라고 하면 C<@ARGV>, C<@INC> 배열이나 C<%ENV> 해쉬도 
없어지기 때문에, 관두는 편이 좋습니다.
패키지 변수만이 리셋됩니다.
렉시컬 변수는 영향을 받지 않지만, 영역에서 벗어나면 자동적으로 
깨끗하게 되기때문에, 이제부터는 이쪽을 사용하는 편이 좋을 겁니다.
L</my> 도 참조해주세요.

=item return EXPR
X<return>

=item return

=begin original

Returns from a subroutine, C<eval>, or C<do FILE> with the value
given in EXPR.  Evaluation of EXPR may be in list, scalar, or void
context, depending on how the return value will be used, and the context
may vary from one execution to the next (see C<wantarray>).  If no EXPR
is given, returns an empty list in list context, the undefined value in
scalar context, and (of course) nothing at all in a void context.

=end original

서브루틴, C<eval>, C<do FILE> 에서 EXPR 로 주어진 값을 가지고 리턴합니다.
EXPR 의 평가는 반환값이 어떻게 사용되는 가에 의해 리스트, 스칼라,
무효 컨텍스트가 됩니다.
또 컨텍스트는 실행마다 바뀝니다(C<wantarray> 를 참조해주세요).
EXPR 이 지정되지 않은 경우, 리스트 컨텍스트에서는 빈 리스트를 
스칼라 컨텍스트에서는 미정의값을 반환합니다.
그리고(물론) 무효 컨텍스트에서는 아무것도 반환하지 않습니다.

=begin original

(Note that in the absence of an explicit C<return>, a subroutine, eval,
or do FILE will automatically return the value of the last expression
evaluated.)

=end original

(서브루틴, eval, do FILE 에 명시적으로 C<return> 이 없으면, 
마지막에 평가된 값으로 자동적으로 return 합니다)

=item reverse LIST
X<reverse> X<rev> X<invert>

=begin original

In list context, returns a list value consisting of the elements
of LIST in the opposite order.  In scalar context, concatenates the
elements of LIST and returns a string value with all characters
in the opposite order.

=end original

리스트 컨텍스트에서는 LIST 를 구성하는 요소를 역순으로 나열한 리스트를 
반환합니다.
스칼라 컨텍스트에서는 LIST 의 요소를 연결해서 모든 문자를 거꾸로 나열한 
문자열을 반환합니다.

    print reverse <>;		# line tac, last line first

    undef $/;			# for efficiency of <>
    print scalar reverse <>;	# character tac, last line tsrif

=begin original

Used without arguments in scalar context, reverse() reverses C<$_>.

=end original

스칼라컨텍스트에서는 인수없 사용하면 reverse() 는 C<$_> 를 역순으로 합니다.

=begin original

This operator is also handy for inverting a hash, although there are some
caveats.  If a value is duplicated in the original hash, only one of those
can be represented as a key in the inverted hash.  Also, this has to
unwind one hash and build a whole new one, which may take some time
on a large hash, such as from a DBM file.

=end original

이 연산자는 해쉬의 역순으로 하는 것에도 편리하지만, 몇가지 약점이 있습니다.
원래 해쉬로 값을 중복하면 그것들 중 하나만이 역순이 된 해쉬의 값으로 
표현됩니다.
또, 이것은 하나의 해쉬를 남겨두고 완전히 새로운 해쉬를 만들기 때문에, 
DBM 파일에서 처럼 큰 해쉬에서는 조금 시간이 걸립니다.

    %by_name = reverse %by_address;	# Invert the hash

=item rewinddir DIRHANDLE
X<rewinddir>

=begin original

Sets the current position to the beginning of the directory for the
C<readdir> routine on DIRHANDLE.

=end original

DIRHANDLE 에 대한 C<readdir> 루틴ㅢ 현재위치를 디렉토리의 최초에 설정합니다.

=item rindex STR,SUBSTR,POSITION
X<rindex>

=item rindex STR,SUBSTR

=begin original

Works just like index() except that it returns the position of the I<last>
occurrence of SUBSTR in STR.  If POSITION is specified, returns the
last occurrence beginning at or before that position.

=end original

STR 안에서 I<마지막에> 발견한 SUBSTR 의 위치를 반환하는 것을 빼고, 
index() 처럼 동작합니다.
POSITION 을 지정하면, 그 위치에서 시작하거나 그 위치보다 앞의, 
마지막의 위치를 반환합니다.

=item rmdir FILENAME
X<rmdir> X<rd> X<directory, remove>

=item rmdir

=begin original

Deletes the directory specified by FILENAME if that directory is
empty.  If it succeeds it returns true, otherwise it returns false and
sets C<$!> (errno).  If FILENAME is omitted, uses C<$_>.

=end original

FILENAME 에서 지정한 디렉토리가 비어 있을 경우, 그 디렉토리를 제거합니다.
성공시에는 참을 반환하고, 실패시에는 거짓을 반환하고, C<$!> (errno) 을 설정합니다. 
FILENAME 을 생략한 경우에는 C<$_> 을 사용합니다.

=begin original

To remove a directory tree recursively (C<rm -rf> on unix) look at
the C<rmtree> function of the L<File::Path> module.

=end original

디렉토리 트리를 재귀적으로 삭제하고 싶은 (unix 에서의 C<rm -rf>) 경우 
L<File::Path> 모듈의 C<rmtree> 함수를 참조해주세요.

=item s///

=begin original

The substitution operator.  See L<perlop>.

=end original

치환연산자.
L<perlop> 를 참조해주세요.

=item say FILEHANDLE LIST
X<say>

=item say LIST

=item say

=begin original

Just like C<print>, but implicitly appends a newline.
C<say LIST> is simply an abbreviation for C<{ local $\ = "\n"; print
LIST }>.

=end original

C<print> 와 비슷하지만, 아묵적으로 개행이 추가됩니다.
C<say LIST> 는 단순히 C< local $\ = "\n"; print LIST }> 의 생략형입니다.

=begin original

This keyword is only available when the "say" feature is
enabled: see L<feature>.

=end original

이 키워드는 "say" 기능이 유효한 경우에만 이용가능합니다:
L<feature> 를 참조해주세요.

=item scalar EXPR
X<scalar> X<context>

=begin original

Forces EXPR to be interpreted in scalar context and returns the value
of EXPR.

=end original

EXPR 을 강제적으로 스칼라컨텍스트서 해석되도록해서, 
EXPR 의 값을 반환합니다.

    @counts = ( scalar @a, scalar @b, scalar @c );

=begin original

There is no equivalent operator to force an expression to
be interpolated in list context because in practice, this is never
needed.  If you really wanted to do so, however, you could use
the construction C<@{[ (some expression) ]}>, but usually a simple
C<(some expression)> suffices.

=end original

식을 강제적으로 리스트 컨텍스트에서 해석시키도록 하는 연산자는 없습니다.
이론적으로는 불필요하기 때문입니다.
그래도 만약 그렇게 하고 싶다면, C<@{[ (some expression) ]}> 이라는 구조를 
사용할 수 있습니다.
그러나, 보통은 단순히 C<(some expression)> 으로 하면 충분합니다.

=begin original

Because C<scalar> is unary operator, if you accidentally use for EXPR a
parenthesized list, this behaves as a scalar comma expression, evaluating
all but the last element in void context and returning the final element
evaluated in scalar context.  This is seldom what you want.

=end original

C<scalar> 는 단항연산자이기에 EXPR 로써 괄호로 감싼 리스트를 사용한 경우, 
이것은 스칼라 컴마 표현으로 행동하고, 마지막이외의 모든 것은 무효 컨텍스트로
취급되어, 마지막의 요소를 스칼라컨텍스트로 취급한 결과가 반환됩니다.
이것이 당신이 바라는 것은 아니겠죠?

=begin original

The following single statement:

=end original

아래의 하나의 구문은:

	print uc(scalar(&foo,$bar)),$baz;

=begin original

is the moral equivalent of these two:

=end original

아래의 2개의 구문과 같습니다.

	&foo;
	print(uc($bar),$baz);

=begin original

See L<perlop> for more details on unary operators and the comma operator.

=end original

단항연산자와 컴마 연산자에 관한 자세한 내용에 대해서는 L<perlop> 를 
참조해주세요.

=item seek FILEHANDLE,POSITION,WHENCE
X<seek> X<fseek> X<filehandle, position>

=begin original

Sets FILEHANDLE's position, just like the C<fseek> call of C<stdio>.
FILEHANDLE may be an expression whose value gives the name of the
filehandle.  The values for WHENCE are C<0> to set the new position
I<in bytes> to POSITION, C<1> to set it to the current position plus
POSITION, and C<2> to set it to EOF plus POSITION (typically
negative).  For WHENCE you may use the constants C<SEEK_SET>,
C<SEEK_CUR>, and C<SEEK_END> (start of the file, current position, end
of the file) from the Fcntl module.  Returns C<1> upon success, C<0>
otherwise.

=end original

C<stdio> 라이브러리의 C<fseek> 함수처럼 FILEHANDLE 의 파일 포인터를 임의의 
위치로 설정합니다. FILEHANDLE 은 실제 파일핸들이름을 주는 식이어도 상관없습니다. WHENCE 의 값이 C<0> 이라면 새로운 위치를 POSITION 의 위치로 C<1> 이라면 
현재위치에서 I<바이트수로> POSITION 추가한 위치로, C<2> 라면 EOF 에서 
POSITION 만 추가한 위치로, 새로운 위치를 설정합니다.
이 값에는 Fcntl 모듈로 사용된 C<SEEK_SET>, C<SEEK_CUR>, C<SEEK_END>
(파일의 선두, 현재위치, 파일의 마지막) 같은 정수를 사용할 수도 있습니다.
성공시에는 C<1> 를 실패시에는 C<0> 을 반환합니다.

=begin original

Note the I<in bytes>: even if the filehandle has been set to
operate on characters (for example by using the C<:encoding(utf8)> open
layer), tell() will return byte offsets, not character offsets
(because implementing that would render seek() and tell() rather slow).

=end original

I<바이트단위> 에 관한 주의: 파일핸들이 (예를들어 C<:encoding(utf8)> 층을 
사용해서) 문자를 조작하도록 설정되어 있다고 해도, tell() 은 문자의 
offset 이 아닌 바이트의 offset 을 반환하는 것에 주의해주세요.
(왜냐면 이것을 구성하면 seek() 와 tell() 이 느려지기 때문입니다).

=begin original

If you want to position file for C<sysread> or C<syswrite>, don't use
C<seek>--buffering makes its effect on the file's system position
unpredictable and non-portable.  Use C<sysseek> instead.

=end original

C<sysread> 나 C<syswrite> 를 위해 파일의 위치를 설정한 경우는 
C<seek> 는 사용할 수 없습니다 -- 버퍼링을 위해 동작은 예측불능하고 
이식성이 없는 것이 되어버립니다.
대신에 C<sysseek> 를 사용해주세요.

=begin original

Due to the rules and rigors of ANSI C, on some systems you have to do a
seek whenever you switch between reading and writing.  Amongst other
things, this may have the effect of calling stdio's clearerr(3).
A WHENCE of C<1> (C<SEEK_CUR>) is useful for not moving the file position:

=end original

ANSI C 의 규칙과 곤란에 따라, 시스템에 따라서는 쓰기와 읽기를 
바꿀 때에 seek 하지 않으면 안되는 경우가 있습니다.
그 외의 일 중에서 이것은 stdio 의 clearerr(3) 을 호출하는 효과가 있습니다.
WHENCE 의 C<1> (C<SEEK_CUR>) 가, 파일위치를 바꾸지 않기에 유용합니다:

    seek(TEST,0,1);

=begin original

This is also useful for applications emulating C<tail -f>.  Once you hit
EOF on your read, and then sleep for a while, you might have to stick in a
seek() to reset things.  The C<seek> doesn't change the current position,
but it I<does> clear the end-of-file condition on the handle, so that the
next C<< <FILE> >> makes Perl try again to read something.  We hope.

=end original

이것은 어플리케이션에서 C<tail -f> 를 에뮬레이트하는 것에도 유용합니다.
한번 읽을 때에 EOF 에 도달하면 당분간 sleep 하고, 
seek() 하는 것으로 리셋할 필요가 있습니다.
c<seek> 는 현재의 위치를 변경하지 않습니다만, 핸들의 EOF 상태를 
I<클리어>하기에, 다음 C<< <FILE> >> 에서 Perl 은 다시 뭔가를 
읽어들이려고 합니다.

=begin original

If that doesn't work (some IO implementations are particularly
cantankerous), then you may need something more like this:

=end original

이것이 움직이지 않는 경우(특히 나쁜 IO 구성있습니다), 
아래와 같은 것을 할 필요가 있습니다:

    for (;;) {
	for ($curpos = tell(FILE); $_ = <FILE>;
             $curpos = tell(FILE)) {
	    # search for some stuff and put it into files
	}
	sleep($for_a_while);
	seek(FILE, $curpos, 0);
    }

=item seekdir DIRHANDLE,POS
X<seekdir>

=begin original

Sets the current position for the C<readdir> routine on DIRHANDLE.  POS
must be a value returned by C<telldir>.  C<seekdir> also has the same caveats
about possible directory compaction as the corresponding system library
routine.

=end original

DIRHANDLE 에서의 C<raddir> 루틴의 현재위치를 설정합니다.
POS 는 C<telldir> 이 반환하는 값이 아니면 안됩니다.
C<seekdir> 은 같은 이름의 시스템 라이브러리 루틴과 같고, 
디렉토리 축소 시의 문제를 생각할 수 있습니다.

=item select FILEHANDLE
X<select> X<filehandle, default>

=item select

=begin original

Returns the currently selected filehandle.  If FILEHANDLE is supplied,
sets the new current default filehandle for output.  This has two
effects: first, a C<write> or a C<print> without a filehandle will
default to this FILEHANDLE.  Second, references to variables related to
output will refer to this output channel.  For example, if you have to
set the top of form format for more than one output channel, you might
do the following:

=end original

그 시점에서 선택된 파일핸들을 반환합니다.
FILEHANDLE 을 지정한 경우에는 그값을 출력의 기본값 파일핸들로 설정합니다.
이것에는 2가지의 효과가 있습니다.
우선, 파일핸들을 지정하지 않고 C<write> 나 C<print> 를 수행한 경우의 기본값이
이 FILEHANDLE 이 됩니다.
또 하나는 출력관련의 변수의 참조는 이 출력채널을 참조하게 됩니다.
예를들면, 복수의 출력 채널에 대해서, 페이지 맨앞 포맷을 지정하지 않으면 
안되기 때문에 아래처럼 하지 않으면 안되겠죠.

    select(REPORT1);
    $^ = 'report1_top';
    select(REPORT2);
    $^ = 'report2_top';

=begin original

FILEHANDLE may be an expression whose value gives the name of the
actual filehandle.  Thus:

=end original

FILEHANDLE 은 실제 파일핸들의 이름을 표시하는 방법이라도 상관없습니다.
즉, 아래와 같은 것입니다:

    $oldfh = select(STDERR); $| = 1; select($oldfh);

=begin original

Some programmers may prefer to think of filehandles as objects with
methods, preferring to write the last example as:

=end original

파일핸들은 메소드를 가진 오브젝트라고 생각하는 것을 좋아하는 프로그래머도
있을지도 모릅니다.
그런 경우를 위해 마지막의 예제는 아래와 같은 것입니다.

    use IO::Handle;
    STDERR->autoflush(1);

=item select RBITS,WBITS,EBITS,TIMEOUT
X<select>

=begin original

This calls the select(2) system call with the bit masks specified, which
can be constructed using C<fileno> and C<vec>, along these lines:

=end original

이것은 select(2) 시스템 호출을 지정한 비트마스크로 호출합니다.
비트마스크는 C<fileno> 와 C<vec> 를 사용해서 아래처럼 작성할 수 있습니다.

    $rin = $win = $ein = '';
    vec($rin,fileno(STDIN),1) = 1;
    vec($win,fileno(STDOUT),1) = 1;
    $ein = $rin | $win;

=begin original

If you want to select on many filehandles you might wish to write a
subroutine:

=end original

복수의 파일핸들에 select 를 수행하고 싶다면, 
아래처럼 합니다.

    sub fhbits {
	my(@fhlist) = split(' ',$_[0]);
	my($bits);
	for (@fhlist) {
	    vec($bits,fileno($_),1) = 1;
	}
	$bits;
    }
    $rin = fhbits('STDIN TTY SOCK');

=begin original

The usual idiom is:

=end original

보통은,

    ($nfound,$timeleft) =
      select($rout=$rin, $wout=$win, $eout=$ein, $timeout);

=begin original

or to block until something becomes ready just do this

=end original

처럼 사용하고, 이 중의 어느 준비가 끝나기까지 블록하는 것에는 
아래처럼 합니다.

    $nfound = select($rout=$rin, $wout=$win, $eout=$ein, undef);

=begin original

Most systems do not bother to return anything useful in $timeleft, so
calling select() in scalar context just returns $nfound.

=end original

대부분의 시스템에서는 일부러 의미있는 값을 $timeleft 로 반환하지 않기에 
select() 를 스칼라 컨텍스트로 호출하면 단순히 $nfound 를 반환합니다.

=begin original

Any of the bit masks can also be undef.  The timeout, if specified, is
in seconds, which may be fractional.  Note: not all implementations are
capable of returning the $timeleft.  If not, they always return
$timeleft equal to the supplied $timeout.

=end original

어느 비트마스크에도 undef 를 설정할 수 있습니다.
TIMEOUT 을 지정할 때에는 초수로 지정하고, 소수도 상관없습니다.
주: 모든 구성에서 $timeleft 가 반환시키는 것이 아닙니다.
이 경우는 $timeleft 에는 이미 지정한 TIMEOUT 과 같은 값이 반환됩니다.

=begin original

You can effect a sleep of 250 milliseconds this way:

=end original

250 밀리 초의 sleep 와 같은 효과가 아래처럼 해서 얻을 수 있습니다.

    select(undef, undef, undef, 0.25);

=begin original

Note that whether C<select> gets restarted after signals (say, SIGALRM)
is implementation-dependent.  See also L<perlport> for notes on the
portability of C<select>.

=end original

C<select> 가 시그널(예를들면 SIGALRM) 의 뒤에 재기동하는 가 어떤가는 
구성의존이라는 것에 주의해주세요.
C<select> 의 이식성에 관한 주의에 대해서는 L<perlport> 도 참조하세요.

=begin original

On error, C<select> behaves like the select(2) system call : it returns
-1 and sets C<$!>.

=end original

에러 시는 C<select> 는 select(2) 시스템 호출로 행동합니다:
-1 을 반환하고, C<$!> 을 설정합니다.

=begin original

Note: on some Unixes, the select(2) system call may report a socket file
descriptor as "ready for reading", when actually no data is available,
thus a subsequent read blocks. It can be avoided using always the
O_NONBLOCK flag on the socket. See select(2) and fcntl(2) for further
details.

=end original

주의: Unix 의 안에는 실제로 이용가능한 데이터가 없기 때문에 계속해 읽기가 
블록되는 경우, select(2) 시스템 호출이 소켓 파일기술자가 "일기 준비중"이라고 
보고하는 것도 있습니다.
이것은 소켓에 대해서 항상 O_NONBLOCK 플래그를 사용하는 것으로 회피할 수 있습니다. 보다 자세한 내용에 대해서는 select(2) 와 fcntl(2) 을 참조해주세요.

=begin original

B<WARNING>: One should not attempt to mix buffered I/O (like C<read>
or <FH>) with C<select>, except as permitted by POSIX, and even
then only on POSIX systems.  You have to use C<sysread> instead.

=end original

B<경고>: 버퍼붙은 I/O (C<read> 나 C<FH>) 와 C<select> 를 
섞어쓰는 것은 안됩니다(예외 : POSIX에서 인증된 형태로 사용ㅏ고 
POSIX 시스템에서만 움직일 경우를 제외합니다).
대신에 C<sysread> 를 사용하지 않으면 안됩니다.

=item semctl ID,SEMNUM,CMD,ARG
X<semctl>

=begin original

Calls the System V IPC function C<semctl>.  You'll probably have to say

=end original

System V IPC 함수 C<semctl> 을 호출합니다.
바른 정수정의를 얻기 위해 우선,

    use IPC::SysV;

=begin original

first to get the correct constant definitions.  If CMD is IPC_STAT or
GETALL, then ARG must be a variable that will hold the returned
semid_ds structure or semaphore value array.  Returns like C<ioctl>:
the undefined value for error, "C<0 but true>" for zero, or the actual
return value otherwise.  The ARG must consist of a vector of native
short integers, which may be created with C<pack("s!",(0)x$nsem)>.
See also L<perlipc/"SysV IPC">, C<IPC::SysV>, C<IPC::Semaphore>
documentation.

=end original

이라고 선언할 필요가 있습니다.
CMD 가 IPC_STAT 이나 GETALL 일 때에는 ARG 는 반환되는 
semid_ds 구조체나 세마포어 값의 배열을 넣는 변수가 아니면 안됩니다.
C<ioctl> 처럼 에러시에는 미정의값, 0 일때는 "C< 0 but true>", 
그 이외라면 그 값 그대로 반환합니다.
ARG 는 네이티브한 short int 의 벡터에서 성립되지 않으면 안됩니다.
이것은 C<pack("s!", (0)x$nsem) 으로 작성할 수 있습니다.
L<perlipc/"SysV IPC">, C<IPC::SysV>, C<IPC:Semaphore> 도 참조하세요.

=item semget KEY,NSEMS,FLAGS
X<semget>

=begin original

Calls the System V IPC function semget.  Returns the semaphore id, or
the undefined value if there is an error.  See also
L<perlipc/"SysV IPC">, C<IPC::SysV>, C<IPC::SysV::Semaphore>
documentation.

=end original

System V IPC 함수 semget 을 호출합니다.
세마포어 ID 나, 에러시에는 미정의값을 반환합니다.
L<perlipc/"SysV IPC">, C<IPC::SysV>, C<IPC::SysV::Semaphore> 도 
참조해주세요.

=item semop KEY,OPSTRING
X<semop>

=begin original

Calls the System V IPC function semop to perform semaphore operations
such as signalling and waiting.  OPSTRING must be a packed array of
semop structures.  Each semop structure can be generated with
C<pack("s!3", $semnum, $semop, $semflag)>.  The length of OPSTRING 
implies the number of semaphore operations.  Returns true if
successful, or false if there is an error.  As an example, the
following code waits on semaphore $semnum of semaphore id $semid:

=end original

시그널을 송신이나 대기 등의 세모포어 조작을 수행하기 위해서는 
System V IPC 함수 semop 를 호출합니다.
OPSTRING 은 semop 구조체의 pack 된 배열이 아니면 안됩니다.
semop 구조체는 각각 
C<pack("s!3", $semnum, $semop, $semflag)> 처럼 만들 수 있습니다.
세마포어 조작의 수는 OPSTRING 의 길이로 알 수 있습니다.
성공시에는 참을 에러시에는 거짓을 반환합니다.
아래의 예제는 세마포어 ID $semid 의 세마포어 $semnum 로 
대기를 수행합니다.

    $semop = pack("s!3", $semnum, -1, 0);
    die "Semaphore trouble: $!\n" unless semop($semid, $semop);

=begin original

To signal the semaphore, replace C<-1> with C<1>.  See also
L<perlipc/"SysV IPC">, C<IPC::SysV>, and C<IPC::SysV::Semaphore>
documentation.

=end original

세마포어에 시그널을 보내기 위해서는 C<-1>을 C<1> 로 변경해주세요.
L<perlipc/"SysV IPC">, C<IPC::SysV>, C<IPC::SysV::Semaphore> 도 참조해주세요.

=item send SOCKET,MSG,FLAGS,TO
X<send>

=item send SOCKET,MSG,FLAGS

=begin original

Sends a message on a socket.  Attempts to send the scalar MSG to the
SOCKET filehandle.  Takes the same flags as the system call of the
same name.  On unconnected sockets you must specify a destination to
send TO, in which case it does a C C<sendto>.  Returns the number of
characters sent, or the undefined value if there is an error.  The C
system call sendmsg(2) is currently unimplemented.  See
L<perlipc/"UDP: Message Passing"> for examples.

=end original

소켓에 메시지ㄹ 보냅니다.
스칼라 MSG 를 파일핸들 SOCKET 으로 보내려고 합니다.
같은 이름의 시스템 호출처럼 플래그를 지정할 수 있습니다.
접속하지 않은 소켓에는 송신처 TO 를 지정하지 않으면 안되고, 
이 경우, C 의 C<sendto> 를 실행합니다.
송신한 문자수나 에러시에는 미정의값을 반환합니다.
C 의 시스템 호출 sendmsg(2) 는 현재 구성되지 않았습니다.
예제에 대해서는 L<perlipc/"UDP: Message Passing"> 을 참조해주세요.

=begin original

Note the I<characters>: depending on the status of the socket, either
(8-bit) bytes or characters are sent.  By default all sockets operate
on bytes, but for example if the socket has been changed using
binmode() to operate with the C<:encoding(utf8)> I/O layer (see
L</open>, or the C<open> pragma, L<open>), the I/O will operate on UTF-8
encoded Unicode characters, not bytes.  Similarly for the C<:encoding>
pragma: in that case pretty much any characters can be sent.

=end original

I<문자> 에 관한 주의: 소켓의 상태에 따라, (8비트의) 바이트나 
문자를 송신합니다.
기본값에서는 모든 소켓은 바이트를 처리합니다만, 
예를들면 소켓이 binmode() 에서 C<:encoding(utf8)> I/O 층(L</open>,
C<open> 프라그마, L<open> 을 참조하세요) 를 사용하도록 지정한 경우, 
I/O 는 바이트가 아닌 UTF-8 인코드 된 Unicode 문자를 조작합니다.
C<:encoding> 프라그마도 마찬가지입니다:
이 경우, 대개 모든 문자를 써넣을 수 있습니다.

=item setpgrp PID,PGRP
X<setpgrp> X<group>

=begin original

Sets the current process group for the specified PID, C<0> for the current
process.  Will produce a fatal error if used on a machine that doesn't
implement POSIX setpgid(2) or BSD setpgrp(2).  If the arguments are omitted,
it defaults to C<0,0>.  Note that the BSD 4.2 version of C<setpgrp> does not
accept any arguments, so only C<setpgrp(0,0)> is portable.  See also
C<POSIX::setsid()>.

=end original

지정한 PID (C<0> 을 지정하면 Current Process) 에 대한 프로세스 그룹을 
설정합니다.
POSIX setpgrp(2) 또는 BSD setpgrp(2) 이 구성되지 않은 머신에서는 
치명적인 에러가 됩니다.
인수가 생략된 경우는 C<0,0> 이 사용됩니다.
BSD 4.2 판의 C<setpgrp> 는 인수를 얻을 수 없기 때문에, 
C<setpgrp(0,0)> 만이 이식성이 있는 것에 주의해주세요.
C<POSIX::setsid()> 도 참조해주세요.

=item setpriority WHICH,WHO,PRIORITY
X<setpriority> X<priority> X<nice> X<renice>

=begin original

Sets the current priority for a process, a process group, or a user.
(See setpriority(2).)  Will produce a fatal error if used on a machine
that doesn't implement setpriority(2).

=end original

프로세스, 프로세스그룹, 유저에 대한 우선순위를 설정합니다.
(setpriority(2) 를 참조해주세요)
setpriority(2) 가 구성되지 않은 머신에서는 
치명적인 에러가 발생합니다.

=item setsockopt SOCKET,LEVEL,OPTNAME,OPTVAL
X<setsockopt>

=begin original

Sets the socket option requested.  Returns undefined if there is an
error.  Use integer constants provided by the C<Socket> module for
LEVEL and OPNAME.  Values for LEVEL can also be obtained from
getprotobyname.  OPTVAL might either be a packed string or an integer.
An integer OPTVAL is shorthand for pack("i", OPTVAL).

=end original

요구ㄴ 소켓 옵션을 설정합니다.
에러시에는 미정의값이 반환됩니다.
LEVEL 과 OPNAME 에는 C<Socket> 모듈이 제공하는 정수를 사용합니다.
LEVEL 의 값은 getprotobyname 에서 얻을 수도 있습니다.
OPTVAL 은 pack 된 문자열이 정수입니다.
정수의 OPTVAL 은 pack("i", OPTVAL) 생략표현입니다.

=begin original

An example disabling the Nagle's algorithm for a socket:

=end original

소켓에 대한 Nagle 의 알고리즘을 무효화하는 예제입니다:

    use Socket qw(IPPROTO_TCP TCP_NODELAY);
    setsockopt($socket, IPPROTO_TCP, TCP_NODELAY, 1);

=item shift ARRAY
X<shift>

=item shift

=begin original

Shifts the first value of the array off and returns it, shortening the
array by 1 and moving everything down.  If there are no elements in the
array, returns the undefined value.  If ARRAY is omitted, shifts the
C<@_> array within the lexical scope of subroutines and formats, and the
C<@ARGV> array outside of a subroutine and also within the lexical scopes
established by the C<eval STRING>, C<BEGIN {}>, C<INIT {}>, C<CHECK {}>,
C<UNITCHECK {}> and C<END {}> constructs.

=end original

배열의 최초의 값을 얻어내서 그 값을 반환하고, 배열을 하나 줄여서, 
모든 요소를 앞으로 미룹니다.
배열에 요소가 없으면, 미정의값을 반환합니다.
ARRAY 를 생략하면,
서브루틴이나 포맷의 렉시컬 스코프에서는 C<@_> 를 
서브루틴의 바깥쪽에서 C<eval STRING>, C<BEGIN {}>, C<INIT {}>, C<CHECK {}>,
C<UNITCHECK {}>, C<END {}> 로 작성된 렉시컬 영역에서는 
C<@ARGV> 가 사용됩니다.

=begin original

See also C<unshift>, C<push>, and C<pop>.  C<shift> and C<unshift> do the
same thing to the left end of an array that C<pop> and C<push> do to the
right end.

=end original

C<unshift>, C<push>, C<pop> 도 참조하세요.
C<shift> 와 C<unshift> 는 C<pop> 과 C<push> 가 배열의 오른쪽단에서 
수행된 것을 왼쪽단에서 수행합니다.

=item shmctl ID,CMD,ARG
X<shmctl>

=begin original

Calls the System V IPC function shmctl.  You'll probably have to say

=end original

System V IPC 함수 shmctl 을 호출합니다. 바른 정수정의를 얻기 위해서는 우선

    use IPC::SysV;

=begin original

first to get the correct constant definitions.  If CMD is C<IPC_STAT>,
then ARG must be a variable that will hold the returned C<shmid_ds>
structure.  Returns like ioctl: the undefined value for error, "C<0> but
true" for zero, or the actual return value otherwise.
See also L<perlipc/"SysV IPC"> and C<IPC::SysV> documentation.

=end original

이라고 선언할 필요가 있습니다.
CMD 가 C<IPC_STAT> 이라면 ARG 는 반환된 C<shmid_ds> 구조체를 
넣는 변수가 아니면 안됩니다.
ioctl 처럼 에러시에는 미정의값, 0 일때는 "C<0> 이지만 참", 
그 이외라면, 그 값을 그대로 반환합니다.
L<perlipc/"SysV IPC"> 와 C<IPC::SysV> 도 참조하세요.

=item shmget KEY,SIZE,FLAGS
X<shmget>

=begin original

Calls the System V IPC function shmget.  Returns the shared memory
segment id, or the undefined value if there is an error.
See also L<perlipc/"SysV IPC"> and C<IPC::SysV> documentation.

=end original

System V IPC 함수 shmget 을 호출합니다.
공유 메모리의 세그먼트 ID 나 에러시에는 미정의값을 반환합니다.
L<perlipc/"SysV IPC"> 와 C<IPC::SysV> 도 참조해주세요.

=item shmread ID,VAR,POS,SIZE
X<shmread>
X<shmwrite>

=item shmwrite ID,STRING,POS,SIZE

=begin original

Reads or writes the System V shared memory segment ID starting at
position POS for size SIZE by attaching to it, copying in/out, and
detaching from it.  When reading, VAR must be a variable that will
hold the data read.  When writing, if STRING is too long, only SIZE
bytes are used; if STRING is too short, nulls are written to fill out
SIZE bytes.  Return true if successful, or false if there is an error.
shmread() taints the variable. See also L<perlipc/"SysV IPC">,
C<IPC::SysV> documentation, and the C<IPC::Shareable> module from CPAN.

=end original

System V 공유 메모리 세그먼트 ID 에 대해, Attach 해서 
복사를 수행하고, detach 하는 형태로 위치 POS 에서 
사이즈 SIZE 만, 읽기나 쓰기를 수행합니다.
읽을 시에는 VAR 는 읽힌 데이터를 넣는 변수가 아니면 안됩니다.
쓸 때에는 STRING 이 너무 길어도, SIZE 바이트만큼 사용됩니다.
STRING 이 너무 짧은 경우에는 SIZE 바이트를 넣기 위해, 
null 문자가 쓰여집니다.
성공시에는 참을, 에러시에는 거짓을 반환합니다.
shmread() 는 변수를 오염시킵니다.
L<perlipc/"SysV IPC"> 와 C<IPC::SysV> 의 문장과 
CPAN 의 C<IPC::Shareable> 도 참조해주세요.

=item shutdown SOCKET,HOW
X<shutdown>

=begin original

Shuts down a socket connection in the manner indicated by HOW, which
has the same interpretation as in the system call of the same name.

=end original

같은 이름의 시스템 호출처럼 해석되는 HOW 에 의해, 
지정된 방법으로 소켓 접속의 shutdown 을 수행합니다.

    shutdown(SOCKET, 0);    # I/we have stopped reading data
    shutdown(SOCKET, 1);    # I/we have stopped writing data
    shutdown(SOCKET, 2);    # I/we have stopped using this socket

=begin original

This is useful with sockets when you want to tell the other
side you're done writing but not done reading, or vice versa.
It's also a more insistent form of close because it also
disables the file descriptor in any forked copies in other
processes.

=end original

이것은 이쪽이 소켓을 다 썼지만 다 읽지 않은,
또는 그 반대를 상대편에 전하고 싶을 때 편리합니다.
이것은 그 외의 프로세스로 fork 한 파일 기술자의 복사도 
무효화하기때문에 보다 귀찮은 닫는 방법입니다.

=item sin EXPR
X<sin> X<sine> X<asin> X<arcsine>

=item sin

=begin original

Returns the sine of EXPR (expressed in radians).  If EXPR is omitted,
returns sine of C<$_>.

=end original

(라디안으로 표현한) EXPR 의 sine 을 반환합니다.
EXPR 이 생략된 때에는 C<$_> 의 sine 을 반환합니다.

=begin original

For the inverse sine operation, you may use the C<Math::Trig::asin>
function, or use this relation:

=end original

역 sine 을 우너하는 경우에는 C<Math::Trig::asin> 함수를 쓰거나, 
아래의 관곌ㄹ 사용해 주세요:

    sub asin { atan2($_[0], sqrt(1 - $_[0] * $_[0])) }

=item sleep EXPR
X<sleep> X<pause>

=item sleep

=begin original

Causes the script to sleep for EXPR seconds, or forever if no EXPR.
May be interrupted if the process receives a signal such as C<SIGALRM>.
Returns the number of seconds actually slept.  You probably cannot
mix C<alarm> and C<sleep> calls, because C<sleep> is often implemented
using C<alarm>.

=end original

스크립트를 EXPR 로 지정한 초수 ( 생략시에는 영원히)
슬리프시킵니다.
그 프로세스에게는 C<SIGALRM> 같은 신호를 수신하면 
인터럽트가 걸립니다.
실제로 슬리프한 초수를 반환합니다 C<sleep> 는 C<alarm> 을 
사용해서 구성된 것이 많기 때문에 C<alarm> 과 C<sleep> 는 
아마도 섞어서 사용할 수 없습니다.

=begin original

On some older systems, it may sleep up to a full second less than what
you requested, depending on how it counts seconds.  Most modern systems
always sleep the full amount.  They may appear to sleep longer than that,
however, because your process might not be scheduled right away in a
busy multitasking system.

=end original

낡은 시스템에서는 어떻게 초를 구하는 가에 의해 요구한 초수를 완전히 
채우지 않은 사이에 슬리프에서 빠지는 경우가 있습니다.
최근의 시스템에서는 이미 완전히 슬리프합니다.
그러나, 부하가 높은 멀티태스크 시스템에서는 바른 스케쥴링이 되지 않기 
때문에 보다 긴 시간 슬리프 할 수 있습니다.

=begin original

For delays of finer granularity than one second, the Time::HiRes module
(from CPAN, and starting from Perl 5.8 part of the standard
distribution) provides usleep().  You may also use Perl's four-argument
version of select() leaving the first three arguments undefined, or you
might be able to use the C<syscall> interface to access setitimer(2) if
your system supports it. See L<perlfaq8> for details.

=end original

1 초보다 정도가 높은 슬리프를 수행하기 위해서는 
Time::HiRes 모듈(CPAN 에서 또는 Perl 5.8 에서는 표준배표되어 있습니다)
이 usleep() 를 제공합니다.
Perl 의 4 인수판 select() 를 맨처음의 3인수를 미정의해서 사용하거나,
setitimer(2) 를 지원하는 시스템에서는 Perl 의 
C<syscall> 인스턴스를 사용해서 접근할 수도 있습니다.
자세한 내용은 L<perlfaq8> 을 참조해주세요.

=begin original

See also the POSIX module's C<pause> function.

=end original

POSIX 모듈의 C<pause> 함수도 참조해주세요.

=item socket SOCKET,DOMAIN,TYPE,PROTOCOL
X<socket>

=begin original

Opens a socket of the specified kind and attaches it to filehandle
SOCKET.  DOMAIN, TYPE, and PROTOCOL are specified the same as for
the system call of the same name.  You should C<use Socket> first
to get the proper definitions imported.  See the examples in
L<perlipc/"Sockets: Client/Server Communication">.

=end original

지정한 종류의 소켓을 열고, 파일핸들 SOCKET 에 attach 합니다.
DOMAIN, TYPE, PROTOCOL 은 같은 이름의 시스템 호출처럼 지정합니다.
적절한 정의를 import 하기 위해서는 우선 C<use Socket> 이라고 하면 좋겠죠?
예제에 대해서는 L<perlipc/"Sockets: Client/Server Communication"> 을 
참조해주세요.

=begin original

On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptor, as determined by the
value of $^F.  See L<perlvar/$^F>.

=end original

파일에 대해 close-on-exec 플래그를 지우너하고 있는 시스템에서는 
플래그는 $^F 의 값으로 결정되는 새롭게 오픈된 파일 기술자에 대해서 
정의됩니다.
L<perlvar/$^F> 를 참조해주세요.

=item socketpair SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL
X<socketpair>

=begin original

Creates an unnamed pair of sockets in the specified domain, of the
specified type.  DOMAIN, TYPE, and PROTOCOL are specified the same as
for the system call of the same name.  If unimplemented, yields a fatal
error.  Returns true if successful.

=end original

지정한 DOMAIN 에 지정한 TYPE 으로 이름 없는 소켓의 쌍을 생성합니다.
DOMAIN, TYPE, PROTOCOL 은 같은 이름의 시스템 호출처럼 지정합니다.
구성되지 않은 경우에는 치명적 에러가 됩니다.
성공시에는 참을 반환합니다.

=begin original

On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptors, as determined by the value
of $^F.  See L<perlvar/$^F>.

=end original

파일에 대해서 close-on-exec 플래그를 지원하고 있는 시스템에서는 
플래그는 $^F 의 값으로 경정되는 새롭게 오픈된 파일기술자에 대해서 정의됩니다.
L<perlvar/$^F> 를 참조해주세요.

=begin original

Some systems defined C<pipe> in terms of C<socketpair>, in which a call
to C<pipe(Rdr, Wtr)> is essentially:

=end original

C<pipe> 를 C<socketpair> 를 사용해서 정의하고 있는 시스템도 있습니다;
C<pipe(Rdr, Wtr)> 은 본질적으로는 아래와 같이 됩니:

    use Socket;
    socketpair(Rdr, Wtr, AF_UNIX, SOCK_STREAM, PF_UNSPEC);
    shutdown(Rdr, 1);        # no more writing for reader
    shutdown(Wtr, 0);        # no more reading for writer

=begin original

See L<perlipc> for an example of socketpair use.  Perl 5.8 and later will
emulate socketpair using IP sockets to localhost if your system implements
sockets but not socketpair.

=end original

socketpair 의 사용예제에 대해서는 L<perlipc> 를 참조해주세요.
Perl 5.8 이후에서는 시스템이 소켓을 구성하고 있지만 socketpair 를 
구성하지 않은 경우, localhost 에 대해서 IP 소켓을 사용하는 것으로 
socketpair 를 에뮬레이트합니다.

=item sort SUBNAME LIST
X<sort> X<qsort> X<quicksort> X<mergesort>

=item sort BLOCK LIST

=item sort LIST

=begin original

In list context, this sorts the LIST and returns the sorted list value.
In scalar context, the behaviour of C<sort()> is undefined.

=end original

리스트 컨텍스트에서는 LIST 를 정렬해서, 정렬된 리스트 값을 반환합니다.
스칼라 컨텍스트에서는 C<sort()> 의 행동은 미정의입니다.

=begin original

If SUBNAME or BLOCK is omitted, C<sort>s in standard string comparison
order.  If SUBNAME is specified, it gives the name of a subroutine
that returns an integer less than, equal to, or greater than C<0>,
depending on how the elements of the list are to be ordered.  (The C<<
<=> >> and C<cmp> operators are extremely useful in such routines.)
SUBNAME may be a scalar variable name (unsubscripted), in which case
the value provides the name of (or a reference to) the actual
subroutine to use.  In place of a SUBNAME, you can provide a BLOCK as
an anonymous, in-line sort subroutine.

=end original

SUBNAME 이나 BLOCK 을 생략하면 표준의 문자열 비교의 순서로 정렬이 
수행됩니다.
SUBNAME 을 지정하면, 그것이 리스트의 요소를 어떤 순서로 나열하는 가에 
대해서 부수, 제로, 정수를 반환하는 서브루틴의 이름으로 해석됩니다.
(이런 루틴에서는 C<< <=> >> 연산자나 cmp 연산자가 꽤 편리합니다)
SUBNAME 은 스칼라 변수이름(첨자없음)이라도 좋고, 
그 경우에는 그 값이 사용하는 실제의 서브틴의 이름(또는 그 리퍼런스)로 
해석됩니다. SUBNAME 대신에 이름없는 인라인 소트 루틴으로 BLOCK 을 
쓸 수 있습니다.

=begin original

If the subroutine's prototype is C<($$)>, the elements to be compared
are passed by reference in C<@_>, as for a normal subroutine.  This is
slower than unprototyped subroutines, where the elements to be
compared are passed into the subroutine
as the package global variables $a and $b (see example below).  Note that
in the latter case, it is usually counter-productive to declare $a and
$b as lexicals.

=end original

서브루틴의 프로토타입이 C<($$)> 인 경우, 비교하는 요소는 보통 서브루틴처럼 
C<@_> 안에 리퍼런스로 건네집니다.
이것은 프로토타입없는 서브루틴보다 느립니다. 이 경우는 비교를 위해 
서브루틴에 넘겨진 2개의 요소는 패키지의 글로벌 변수 $a 와 $b 로 건네집니다.
(다음의 예제를 참조해주세요).
후자의 경우는 렉시컬하게 $a 와 $b 를 선언하는 것은 보통 역효과가 됩니다.

=begin original

The values to be compared are always passed by reference and should not
be modified.

=end original

$a 나 $b  는 리퍼런스에 의해 건네지기 때문에 변경해야하는 것이 아닙니다.

=begin original

You also cannot exit out of the sort block or subroutine using any of the
loop control operators described in L<perlsyn> or with C<goto>.

=end original

또, sort block 이나 서브루틴에서 L<perlsyn> 에서 설명되는 루프 제어자나 
C<goto> 를 사용해서 빠져나와서는 안됩니다.

=begin original

When C<use locale> is in effect, C<sort LIST> sorts LIST according to the
current collation locale.  See L<perllocale>.

=end original

C<use locale> 이 유효한 경우, C<sort LIST> 는 LIST 를 현재의 비교로케일에 
따라 정렬ㅂ니다. L<perllocale> 을 참조해주세요.

=begin original

sort() returns aliases into the original list, much as a for loop's index
variable aliases the list elements.  That is, modifying an element of a
list returned by sort() (for example, in a C<foreach>, C<map> or C<grep>)
actually modifies the element in the original list.  This is usually
something to be avoided when writing clear code.

=end original

sort() 는 원래의 리스트로의 alias 를 반환합니다; for 루프의 인덱스 변수가
리스트 요소로의 alias 와 같습니다.
즉, sort() 로 반환되는 리스트 요소를(예를들면, C<foreach> 나 C<map> 이나 
C<grep> 에서) 변경하면, 실제로 원래의 리스트 요소가 변경됩니다.
이것은 예쁜 코드를 쓰는 것으로 보통은 회피할 수 있습니다.

=begin original

Perl 5.6 and earlier used a quicksort algorithm to implement sort.
That algorithm was not stable, and I<could> go quadratic.  (A I<stable> sort
preserves the input order of elements that compare equal.  Although
quicksort's run time is O(NlogN) when averaged over all arrays of
length N, the time can be O(N**2), I<quadratic> behavior, for some
inputs.)  In 5.7, the quicksort implementation was replaced with
a stable mergesort algorithm whose worst-case behavior is O(NlogN).
But benchmarks indicated that for some inputs, on some platforms,
the original quicksort was faster.  5.8 has a sort pragma for
limited control of the sort.  Its rather blunt control of the
underlying algorithm may not persist into future Perls, but the
ability to characterize the input or output in implementation
independent ways quite probably will.  See L<sort>.

=end original

Perl 5.6 이전에서는 정렬의 구성에 퀵 소트 알고리즘을 사용했습니다.
이 알고리즘은 안정되지 않고, 2 승의 시간이 걸릴 I<가능성이 있습니다>.
(I<안정된> 정렬은 비교한 때에 같은 요소의 입력순으로 보존됩니.
퀵소트의 실행시간은 길이 N 의 모든 배열의 평균에서는 O(NlogN) 입니다만, 
입력에 따라서는 O(N**2) 라는 I<2 승의> 행동을 하는 수가 있습니다)
5.7 에서는 퀵소트에 의한 구성은 최악의 경우의 행동도 O(NlogN) 인, 
안정된 머지소트알고리즘으로 바꿔졌습니다.
그러나, 입력과 플랫폼에 따라서는 벤치마크는 퀵소트의 쪽이 빨라집니다.
5.8 에서는 정렬을 한정적으로 제어할 수 있는 sort 프라그마가 있습니다.
이 알고리즘의 직접적인 제어방법은 장래의 perl 에서는 계속되지 않을지도 
모르지만, 구성에 의존하지 않는 형태로 입력이나 출력을 성격을 정하는 기능은
아마도 있습니다.
L<sort> 를 참조하세요.

=begin original

Examples:

=end original

예제:

    # sort lexically
    @articles = sort @files;

    # same thing, but with explicit sort routine
    @articles = sort {$a cmp $b} @files;

    # now case-insensitively
    @articles = sort {uc($a) cmp uc($b)} @files;

    # same thing in reversed order
    @articles = sort {$b cmp $a} @files;

    # sort numerically ascending
    @articles = sort {$a <=> $b} @files;

    # sort numerically descending
    @articles = sort {$b <=> $a} @files;

    # this sorts the %age hash by value instead of key
    # using an in-line function
    @eldest = sort { $age{$b} <=> $age{$a} } keys %age;

    # sort using explicit subroutine name
    sub byage {
	$age{$a} <=> $age{$b};	# presuming numeric
    }
    @sortedclass = sort byage @class;

    sub backwards { $b cmp $a }
    @harry  = qw(dog cat x Cain Abel);
    @george = qw(gone chased yz Punished Axed);
    print sort @harry;
	    # prints AbelCaincatdogx
    print sort backwards @harry;
	    # prints xdogcatCainAbel
    print sort @george, 'to', @harry;
	    # prints AbelAxedCainPunishedcatchaseddoggonetoxyz

    # inefficiently sort by descending numeric compare using
    # the first integer after the first = sign, or the
    # whole record case-insensitively otherwise

    @new = sort {
	($b =~ /=(\d+)/)[0] <=> ($a =~ /=(\d+)/)[0]
			    ||
	            uc($a)  cmp  uc($b)
    } @old;

    # same thing, but much more efficiently;
    # we'll build auxiliary indices instead
    # for speed
    @nums = @caps = ();
    for (@old) {
	push @nums, /=(\d+)/;
	push @caps, uc($_);
    }

    @new = @old[ sort {
			$nums[$b] <=> $nums[$a]
				 ||
			$caps[$a] cmp $caps[$b]
		       } 0..$#old
	       ];

    # same thing, but without any temps
    @new = map { $_->[0] }
           sort { $b->[1] <=> $a->[1]
                           ||
                  $a->[2] cmp $b->[2]
           } map { [$_, /=(\d+)/, uc($_)] } @old;

    # using a prototype allows you to use any comparison subroutine
    # as a sort subroutine (including other package's subroutines)
    package other;
    sub backwards ($$) { $_[1] cmp $_[0]; }	# $a and $b are not set here

    package main;
    @new = sort other::backwards @old;

    # guarantee stability, regardless of algorithm
    use sort 'stable';
    @new = sort { substr($a, 3, 5) cmp substr($b, 3, 5) } @old;

    # force use of mergesort (not portable outside Perl 5.8)
    use sort '_mergesort';  # note discouraging _
    @new = sort { substr($a, 3, 5) cmp substr($b, 3, 5) } @old;

=begin original

If you're using strict, you I<must not> declare $a
and $b as lexicals.  They are package globals.  That means
if you're in the C<main> package and type

=end original

use strict 하고 있는 경우 $a 와 $b 를 렉시컬로 선언해서는 I<안됩니다>.
이것은 패키지 글로벌입니다.
즉, C<main> 패키지에서 아래처럼 쓴 경우:

    @articles = sort {$b <=> $a} @files;

=begin original

then C<$a> and C<$b> are C<$main::a> and C<$main::b> (or C<$::a> and C<$::b>),
but if you're in the C<FooPack> package, it's the same as typing

=end original

C<$a> 와 C<$b> 는 C<$main::a> 와 C<$main::b> (또는 C<$::a> 와 C<$::b>) 를 
의미하지만, C<FooPack> 패키지안의 경우는 이것은 아래처럼 됩니다:

    @articles = sort {$FooPack::b <=> $FooPack::a} @files;

=begin original

The comparison function is required to behave.  If it returns
inconsistent results (sometimes saying C<$x[1]> is less than C<$x[2]> and
sometimes saying the opposite, for example) the results are not
well-defined.

=end original

비교함수는 일관된 행동을 하는 것을 원합ㅣ다.
일관되지 않은 결과를 반환하는(예를 들어, 어떤 때는 C<$x[1]> 이 
C<$x[2]> 보다 작다고 반환하고 또 어떤때는 반대의 경우를 반환하는) 
경우, 결과는 미정의입니다.

=begin original

Because C<< <=> >> returns C<undef> when either operand is C<NaN>
(not-a-number), and because C<sort> will trigger a fatal error unless the
result of a comparison is defined, when sorting with a comparison function
like C<< $a <=> $b >>, be careful about lists that might contain a C<NaN>.
The following example takes advantage of the fact that C<NaN != NaN> to
eliminate any C<NaN>s from the input.

=end original

C<< <=> >> 는 어느쪽의 operand 가 C<NaN> (not-a-number) 일 때에 
C<undef> 를 반환하고, C<sort> 는 비교 결과가 미정의값이라고 치명적 
에러가 되기때문에, C<< $a <=> $b >> 같은 비교함수로 정렬하는 경우는 
리스트에 C<NaN> 이 포함되지 않도록 주의해주세요.
아래의 예제는 입력에서 C<NaN> 을 빼기 위해서는 C<NaN != NaN> 같은 
성질을 이용하고 있습니다.

    @result = sort { $a <=> $b } grep { $_ == $_ } @input;

=item splice ARRAY,OFFSET,LENGTH,LIST
X<splice>

=item splice ARRAY,OFFSET,LENGTH

=item splice ARRAY,OFFSET

=item splice ARRAY

=begin original

Removes the elements designated by OFFSET and LENGTH from an array, and
replaces them with the elements of LIST, if any.  In list context,
returns the elements removed from the array.  In scalar context,
returns the last element removed, or C<undef> if no elements are
removed.  The array grows or shrinks as necessary.
If OFFSET is negative then it starts that far from the end of the array.
If LENGTH is omitted, removes everything from OFFSET onward.
If LENGTH is negative, removes the elements from OFFSET onward
except for -LENGTH elements at the end of the array.
If both OFFSET and LENGTH are omitted, removes everything. If OFFSET is
past the end of the array, perl issues a warning, and splices at the
end of the array.

=end original

ARRAY 에서 OFFSET, LENGTH 에서 지정된 요소를 제외하고,
LIST 가 있으면 그것을 대신에 투입합니다.
리스트 컨텍스트에서는 배열에서 뺀 요소를 반환합니다.
스칼라 컨텍스트에서는 빠진 마지막의 요소를 반환합니다.
요소가 빠지지 않은 경우는 C<undef> 를 반환합니다.
배열은 필요에 따라서 크거나, 작아질 수 있습니다.
OFFSET 이 음수인 경우는 배열의 마지막에서의 거리를 나타냅니다.
LENGTH 가 생략되면 OFFSET 이후의 모든 요소를 제외합니다.
LENGTH 가 음수인 경우는 OFFSET 에서 전방으로 배열의 마지막부터 -LENGTH 요소를 
빼고 제외합니다.
OFFSET 과 LENGTH 의 양쪽이 생략되면 모든 요소를 제외합니다.
OFFSET 이 배열의 마지막보다 뒤인 경우 perl 은 경고를 내고, 배열의 마지막에 
대해서 처리합니다.

=begin original

The following equivalences hold (assuming C<< $[ == 0 and $#a >= $i >> )

=end original

아래는 (C<< $[ == 0 과 $#a >= $i >> 라고 가정하면) 각각 같습니다.

    push(@a,$x,$y)	splice(@a,@a,0,$x,$y)
    pop(@a)		splice(@a,-1)
    shift(@a)		splice(@a,0,1)
    unshift(@a,$x,$y)	splice(@a,0,0,$x,$y)
    $a[$i] = $y		splice(@a,$i,1,$y)

=begin original

Example, assuming array lengths are passed before arrays:

=end original

다음의 예제에서는 배열의 앞에서 각각의 배열의 크가가 건네지는 것입니다.

    sub aeq {	# compare two list values
	my(@a) = splice(@_,0,shift);
	my(@b) = splice(@_,0,shift);
	return 0 unless @a == @b;	# same len?
	while (@a) {
	    return 0 if pop(@a) ne pop(@b);
	}
	return 1;
    }
    if (&aeq($len,@foo[1..$len],0+@bar,@bar)) { ... }

=item split /PATTERN/,EXPR,LIMIT
X<split>

=item split /PATTERN/,EXPR

=item split /PATTERN/

=item split

=begin original

Splits the string EXPR into a list of strings and returns that list.  By
default, empty leading fields are preserved, and empty trailing ones are
deleted.  (If all fields are empty, they are considered to be trailing.)

=end original

문자열 EPR 을 문자열의 리스트 로 분할한 리스트를 반환합니다.
기본값으로는 줄의 첫번째의 공백은 보존되고, 끝단의 공백은 제거됩니다.
(모든 필드가 빌 경우, 이것은 끝단인 것으로 취급됩니다.)

=begin original

In scalar context, returns the number of fields found and splits into
the C<@_> array.  Use of split in scalar context is deprecated, however,
because it clobbers your subroutine arguments.

=end original

스칼라컨텍스트인 경우에는 발견한 필드의 수를 반환하고,
배열 C<@_> 에 분할결과를 설정합니다.
그러나 스칼라 컨텍스트에서의 split 의 사용은 추천하지 않습니다.
서브루틴의 인수를 덮어써버리기 때문입니다.

=begin original

If EXPR is omitted, splits the C<$_> string.  If PATTERN is also omitted,
splits on whitespace (after skipping any leading whitespace).  Anything
matching PATTERN is taken to be a delimiter separating the fields.  (Note
that the delimiter may be longer than one character.)

=end original

EXPR 을 생략하면, 문자열 C<$_> 를 split 합니다.
만약 PATTERN 을 생략하면 
(맨앞의 공백문자를 스킵한 뒤) 공백으로 split 합니다.
PATTERN 에 매치하는 것은 필드를 분할하는 구분자로 취급됩니다.
(구분자는 1문자뿐만 아닙니다)

=begin original

If LIMIT is specified and positive, it represents the maximum number
of fields the EXPR will be split into, though the actual number of
fields returned depends on the number of times PATTERN matches within
EXPR.  If LIMIT is unspecified or zero, trailing null fields are
stripped (which potential users of C<pop> would do well to remember).
If LIMIT is negative, it is treated as if an arbitrarily large LIMIT
had been specified.  Note that splitting an EXPR that evaluates to the
empty string always returns the empty list, regardless of the LIMIT
specified.

=end original

정수의 LIMIT 를 지정한 경우에는 EXPR 이 분할된 필드의 최대수를 
나타내지만 실제로 반환되는 필드의 수가 EXPR의 안에서 몇번 PATTERN 이 
매치하는 가에 의존합니다.
LIMIT 을 지정하지않거나 제로라면 끝단의 빈 필드를 버립니다
(C<pop> 를 수행하는 때에는 신경쓰지 않으면 안됩니다).
LIMIT 가 음수라면 LIMIT 에 임의의 크기의 수를 지정한 것과 같아집니다.
빈 문자열로 평가된 EXPR 을 분할하는 경우, LIMIT 에서의 지정에 상관없이 
항상 빈 리스트가 반환하는 것에 주의해주세요.

=begin original

A pattern matching the null string (not to be confused with
a null pattern C<//>, which is just one member of the set of patterns
matching a null string) will split the value of EXPR into separate
characters at each point it matches that way.  For example:

=end original

빈 문자열에 매치하는 패턴 (null 패턴 C<//> 과 혼동하지 말아주세요.
이것은 빈문자열에 매치하는 패턴의 하나밖에 없습니다) 은 
어느 장소에서도 매치하고, EXPR 의 값을 1문자씩 분할합니다.
예를들면:

    print join(':', split(/ */, 'hi there'));

=begin original

produces the output 'h:i:t:h:e:r:e'.

=end original

는 'h:i:t:h:e:r:e' 라고 출력하게 됩니다.

=begin original

As a special case for C<split>, using the empty pattern C<//> specifically
matches only the null string, and is not be confused with the regular use
of C<//> to mean "the last successful pattern match".  So, for C<split>,
the following:

=end original

C<split> 에 관한 특별한 경우로 특히 빈패턴 C<//> 는 빈문자열에 
매치하기때문에 "마지막에 성공한 패턴매치" 를 의미하는 일반적인 C<//> 의
사용법과 혼동하지 마세요.
그리고, C<split> 의 경우는 아래처럼 하면:

    print join(':', split(//, 'hi there'));

=begin original

produces the output 'h:i: :t:h:e:r:e'.

=end original

'h:i: :t:h:e:r:e' 라고 출력하게 됩니다.

=begin original

Empty leading fields are produced when there are positive-width matches at
the beginning of the string; a zero-width match at the beginning of
the string does not produce an empty field. For example:

=end original

맨앞의 빈필드는 문자열의 맨앞에서 0 이 아닌 폭으로 매치한 경우는 
생성됩니다. 폭 0 으로 매치한 경우는 생성되지 않습니다.
예를들면:

   print join(':', split(/(?=\w)/, 'hi there!'));

=begin original

produces the output 'h:i :t:h:e:r:e!'. Empty trailing fields, on the other
hand, are produced when there is a match at the end of the string (and
when LIMIT is given and is not 0), regardless of the length of the match.
For example:

=end original

이것의 출력은 'h:i :t:h:e:r:e' 가 됩니다.
한편, 끝단의 빈 필드는 매칭의 길이에 상관없이 문자열의 마지막에 
매칭한(그리고 LIMIT 가 주어져 그것이 0이 아닌)경우에 생성됩니다.
예를들면:

   print join(':', split(//,   'hi there!', -1));
   print join(':', split(/\W/, 'hi there!', -1));

=begin original

produce the output 'h:i: :t:h:e:r:e:!:' and 'hi:there:', respectively,
both with an empty trailing field.

=end original

이것의 출력은 각각 'h:i :t:h:e:r:e!' 및 'hi:there:' 가 되고, 
양쪽다 끝단에 빈 필드가 붙습니다.

=begin original

The LIMIT parameter can be used to split a line partially

=end original

LIMIT 를 사용하면, 행을 부분적으로 split 할 수 있습니다.

    ($login, $passwd, $remainder) = split(/:/, $_, 3);

=begin original

When assigning to a list, if LIMIT is omitted, or zero, Perl supplies
a LIMIT one larger than the number of variables in the list, to avoid
unnecessary work.  For the list above LIMIT would have been 4 by
default.  In time critical applications it behooves you not to split
into more fields than you really need.

=end original

리스트에 대입할 때, LIMIT 를 생략하거나 0인 경우, Perl 은 쓸데없는 
일을 피하기 위해 그 리스트의 변수의 수보다 하나 큰 LIMIT 가 주어진 것으로
처리를 수행합니다. 위의 리스트의 경우에는 LIMIT 는 기본값으로 4가 됩니다.
시간이 문제가 되는 어플리케이션에서는 필요이상의 필드로 나누지 않도록 할 
필요가 있습니다.

=begin original

If the PATTERN contains parentheses, additional list elements are
created from each matching substring in the delimiter.

=end original

PATTERN 에 괄호가 포함되어 있으면 구분자 안의 부분문자열에 매치하는 것도 
리스트 요소에 포함되게 됩니다.

    split(/([,-])/, "1-10,20", 3);

=begin original

produces the list value

=end original

는 아래의 리스트 값을 생성합니다.

    (1, '-', 10, ',', 20)

=begin original

If you had the entire header of a normal Unix email message in $header,
you could split it up into fields and their values this way:

=end original

$header 에 Unix E 메일메시징 헤더 전체가 들어 있다고 하면
아래처럼해서 필드와 그 값으로 분할할 수 있습니다:

    $header =~ s/\n\s+/ /g;  # fix continuation lines
    %hdrs   =  (UNIX_FROM => split /^(\S*?):\s*/m, $header);

=begin original

The pattern C</PATTERN/> may be replaced with an expression to specify
patterns that vary at runtime.  (To do runtime compilation only once,
use C</$variable/o>.)

=end original

/PATTERN/ 은, 실행시에 변하는 패턴을 지정하는 식으로 바꿀 수 있습니다.
(실행시의 컴파일을 한번만 하위해 /$variable/o 를 사용해주세요.)

=begin original

As a special case, specifying a PATTERN of space (S<C<' '>>) will split on
white space just as C<split> with no arguments does.  Thus, S<C<split(' ')>> can
be used to emulate B<awk>'s default behavior, whereas S<C<split(/ /)>>
will give you as many null initial fields as there are leading spaces.
A C<split> on C</\s+/> is like a S<C<split(' ')>> except that any leading
whitespace produces a null first field.  A C<split> with no arguments
really does a S<C<split(' ', $_)>> internally.

=end original

특별한 경우로 PATTERN 에 스페이스 (S<C' '>>) 를 지정하면 
인수없는 C<split> 처럼 공백으로 split 를 수행합니다.
즉, S<C<split(' ')>> 은 B<awk> 의 기본 동작을 에뮬레이트 하기 위해 
사용할 수 있고, S<C<split(/ /)>> 는 행의 맨앞의 스페이스의 수에 따라 
빈 필드가 될 수 있습니다.
C<split /\s+/> 은 S<C<split(' ')>> 와 같지만, 
맨앞의 공백은 선두의 빈 필드가 됩니다.
인수없는 C<split> 은 내부적으로는 S<C<split(' ', $_)>> 를 실행합니다.

=begin original

A PATTERN of C</^/> is treated as if it were C</^/m>, since it isn't
much use otherwise.

=end original

PATTERN 에 C</^/> 를 지정하면 C</^/m> 으로 취급됩니다.
다른 의미로 사용되는 것은 없기때문입니다.

=begin original

Example:

=end original

예제:

    open(PASSWD, '/etc/passwd');
    while (<PASSWD>) {
        chomp;
        ($login, $passwd, $uid, $gid,
         $gcos, $home, $shell) = split(/:/);
	#...
    }

=begin original

As with regular pattern matching, any capturing parentheses that are not
matched in a C<split()> will be set to C<undef> when returned:

=end original

일반적인 패턴매칭에서 C<split()> 으로 매치하지 않은 모든 괄호는 
반환될 때에는 C<undef> 가 설정됩니다.

    @fields = split /(A)|B/, "1A2B3";
    # @fields is (1, 'A', 2, undef, 3)

=item sprintf FORMAT, LIST
X<sprintf>

=begin original

Returns a string formatted by the usual C<printf> conventions of the C
library function C<sprintf>.  See below for more details
and see L<sprintf(3)> or L<printf(3)> on your system for an explanation of
the general principles.

=end original

보통의 C 언어의 C<printf> 기법의 포맷ㅡ로 정형된 문자열을 반환합니다.
일반적인 원칙의 설명에 대해서는 아래의 설명과 시스템의 L<sprintf(3)> 
또는 L<printf(3)> 의 설명을 참고해주세요.

=begin original

For example:

=end original

예제:

        # Format number with up to 8 leading zeroes
        $result = sprintf("%08d", $number);

        # Round number to 3 digits after decimal point
        $rounded = sprintf("%.3f", $number);

=begin original

Perl does its own C<sprintf> formatting--it emulates the C
function C<sprintf>, but it doesn't use it (except for floating-point
numbers, and even then only the standard modifiers are allowed).  As a
result, any non-standard extensions in your local C<sprintf> are not
available from Perl.

=end original

Perl 은 C<sprintf> 포맷처리를 자력으로 수행합빈다.
이것은 C 의 C<sprintf> 함수를 에뮬레이트하지만, 
C 의 함수는 사용하지 않습니다(부동소수점을 빼지만, 그래도 표준의 
기술자만을 이용할 수 있습니다).
따라, 로컬의 비표준의 C<sprintf> 확장기능은 Perl 에서는 사용할 수 없습니다.

=begin original

Unlike C<printf>, C<sprintf> does not do what you probably mean when you
pass it an array as your first argument. The array is given scalar context,
and instead of using the 0th element of the array as the format, Perl will
use the count of elements in the array as the format, which is almost never
useful.

=end original

C<sprintf> 와는 달리, C<sprintf> 의 최초의 인수에 배열을 넘겨도 
당신이 원하는 대로 동작하지 않습니다.
배열은 스칼라 컨텍스트에서 건네지기때문에 배열의 0 번째의 요소가 아닌
배열의 요소수를 패멋으로 취급합니다.
이것은 쓸모없습니다.

=begin original

Perl's C<sprintf> permits the following universally-known conversions:

=end original

Perl 의 C<sprintf> 는 아래의 일반적으로 알려진 변수를 지원하고 있습니다:

   %%	a percent sign
   %c	a character with the given number
   %s	a string
   %d	a signed integer, in decimal
   %u	an unsigned integer, in decimal
   %o	an unsigned integer, in octal
   %x	an unsigned integer, in hexadecimal
   %e	a floating-point number, in scientific notation
   %f	a floating-point number, in fixed decimal notation
   %g	a floating-point number, in %e or %f notation

=begin original

In addition, Perl permits the following widely-supported conversions:

=end original

거기에 Perl 에서는 아래의 자주쓰이는 변수도 지원합니다:

   %X	like %x, but using upper-case letters
   %E	like %e, but using an upper-case "E"
   %G	like %g, but with an upper-case "E" (if applicable)
   %b	an unsigned integer, in binary
   %B	like %b, but using an upper-case "B" with the # flag
   %p	a pointer (outputs the Perl value's address in hexadecimal)
   %n	special: *stores* the number of characters output so far
        into the next variable in the parameter list

=begin original

Finally, for backward (and we do mean "backward") compatibility, Perl
permits these unnecessary but widely-supported conversions:

=end original

마지막에 과거와의 호환성(이것은 "과거"라고 생각하고 있습니다)을 위해서 
Perl 은 아래의 쓸데없지만 널리 쓰이는 변수도 지원하고 있습니다.

   %i	a synonym for %d
   %D	a synonym for %ld
   %U	a synonym for %lu
   %O	a synonym for %lo
   %F	a synonym for %f

=begin original

Note that the number of exponent digits in the scientific notation produced
by C<%e>, C<%E>, C<%g> and C<%G> for numbers with the modulus of the
exponent less than 100 is system-dependent: it may be three or less
(zero-padded as necessary).  In other words, 1.23 times ten to the
99th may be either "1.23e99" or "1.23e099".

=end original

C<%e>, C<%E>, C<%g>, C<%G> 에 대해서, 지수부가 100 미만일 경우 
지수부의 과학적인 표기법은 시스템 의존인 것에 주의해주세요:
3자리일지도 모르고, 그 이하일지도 모릅니다(필요에 따라서 0으로 
패딩됩니다).
바꿔 말하면, 1.23 곱하기 10의 99 승은 "1.23e99" 일지도 모고,
"1.23e099" 일지도 모릅니다.

=begin original

Between the C<%> and the format letter, you may specify a number of
additional attributes controlling the interpretation of the format.
In order, these are:

=end original

C<%> 와 포맷문자 사이에, 포맷의 해석을 제어하기 위해, 
임의의 수의 추가 속성을 지정할 수 있습니다.
순번으로 아래와 가튼 것이 있습니다:

=over 4

=item format parameter index

=begin original

An explicit format parameter index, such as C<2$>. By default sprintf
will format the next unused argument in the list, but this allows you
to take the arguments out of order, e.g.:

=end original


  printf '%2$d %1$d', 12, 34;      # prints "34 12"
  printf '%3$d %d %1$d', 1, 2, 3;  # prints "3 1 1"

=item flags

=begin original

one or more of:

=end original

아래 중의 하나 이상은 지수지정을 할 수 있습니다:

   space   prefix positive number with a space
   +       prefix positive number with a plus sign
   -       left-justify within the field
   0       use zeros, not spaces, to right-justify
   #       ensure the leading "0" for any octal,
           prefix non-zero hexadecimal with "0x" or "0X",
           prefix non-zero binary with "0b" or "0B"

=begin original

For example:

=end original

예제:

  printf '<% d>',  12;   # prints "< 12>"
  printf '<%+d>',  12;   # prints "<+12>"
  printf '<%6s>',  12;   # prints "<    12>"
  printf '<%-6s>', 12;   # prints "<12    >"
  printf '<%06s>', 12;   # prints "<000012>"
  printf '<%#o>',  12;   # prints "<014>"
  printf '<%#x>',  12;   # prints "<0xc>"
  printf '<%#X>',  12;   # prints "<0XC>"
  printf '<%#b>',  12;   # prints "<0b1100>"
  printf '<%#B>',  12;   # prints "<0B1100>"

=begin original

When a space and a plus sign are given as the flags at once,
a plus sign is used to prefix a positive number.

=end original

공백과 플러스기호가 플래그로 동시에 주어지면, 플러스 기호는 정수로 
전치하기 위해 사용됩니다.

  printf '<%+ d>', 12;   # prints "<+12>"
  printf '<% +d>', 12;   # prints "<+12>"

=begin original

When the # flag and a precision are given in the %o conversion,
the precision is incremented if it's necessary for the leading "0".

=end original

%o 변환에 # 플래그와 정도가 주어지면, 맨 앞의 "0" 이 필요한 경우는 
정도에 1이 더해집니다.

  printf '<%#.5o>', 012;      # prints "<00012>"
  printf '<%#.5o>', 012345;   # prints "<012345>"
  printf '<%#.0o>', 0;        # prints "<0>"

=item vector flag

=begin original

This flag tells perl to interpret the supplied string as a vector of
integers, one for each character in the string. Perl applies the format to
each integer in turn, then joins the resulting strings with a separator (a
dot C<.> by default). This can be useful for displaying ordinal values of
characters in arbitrary strings:

=end original

이 플래그는 perl 에 주어진 문자열을 문자마다 한씩 정수의 벡터로써 해석시킵니다.
Perl 은 각 수치를 포맷해서, 그리고 결과의 문자열을 구분자로(기본값으로는 C<.>) 로 연결합니다.
이것은 임의의 문자열의 문자를 순서붙은 값으로 표시하기에 편리합니다:

  printf "%vd", "AB\x{100}";           # prints "65.66.256"
  printf "version is v%vd\n", $^V;     # Perl's version

=begin original

Put an asterisk C<*> before the C<v> to override the string to
use to separate the numbers:

=end original

아스타리스크 C<*> 를 C<v> 의 앞에 놓으면 수치를 나누기 위해 사용되는 문자열을
덮어씁니다:

  printf "address is %*vX\n", ":", $addr;   # IPv6 address
  printf "bits are %0*v8b\n", " ", $bits;   # random bitstring

=begin original

You can also explicitly specify the argument number to use for
the join string using e.g. C<*2$v>:

=end original

또, C<*2$v> 처럼 연결하는 문자열로 사용하는 인수의 번호를 명시적으로 
지정할 수 있습니다.

  printf '%*4$vX %*4$vX %*4$vX', @addr[1..3], ":";   # 3 IPv6 addresses

=item (minimum) width

=begin original

Arguments are usually formatted to be only as wide as required to
display the given value. You can override the width by putting
a number here, or get the width from the next argument (with C<*>)
or from a specified argument (with e.g. C<*2$>):

=end original

인수는 보통은 값을 표시하기에 필요한 적당한 폭으로 포맷됩니다.
이것으로 수치를 놓을까 (C<*> 로) 다음의 인수가 (C<*2$> 로) 명시적으로 
지정한 인수로 폭을 덮어쓸 수 있습니다.

  printf '<%s>', "a";       # prints "<a>"
  printf '<%6s>', "a";      # prints "<     a>"
  printf '<%*s>', 6, "a";   # prints "<     a>"
  printf '<%*2$s>', "a", 6; # prints "<     a>"
  printf '<%2s>', "long";   # prints "<long>" (does not truncate)

=begin original

If a field width obtained through C<*> is negative, it has the same
effect as the C<-> flag: left-justification.

=end original

C<*> 를 통해서 얻은 필드의 값이 음수인 경우 C<-> 플래와 같은 
효과가 있습니다.

=item precision, or maximum width
X<precision>

=begin original

You can specify a precision (for numeric conversions) or a maximum
width (for string conversions) by specifying a C<.> followed by a number.
For floating point formats, with the exception of 'g' and 'G', this specifies
the number of decimal places to show (the default being 6), e.g.:

=end original

C<.> 의 뒤에 수치를 지정하는 것으로 (수치변환인 경우) 정도나 (문자열변환인 경우) 최대폭을 지정할 수 있습니다.
소수점수 포맷인 경우, 'g' 와 'G' 를 빼고, 표시하는 소수점이하의 
자릿수를 지정합니다(기본값은 6 입니다).
예제:

  # these examples are subject to system-specific variation
  printf '<%f>', 1;    # prints "<1.000000>"
  printf '<%.1f>', 1;  # prints "<1.0>"
  printf '<%.0f>', 1;  # prints "<1>"
  printf '<%e>', 10;   # prints "<1.000000e+01>"
  printf '<%.1e>', 10; # prints "<1.0e+01>"

=begin original

For 'g' and 'G', this specifies the maximum number of digits to show,
including prior to the decimal point as well as after it, e.g.:

=end original

'g' 와 'G' 인 경우, 이것은 표시하는 숫자값의 수를 지정합니다;
이것에는 소수점 앞의 수치와 뒤의 수치를 포함합니다.
예제:

  # these examples are subject to system-specific variation
  printf '<%g>', 1;        # prints "<1>"
  printf '<%.10g>', 1;     # prints "<1>"
  printf '<%g>', 100;      # prints "<100>"
  printf '<%.1g>', 100;    # prints "<1e+02>"
  printf '<%.2g>', 100.01; # prints "<1e+02>"
  printf '<%.5g>', 100.01; # prints "<100.01>"
  printf '<%.4g>', 100.01; # prints "<100>"

=begin original

For integer conversions, specifying a precision implies that the
output of the number itself should be zero-padded to this width,
where the 0 flag is ignored:

=end original

정수변환인 경우, 정도를 지정하면 수치자체의 출력은 이 폭에 0 으로 
패딩해야하는 것을 암시적으로 나타내는 것으로 0 플래그는 무시됩니다.

  printf '<%.6d>', 1;      # prints "<000001>"
  printf '<%+.6d>', 1;     # prints "<+000001>"
  printf '<%-10.6d>', 1;   # prints "<000001    >"
  printf '<%10.6d>', 1;    # prints "<    000001>"
  printf '<%010.6d>', 1;   # prints "<    000001>"
  printf '<%+10.6d>', 1;   # prints "<   +000001>"

  printf '<%.6x>', 1;      # prints "<000001>"
  printf '<%#.6x>', 1;     # prints "<0x000001>"
  printf '<%-10.6x>', 1;   # prints "<000001    >"
  printf '<%10.6x>', 1;    # prints "<    000001>"
  printf '<%010.6x>', 1;   # prints "<    000001>"
  printf '<%#10.6x>', 1;   # prints "<  0x000001>"

=begin original

For string conversions, specifying a precision truncates the string
to fit in the specified width:

=end original

문자열 변환의 경우, 정도를 지정하면, 지정된 폭에 맞도록 문자열을 
자를 수 있습니다:

  printf '<%.5s>', "truncated";   # prints "<trunc>"
  printf '<%10.5s>', "truncated"; # prints "<     trunc>"

=begin original

You can also get the precision from the next argument using C<.*>:

=end original

C<.*> 를 사용해서 정도를 다음의 인수부터 얻을 수도 있습니다:

  printf '<%.6x>', 1;       # prints "<000001>"
  printf '<%.*x>', 6, 1;    # prints "<000001>"

=begin original

If a precision obtained through C<*> is negative, it has the same
effect as no precision.

=end original

C<*> 에 의해서 얻어진 정도가 음수인 경우, 정도가 지정되지 않은 것과 
같습니다.

  printf '<%.*s>',  7, "string";   # prints "<string>"
  printf '<%.*s>',  3, "string";   # prints "<str>"
  printf '<%.*s>',  0, "string";   # prints "<>"
  printf '<%.*s>', -1, "string";   # prints "<string>"

  printf '<%.*d>',  1, 0;   # prints "<0>"
  printf '<%.*d>',  0, 0;   # prints "<>"
  printf '<%.*d>', -1, 0;   # prints "<0>"

=begin original

You cannot currently get the precision from a specified number,
but it is intended that this will be possible in the future using
e.g. C<.*2$>:

=end original

현재 정도를 지정한 수치에서 얻을 수는 없지만, 
앞으로는 C<.*2$> 처럼 해서 가능하도록 하고 있습니다:

  printf '<%.*2$x>', 1, 6;   # INVALID, but in future will print "<000001>"

=item size

=begin original

For numeric conversions, you can specify the size to interpret the
number as using C<l>, C<h>, C<V>, C<q>, C<L>, or C<ll>. For integer
conversions (C<d u o x X b i D U O>), numbers are usually assumed to be
whatever the default integer size is on your platform (usually 32 or 64
bits), but you can override this to use instead one of the standard C types,
as supported by the compiler used to build Perl:

=end original

수치 변환에서는 C<l>, C<h>, C<V>, C<q>, C<L>, C<ll> 을 사용해서 해석하는 
수치의 크기를 지정할 수 있습니다.
정수변환 (C<d u o x X b i D U O>) 에서는 수치는 통상 플랫폼의 기본값의 
정수의 사이즈(보통 32비트나 64비트) 를 가정합니다만, 
이것을 Perl 이 빌드된 컴파일러가 지원하는 표준 C 의 형태의 하나로
덮어쓸 수 있습니다:

=begin original

   l           interpret integer as C type "long" or "unsigned long"
   h           interpret integer as C type "short" or "unsigned short"
   q, L or ll  interpret integer as C type "long long", "unsigned long long".
               or "quads" (typically 64-bit integers)

=end original

   l           정수를 C 의 "long" 또는 "unsinged long" 으로 해석함
   h           정수를 C 의 "short" 또는 "unsinged short" 로 해석함 
   q, L or ll  정수를 C 의 "long long", "unsinged long long ",
               "quads"(전형적으로는 64비트 정수) 중 어느것으로 해석함

=begin original

The last will produce errors if Perl does not understand "quads" in your
installation. (This requires that either the platform natively supports quads
or Perl was specifically compiled to support quads.) You can find out
whether your Perl supports quads via L<Config>:

=end original

마지막의 에제에서 Perl 이 64비트 정수를 이해하지 않는 경우 에러가 됩니다.
(이 때문에 플랫폼이 네이티브하게 64비트 정수를 지원하는 가 
Perl 이 특히 64비트 정수를 지원하는 것처럼 컴파일될 필요가 있습니다.)
Perl 이 64 비트 정수를 지원하는 지 어떤지는 L<Config> 를 사용해서 
조사할 수 있습니다:

	use Config;
	($Config{use64bitint} eq 'define' || $Config{longsize} >= 8) &&
		print "quads\n";

=begin original

For floating point conversions (C<e f g E F G>), numbers are usually assumed
to be the default floating point size on your platform (double or long double),
but you can force 'long double' with C<q>, C<L>, or C<ll> if your
platform supports them. You can find out whether your Perl supports long
doubles via L<Config>:

=end original

부동소수점 숫자변환 (C<e f g E F G>) 에서는 보통은 플랫폼의 기본값의 
부동소수점 수의 사이즈(double 이나 long double) 을 가정합니다.
Perl 이 long double 을 지원하는지 어떤지는 L<Config> 를 사용해서 
조사할 수 있습니다.

	use Config;
	$Config{d_longdbl} eq 'define' && print "long doubles\n";

=begin original

You can find out whether Perl considers 'long double' to be the default
floating point size to use on your platform via L<Config>:

=end original

Perl 이 'long double' 을 기본값의 부동소수점 수로 취급하는지 어떤지는 
L<Config>  를 사용해서 알 수 있습니다:

        use Config;
        ($Config{uselongdouble} eq 'define') &&
                print "long doubles by default\n";

=begin original

It can also be the case that long doubles and doubles are the same thing:

=end original

long double 과 double 이 같은 경우도 있습니다:

        use Config;
        ($Config{doublesize} == $Config{longdblsize}) &&
                print "doubles are long doubles\n";

=begin original

The size specifier C<V> has no effect for Perl code, but it is supported
for compatibility with XS code; it means 'use the standard size for
a Perl integer (or floating-point number)', which is already the
default for Perl code.

=end original

사이즈의 지정자 C<V> 는 Perl 의 코드에는 아무런 영향도 없지만, 이것은 
XS 코드와의 호환성을 위해 지원고 있습니다; 이것은 "Perl 정수 (또는 
부동소수점수" 로써 표준적인 사이즈를 사용하는" 것을 의미하고, 이것은 
Perl 의 코드에서는 이미 기본값입니다.

=item order of arguments

=begin original

Normally, sprintf takes the next unused argument as the value to
format for each format specification. If the format specification
uses C<*> to require additional arguments, these are consumed from
the argument list in the order in which they appear in the format
specification I<before> the value to format. Where an argument is
specified using an explicit index, this does not affect the normal
order for the arguments (even when the explicitly specified index
would have been the next argument in any case).

=end original

보통 sprintf 는 각 포맷지정에 대해서 사용되지 않은 다음의 인수를 
포맷하는 값으로 사용합니다.
추가의 인수를 요구하기 위해서 포맷 지정 C<*> 를 사용하면, 
이것들은 포맷하는 값의 I<앞> 의 포맷지정에 나타나는 순서로 
인수리스트에서 소비됩니다.
인수의 위치가 명시적인 인덱스를 사용해서 지정된 경우, 
(명시적으로 지정한 인덱스가 다음 인수일 경우에도)
이것은 일반적인 인수의 순서에 영향을 주지 않습니다.

=begin original

So:

=end original

그래서:

  printf '<%*.*s>', $a, $b, $c;

=begin original

would use C<$a> for the width, C<$b> for the precision and C<$c>
as the value to format, while:

=end original

라고 하면 C<$a> 를 폭으로 C<$b> 를 정도로 C<$c> 를 포맷의 값으로 
사용합니다만, 한편으로:

  printf '<%*1$.*s>', $a, $b;

=begin original

would use C<$a> for the width and the precision, and C<$b> as the
value to format.

=end original

라고 하면 C<$a> 를 폭과 정도로, C<$b> 를 포맷의 값으로 사용합니다.

=begin original

Here are some more examples - beware that when using an explicit
index, the C<$> may need to be escaped:

=end original

아래에 보다 자세한 예제를 나타냅니다 - 명시적으로 인덱스를 사용하는 경우, 
C<$> 는 이스케이프할 필요가 있는 것에 주의해주세요.

  printf "%2\$d %d\n",    12, 34;		# will print "34 12\n"
  printf "%2\$d %d %d\n", 12, 34;		# will print "34 12 34\n"
  printf "%3\$d %d %d\n", 12, 34, 56;		# will print "56 12 34\n"
  printf "%2\$*3\$d %d\n", 12, 34, 3;		# will print " 34 12\n"

=back

=begin original

If C<use locale> is in effect, and POSIX::setlocale() has been called,
the character used for the decimal separator in formatted floating
point numbers is affected by the LC_NUMERIC locale.  See L<perllocale>
and L<POSIX>.

=end original

C<use locale> 이 유효하고, POSIX::setlocale() 이 호출된 경우, 
포맷된 부동소수점수의 소수점으로 사용되는 문자는 
LC_NUMERIC 로케일의 영향을 받습니다.
L<perllocale> 과 L<POSIX> 를 참조해주세요.

=item sqrt EXPR
X<sqrt> X<root> X<square root>

=item sqrt

=begin original

Return the square root of EXPR.  If EXPR is omitted, returns square
root of C<$_>.  Only works on non-negative operands, unless you've
loaded the standard Math::Complex module.

=end original

EXPR 의 평방근을 반환합니다.
EXPR 을 생략하면 C<$_> 의 평방근을 반환합니다.
표준의 Math::Complex 모듈을 사용하지 않는 경우는 
음수의 인수는 취급할 수 없습니다.

    use Math::Complex;
    print sqrt(-2);    # prints 1.4142135623731i

=item srand EXPR
X<srand> X<seed> X<randseed>

=item srand

=begin original

Sets the random number seed for the C<rand> operator.

=end original

rnad 여난자를 위해 시드 값을 설정합니다.

=begin original

The point of the function is to "seed" the C<rand> function so that
C<rand> can produce a different sequence each time you run your
program.

=end original

이 함수의 포인트는 프로그램을 실행하는 것으로 C<rand> 함수가 
다른 난수열을 생성할 수 있도록 C<rand> 함수의 "종류"를 설정하는 것입니다.

=begin original

If srand() is not called explicitly, it is called implicitly at the
first use of the C<rand> operator.  However, this was not the case in
versions of Perl before 5.004, so if your script will run under older
Perl versions, it should call C<srand>.

=end original

srand() 가 명시적으로 호출되지 않은 경우, 최초에 C<rand> 연산자를 사용한 
시점에서 암묵적으로 호출됩니다.
그러나, 이것은 Perl 의 버젼이 5.004 보다 앞에서는 수행되지 않기때문에 
프로그램이 낡은 Perl 로 실행되는 경우는 C<srand> 를 호출해야합니다.

=begin original

Most programs won't even call srand() at all, except those that
need a cryptographically-strong starting point rather than the
generally acceptable default, which is based on time of day,
process ID, and memory allocation, or the F</dev/urandom> device,
if available.

=end original

대부분의 프로그램은 원래 srand() 를 부를 필요도 없습니다;
예외는 시각, 프로세스 ID, 메모리 배치, (이용가능하다면) F</dev/urandom> 
디바이스같은 일반적으로 받아들일 수 있는 기본값보다도 암호학적으로 
강력한 개시점이 필요한 경우입니다.

=begin original

You can call srand($seed) with the same $seed to reproduce the
I<same> sequence from rand(), but this is usually reserved for
generating predictable results for testing or debugging.
Otherwise, don't call srand() more than once in your program.

=end original

같은 $seed 를 사용해서 srand($seed) 를 호출하는 것으로 rand() 에서 I<같은>
난수형을 재현할 수 있지만, 이것은 보통 테스트나 디버그를 위해서 예측되는 
결과를 생성하기 위해 사용됩니다.
그 이외에서는 srand() 를 프로그램 안에서 2 회 이상 호출하지 않도록 하세요.

=begin original

Do B<not> call srand() (i.e. without an argument) more than once in
a script.  The internal state of the random number generator should
contain more entropy than can be provided by any seed, so calling
srand() again actually I<loses> randomness.

=end original

srand() (인수없는)를 프로그램 안에서 I<여러번 호출해서는 안됩니다>.
난수생성기의 내부상태는 어떤 종류에 의해 제공되는 것보다도 
높은 엔트로피를 가지고 있기 때문에 srand() 를 다시 호출하면 
랜덤성이 I<상실됩니다>.

=begin original

Most implementations of C<srand> take an integer and will silently
truncate decimal numbers.  This means C<srand(42)> will usually
produce the same results as C<srand(42.1)>.  To be safe, always pass
C<srand> an integer.

=end original

C<srand> 의 대부분의 구성에서는 정수를 얻어서, 소수를 암묵적으로 내립니다.
이것은 C<srand(42)> 는 보통 C<srand(42.1)> 과 같은 결과가 되는 것을 
의미합니다.
안전을위해서 C<srand> 에는 항상 정수를 건내도록 합시다.

=begin original

In versions of Perl prior to 5.004 the default seed was just the
current C<time>.  This isn't a particularly good seed, so many old
programs supply their own seed value (often C<time ^ $$> or C<time ^
($$ + ($$ << 15))>), but that isn't necessary any more.

=end original

5.004 이전의 Perl 에서는 기본값의 시드값은 현재의 C<time> 이었습니다.
이것은 특히 좋은 시드값이 아니었기 때문에, 
많은 낡은 프로그램은 자력으로 시드값을 설정하고 있습니다만(C< time ^ $$ > 또는 
C<time ^ ($$ + ($$ << 15)) 가 자주 사용됩니다), 
이미 이것은 필요없습니다.

=begin original

For cryptographic purposes, however, you need something much more random 
than the default seed.  Checksumming the compressed output of one or more
rapidly changing operating system status programs is the usual method.  For
example:

=end original

그러나, 암호처리에는 보다 랜덤한 값을 사용할 필요가 있습니다.
급격하게 변화하는 OS 의 상태값 프로그램의 출력을 하나 또는 복수를 이용해 
압축해서 체크섬을 얻는 것 같은 것이 보통 수행됩니다.
예를들면:

    srand (time ^ $$ ^ unpack "%L*", `ps axww | gzip -f`);

=begin original

If you're particularly concerned with this, see the C<Math::TrulyRandom>
module in CPAN.

=end original

특히 이런 것에 관심이 있는 경우는 
CPAN 의 C<Math::TrulyRandom> 모듈을 참조해주세요.

=begin original

Frequently called programs (like CGI scripts) that simply use

=end original

(CGI 스크립트처럼) 간결하게 호출되는 프로그램으로 단순히 

    time ^ $$

=begin original

for a seed can fall prey to the mathematical property that

=end original

를 시드로 사용하면 3 번에 한번은 아래의 수학특성 

    a^b == (a+1)^(b+1)

=begin original

one-third of the time.  So don't do that.

=end original

이 됩니다.
따라서 이런 것은 해서는 안됩니다.

=item stat FILEHANDLE
X<stat> X<file, status> X<ctime>

=item stat EXPR

=item stat DIRHANDLE

=item stat

=begin original

Returns a 13-element list giving the status info for a file, either
the file opened via FILEHANDLE or DIRHANDLE, or named by EXPR.  If EXPR is 
omitted, it stats C<$_>.  Returns a null list if the stat fails.  Typically
used as follows:

=end original

FILEHANDLE 이 DIRHANDLE 을 통해서 오픈되는 파일이 
EXPR 로 지정된 파일의 정보를 주는 13 요소의 리스트를 반환합니다.
EXPR 이 생략되면 C<$_> 가 이용됩니다.
stat 에 실패한 경우에는 빈 리스트를 반환합니다.
보통은 아래처럼 해서 사용합니다:

    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
       $atime,$mtime,$ctime,$blksize,$blocks)
           = stat($filename);

=begin original

Not all fields are supported on all filesystem types.  Here are the
meanings of the fields:

=end original

모든 파일시스템에서 모든 필드를 지원하는 것은 아닙니다.
필드의 의미는 아래와 같습니다.

=begin original

  0 dev      device number of filesystem
  1 ino      inode number
  2 mode     file mode  (type and permissions)
  3 nlink    number of (hard) links to the file
  4 uid      numeric user ID of file's owner
  5 gid      numeric group ID of file's owner
  6 rdev     the device identifier (special files only)
  7 size     total size of file, in bytes
  8 atime    last access time in seconds since the epoch
  9 mtime    last modify time in seconds since the epoch
 10 ctime    inode change time in seconds since the epoch (*)
 11 blksize  preferred block size for file system I/O
 12 blocks   actual number of blocks allocated

=end original

  0 dev      파일시스템의 디바이스 번호
  1 ino      inode 번호
  2 mode     파일모드(타입과 퍼미션)
  3 nlink    파일로의 (하드) 링크의 수
  4 uid      파일 소유자의 유저 ID 수치 
  5 gid      파일 소유자의 그룹 ID 수치 
  6 rdev     디바이스 식별자(특수 파일만) 
  7 size     파일사이즈(바이트 단위)
  8 atime    기원에서 마지막에 접근된 시각까지의 초수
  9 mtime    기원에서 최후에 수정(modify) 된 시각까지의 초수
 10 ctime    기원에서 inode 변경(change) 된 시각까지의 초(*)
 11 blksize  파일시스템 I/O 에 적합한 블록사이즈
 12 blocks   실제로 할당된 블록의 수 

=begin original

(The epoch was at 00:00 January 1, 1970 GMT.)

=end original

(기원은 GMT 로 1970/01/01 00:00:00)

=begin original

(*) Not all fields are supported on all filesystem types. Notably, the
ctime field is non-portable.  In particular, you cannot expect it to be a
"creation time", see L<perlport/"Files and Filesystems"> for details.

=end original

(*) 모든 필드가 모든 파일시스템 타입에서 지원하고 있는 것은 아닙ㄴ디ㅏ.
명백하게 ctime 의 필드는 이식성이 없습니다.
특히, 이제부터의 "작성시각" 을 상정할 수는 없습니다.
자세한 내용에 대해서는 L<perlport"Files and Filesystems"> 를 참조해주세요.

=begin original

If C<stat> is passed the special filehandle consisting of an underline, no
stat is done, but the current contents of the stat structure from the
last C<stat>, C<lstat>, or filetest are returned.  Example:

=end original

밑줄 뿐인 _ 이라고 하는 특별한 파일핸들을 C<stat> 에 건내면 
실제로는 stat 을 수행하지 않고 stat 구조체에 남아있는 
앞의 stat 이나 파일테스트의 정보가 반환됩니다.
예제:

    if (-x $file && (($d) = stat(_)) && $d < 0) {
	print "$file is executable NFS file\n";
    }

=begin original

(This works on machines only for which the device number is negative
under NFS.)

=end original

(이것은 NFS 을 기반으로 디바이스 번호가 음수가 되는 머신에서만 동작합니다.)

=begin original

Because the mode contains both the file type and its permissions, you
should mask off the file type portion and (s)printf using a C<"%o">
if you want to see the real permissions.

=end original

모드에는 파일타입과 그 권한의 양쪽이 포함되어 있기에 
진짜 권한을 보고싶은 경우는 (s)printf로 C<"%"> 를 사용하는 것으로 
파일타입을 마스크해야 합니다.

    $mode = (stat($filename))[2];
    printf "Permissions are %04o\n", $mode & 07777;

=begin original

In scalar context, C<stat> returns a boolean value indicating success
or failure, and, if successful, sets the information associated with
the special filehandle C<_>.

=end original

스칼라 컨텍스트에서는 C<stat> 은 성공/실패를 나타내는 참거짓값을 반환하고,
성공시에는 특별한 파일핸들 C<_> 에 결부된 정보를 설정합니.

=begin original

The L<File::stat> module provides a convenient, by-name access mechanism:

=end original

L<File::stat> 모듈은 편리한 이름으로 접근 기구를 제공합니다.

    use File::stat;
    $sb = stat($filename);
    printf "File is %s, size is %s, perm %04o, mtime %s\n",
	$filename, $sb->size, $sb->mode & 07777,
	scalar localtime $sb->mtime;

=begin original

You can import symbolic mode constants (C<S_IF*>) and functions
(C<S_IS*>) from the Fcntl module:

=end original

모드 지정 (C<S_IF*>) 과 함수 (C<S_IS*>) 를 Fcntl 모듈에서 
임포트할 수 있습니다.

    use Fcntl ':mode';

    $mode = (stat($filename))[2];

    $user_rwx      = ($mode & S_IRWXU) >> 6;
    $group_read    = ($mode & S_IRGRP) >> 3;
    $other_execute =  $mode & S_IXOTH;

    printf "Permissions are %04o\n", S_IMODE($mode), "\n";

    $is_setuid     =  $mode & S_ISUID;
    $is_directory  =  S_ISDIR($mode);

=begin original

You could write the last two using the C<-u> and C<-d> operators.
The commonly available C<S_IF*> constants are

=end original

마지막의 두개는 C<-u> 와 C<-d> 연산자를 사용해서도 쓸 수 있습니다.
일반적으로 이용가능한 C<S_IF*> 정수는 아래와 같습니다.

    # Permissions: read, write, execute, for user, group, others.

    S_IRWXU S_IRUSR S_IWUSR S_IXUSR
    S_IRWXG S_IRGRP S_IWGRP S_IXGRP
    S_IRWXO S_IROTH S_IWOTH S_IXOTH

    # Setuid/Setgid/Stickiness/SaveText.
    # Note that the exact meaning of these is system dependent.

    S_ISUID S_ISGID S_ISVTX S_ISTXT

    # File types.  Not necessarily all are available on your system.

    S_IFREG S_IFDIR S_IFLNK S_IFBLK S_IFCHR S_IFIFO S_IFSOCK S_IFWHT S_ENFMT

    # The following are compatibility aliases for S_IRUSR, S_IWUSR, S_IXUSR.

    S_IREAD S_IWRITE S_IEXEC

=begin original

and the C<S_IF*> functions are

=end original

일반적으로 이용가능한 C<S_IF*> 함수는 아래와 같습니다.

    S_IMODE($mode)	the part of $mode containing the permission bits
			and the setuid/setgid/sticky bits

    S_IFMT($mode)	the part of $mode containing the file type
			which can be bit-anded with e.g. S_IFREG
                        or with the following functions

    # The operators -f, -d, -l, -b, -c, -p, and -S.

    S_ISREG($mode) S_ISDIR($mode) S_ISLNK($mode)
    S_ISBLK($mode) S_ISCHR($mode) S_ISFIFO($mode) S_ISSOCK($mode)

    # No direct -X operator counterpart, but for the first one
    # the -g operator is often equivalent.  The ENFMT stands for
    # record flocking enforcement, a platform-dependent feature.

    S_ISENFMT($mode) S_ISWHT($mode)

=begin original

See your native chmod(2) and stat(2) documentation for more details
about the C<S_*> constants.  To get status info for a symbolic link
instead of the target file behind the link, use the C<lstat> function.

=end original

C<S_*> 정수에 관한 자세한 내용에 대해서는 네이티브의 chmod(2) 와 
stat(2) 의 문서를 참조해주세요.
링크의 앞에 있는 파일이 아닌, 심볼릭 링크 그 것의 정보를 얻고 싶은 경우는 
C<lstat> 함수를 사용해주세요.

=item state EXPR
X<state>

=item state TYPE EXPR

=item state EXPR : ATTRS

=item state TYPE EXPR : ATTRS

=begin original

C<state> declares a lexically scoped variable, just like C<my> does.
However, those variables will never be reinitialized, contrary to
lexical variables that are reinitialized each time their enclosing block
is entered.

=end original

C<state> 는 C<my> 처럼 렉시컬 영역의 변수를 선언합니다.
그러나 블록에 들어갈 때마다 재초기화 되는 렉시컬 변수와는 달리 
이 변수들은 결코 재초기화되지 않습니다.

=begin original

C<state> variables are only enabled when the C<feature 'state'> pragma is
in effect.  See L<feature>.

=end original

C<state> 벼누는 C<feature 'state'> 프라그마가 유효ㄴ 경우만 유효합니다.
L<feature> 를 참조해주세요.

=item study SCALAR
X<study>

=item study

=begin original

Takes extra time to study SCALAR (C<$_> if unspecified) in anticipation of
doing many pattern matches on the string before it is next modified.
This may or may not save time, depending on the nature and number of
patterns you are searching on, and on the distribution of character
frequencies in the string to be searched--you probably want to compare
run times with and without it to see which runs faster.  Those loops
that scan for many short constant strings (including the constant
parts of more complex patterns) will benefit most.  You may have only
one C<study> active at a time--if you study a different scalar the first
is "unstudied".  (The way C<study> works is this: a linked list of every
character in the string to be searched is made, so we know, for
example, where all the C<'k'> characters are.  From each search string,
the rarest character is selected, based on some static frequency tables
constructed from some C programs and English text.  Only those places
that contain this "rarest" character are examined.)

=end original

다음에 변경되기 전에 몇 번이나 문자열에 대해서 패턴매치를 수행하는 
어플리케이션에서 그런 문자열 SCALAR(생략시에는 C<$_>) 를 예습해둡니다.
이것은 검색을 위해서 어떻게 패턴을 몇번 사용하는 가에 따라 
또, 검색되는 문자열 안의 문자정도의 분포에 따라서 
시간을 절약하는 것이 될지도 모르고, 거꾸로 낭비하게 될지도 모릅니다.
예습을 한 경우와 하지 않는 경우의 실행시간을 비교해서 
어느쪽이 빠른가르 ㄹ조사하는 것이 필요할 겁니다.
짧은 고정문자열 (복잡하 패턴의 고정부분을 포함합니다)를 많이 검색하는 
루프에서 제일 효과가 있을 겁니.
동시에 하나의 C<study> 만이 유효합니다.
별도의 스칼라를 study 한 경우에는 이전에 학습한 내용은 
"망각"되어 버렸습니다.
(이 C<study> 의 구성은 우선 검색되는 문자열 안의 모든 문자의 링크된 
리스트가 만들어지, 예를들어, 모든 C<'k'> 가 어디에 있는 가 
알 수 있게 됩니다.
각각의 검색문자열에서 C 프로그램이나 영어의 텍스트에서 만들어진 
정도의 통계정보에 기반해, 제일 바른 문자가 선택됩니다.
이 "바른" 문자를 포ㅁ한 장소만이 조사되는 것입니다.)

=begin original

For example, here is a loop that inserts index producing entries
before any line containing a certain pattern:

=end original

예를들어, 특정의 패턴을 포함한 줄의 앞에 인덱스를 붙이는 
엔트리를 넣는 예제를 나타냅니다.

    while (<>) {
	study;
	print ".IX foo\n" 	if /\bfoo\b/;
	print ".IX bar\n" 	if /\bbar\b/;
	print ".IX blurfl\n" 	if /\bblurfl\b/;
	# ...
	print;
    }

=begin original

In searching for C</\bfoo\b/>, only those locations in C<$_> that contain C<f>
will be looked at, because C<f> is rarer than C<o>.  In general, this is
a big win except in pathological cases.  The only question is whether
it saves you more time than it took to build the linked list in the
first place.

=end original

C<f> 는 C<o> 보다도 바르기에, C</\bfoo\b/> 를 찾을 때, C<$_> 에서 C<f> 를 
포함한 장소만이 검색됩니다.
일반적으로 병적인 경우를 제외하고 상당한 결과를 얻을 수 있습니다.
유일한 문제는 절약할 수 있는 시간이 최초에 링크리스트를 만드는 
시간보다 많은지 어떤 지 입니다.

=begin original

Note that if you have to look for strings that you don't know till
runtime, you can build an entire loop as a string and C<eval> that to
avoid recompiling all your patterns all the time.  Together with
undefining C<$/> to input entire files as one record, this can be very
fast, often faster than specialized programs like fgrep(1).  The following
scans a list of files (C<@files>) for a list of words (C<@words>), and prints
out the names of those files that contain a match:

=end original

실행 시까지, 찾으려고 하는 문자열을 모를 때에는 
루프 전체를 문자열로 조립해서 C<eval> 하면 
항상 모든 패턴을 재 컴파일 하는 사태를 피할 수 있습니다.
파일 전체를 하나의 레코드로 입력하기 위해서 C<$/> 를 미정의하면 
꽤 빨라지고, 많은 경우 fgrep(1) 같은 전용 프로그램보다 빨라 집니다.
아래의 예제는 파일의 리스트 (C<@files>) 에서 단어의 리스트 (C<@words>) 를
찾아서, 매치하는 것이 있는 파일이름을 출력합니다.

    $search = 'while (<>) { study;';
    foreach $word (@words) {
	$search .= "++\$seen{\$ARGV} if /\\b$word\\b/;\n";
    }
    $search .= "}";
    @ARGV = @files;
    undef $/;
    eval $search;		# this screams
    $/ = "\n";		# put back to normal input delimiter
    foreach $file (sort keys(%seen)) {
	print $file, "\n";
    }

=item sub NAME BLOCK
X<sub>

=item sub NAME (PROTO) BLOCK

=item sub NAME : ATTRS BLOCK

=item sub NAME (PROTO) : ATTRS BLOCK

=begin original

This is subroutine definition, not a real function I<per se>.
Without a BLOCK it's just a forward declaration.  Without a NAME,
it's an anonymous function declaration, and does actually return
a value: the CODE ref of the closure you just created.

=end original

이것은 서브루틴 정의이고, I<본질적으로는> 실제의 함수가 아닙니다.
NAME 없는 경우는 이름없는 함수선언이고 실제로ㄴ 값(작성한 블록의 
코드 리퍼런스)를 반환합니다.

=begin original

See L<perlsub> and L<perlref> for details about subroutines and
references, and L<attributes> and L<Attribute::Handlers> for more
information about attributes.

=end original

서브루틴과 리퍼런스에 관한 자세한 정보에 대해서는 L<perlsub> 와 
L<perlref> 를 속성에 관한 새로운 정보에 대해서는 L<attributes> 와 
L<Attribute::Handlers> 를 참조해주세요.

=item substr EXPR,OFFSET,LENGTH,REPLACEMENT
X<substr> X<substring> X<mid> X<left> X<right>

=item substr EXPR,OFFSET,LENGTH

=item substr EXPR,OFFSET

=begin original

Extracts a substring out of EXPR and returns it.  First character is at
offset C<0>, or whatever you've set C<$[> to (but don't do that).
If OFFSET is negative (or more precisely, less than C<$[>), starts
that far from the end of the string.  If LENGTH is omitted, returns
everything to the end of the string.  If LENGTH is negative, leaves that
many characters off the end of the string.

=end original

EXPR 에서 부분문자열을 얻어내서 반환합니다.
최초의 문자가 오프셋 C<0> 혹은 C<$[> 에 설정한 값(그러나 이것을 
사용해서는 안됩니다)이 됩니다.
OFFSET 에 음수(보다 엄밀하게 C<$[> 보다 작은 값)을 설정하면 
EXPR 의 끝에서의 오프셋이 됩니다.
LENGTH 를 생략하면 EXPR 의 마지막까지 모든 것이 반환됩니다.
LENGTH 가 음수라면 문자열의 마지막에서 지ㅇ된 수만 문자를 뺍니다.

    my $s = "The black cat climbed the green tree";
    my $color  = substr $s, 4, 5;	# black
    my $middle = substr $s, 4, -11;	# black cat climbed the
    my $end    = substr $s, 14;		# climbed the green tree
    my $tail   = substr $s, -4;		# tree
    my $z      = substr $s, -4, 2;	# tr

=begin original

You can use the substr() function as an lvalue, in which case EXPR
must itself be an lvalue.  If you assign something shorter than LENGTH,
the string will shrink, and if you assign something longer than LENGTH,
the string will grow to accommodate it.  To keep the string the same
length you may need to pad or chop your value using C<sprintf>.

=end original

substr() 을 좌변치로 사용하는 것도 가능하고, 그 경우에는 
EXPR 이 자신좌변치가 아니면 안됩니다.
LENGTH 보다 짧은 것을 대입한 때에는 
EXPR 은 짧어지고, LENGTH 보다 긴 것을 대입한 때에는 
EXPR 은 그에 맞춰서 늘어지게 됩니다.
EXPR 의 길이를 일정하게 가지기 위해서는 C<sprintf> 를 사용해서 
대입하는 값의 길이를 조정하는 것이 필요할 지도 모르겠습니다.

=begin original

If OFFSET and LENGTH specify a substring that is partly outside the
string, only the part within the string is returned.  If the substring
is beyond either end of the string, substr() returns the undefined
value and produces a warning.  When used as an lvalue, specifying a
substring that is entirely outside the string is a fatal error.
Here's an example showing the behavior for boundary cases:

=end original

OFFSET 과 LENGTH 로 문자열의 바깥쪽을 포함하도록 부분문자열이 지정되면 
문자열의 안쪽 부분만이 반환됩니다.
부분문자열이 문자열의 양쪽의 바깥 쪽일 경우 substr() 은 미정의값을 반환하고,
경고가 출력됩니다.
좌변값으로 사용한 경우, 문자열의 완전히 바깥쪽을 부분문자열로 지정하면 
치명적인 에러가 됩니다.
아래는 경계조건의 행동을 나타내는 예제입니다:

    my $name = 'fred';
    substr($name, 4) = 'dy';		# $name is now 'freddy'
    my $null = substr $name, 6, 2;	# returns '' (no warning)
    my $oops = substr $name, 7;		# returns undef, with warning
    substr($name, 7) = 'gap';		# fatal error

=begin original

An alternative to using substr() as an lvalue is to specify the
replacement string as the 4th argument.  This allows you to replace
parts of the EXPR and return what was there before in one operation,
just as you can with splice().

=end original

substr() 을 좌변값으로 사용하는 대신의 방법은 치환하는 문자열을 4번째의 
인수로 지정하는 것입니다.
이것에 의해 EXPR 의 일부를바꾸고, 바꾸기 전이 뭐였는지를 반환하는 것을 
(splice() 와 같은) 한동작으로 수행할 수 있습니다.

    my $s = "The black cat climbed the green tree";
    my $z = substr $s, 14, 7, "jumped from";	# climbed
    # $s is now "The black cat jumped from the green tree"

=begin original

Note that the lvalue returned by the 3-arg version of substr() acts as
a 'magic bullet'; each time it is assigned to, it remembers which part
of the original string is being modified; for example:

=end original

3인수의 substr() 에 의해 반환된 좌변값은 "마법의 탄환" 처럼 행동하는 것에 
주의하세요; 이것이 대입될 때마다 원래의 문자열의 어느 부분이 변경되는 가가 
생각나게 됩니다; 예를들어:

    $x = '1234';
    for (substr($x,1,2)) {
        $_ = 'a';   print $x,"\n";	# prints 1a4
        $_ = 'xyz'; print $x,"\n";	# prints 1xyz4
        $x = '56789';
        $_ = 'pq';  print $x,"\n";	# prints 5pq9
    }

=begin original

Prior to Perl version 5.9.1, the result of using an lvalue multiple times was
unspecified.

=end original

버젼5.9.1 이전의 Perl 에서는 여러번 좌변값을 사용한 경우의 결과는 미정의입니다.

=item symlink OLDFILE,NEWFILE
X<symlink> X<link> X<symbolic link> X<link, symbolic>

=begin original

Creates a new filename symbolically linked to the old filename.
Returns C<1> for success, C<0> otherwise.  On systems that don't support
symbolic links, produces a fatal error at run time.  To check for that,
use eval:

=end original

NEWFILE 로, OLDFILE로의 심볼릭 링크를 생성합니다.
생성시에는 C<1> 을 반환하고, 실패시에는 C<0> 을 반환합니다.
심볼릭 링크 링크를 지원하지 않는 시스템에서는 
실행시에 치명적인 에러가 발생합니다.
이것을 체크하기위해 eval 을 사용합니다;

    $symlink_exists = eval { symlink("",""); 1 };

=item syscall NUMBER, LIST
X<syscall> X<system call>

=begin original

Calls the system call specified as the first element of the list,
passing the remaining elements as arguments to the system call.  If
unimplemented, produces a fatal error.  The arguments are interpreted
as follows: if a given argument is numeric, the argument is passed as
an int.  If not, the pointer to the string value is passed.  You are
responsible to make sure a string is pre-extended long enough to
receive any result that might be written into a string.  You can't use a
string literal (or other read-only string) as an argument to C<syscall>
because Perl has to assume that any string pointer might be written
through.  If your
integer arguments are not literals and have never been interpreted in a
numeric context, you may need to add C<0> to them to force them to look
like numbers.  This emulates the C<syswrite> function (or vice versa):

=end original

LIST 의 최초의 요소로 지정하는 시스템 호출을 남은 요소를 그 시스템 호출의 
인수로 호출합니다.
구성되지 않을 때에는 치명적인 에러가 됩니다.
인수는 아래처럼 해석됩니다: 인수가 숫자이면, int 로 인수를 건넵니다.
그렇지 않으면 문자열값으로의 포인터가 건네집니다.
문자열에 결과를 받을 때에는 그 결과를 받는 것에 충분할 정도로 
문자열을 미리 늘어놓을 필요가 있습니다.
문자열 리터럴(혹은 그 외의 일기 전용 문자열) 을 C<syscall> 의 
인수로 사용할 수는 없습니다.
Perl 은 모든 문자열 포인터는 쓰여진다고 갖어하지 않으면 안되기 때문입니다.
정수인수 리터럴하지 않고 숫자값 컨텍스트로 평가되는 일이 없는 것이면 
숫자값으로 해석되도록 C<0> 를 충분하게 해둘 필요가 있을지도 모르죠.
아래는 C<syswrite> 함수(또는 그 반대)를 에뮬레이트합니다.

    require 'syscall.ph';		# may need to run h2ph
    $s = "hi there\n";
    syscall(&SYS_write, fileno(STDOUT), $s, length $s);

=begin original

Note that Perl supports passing of up to only 14 arguments to your system call,
which in practice should usually suffice.

=end original

Perl 은 시스템 호출에 최대 14 개의 인수밖에 건네지않지만, 
실용적인 문제는 없을 겁니다.

=begin original

Syscall returns whatever value returned by the system call it calls.
If the system call fails, C<syscall> returns C<-1> and sets C<$!> (errno).
Note that some system calls can legitimately return C<-1>.  The proper
way to handle such calls is to assign C<$!=0;> before the call and
check the value of C<$!> if syscall returns C<-1>.

=end original

syscall 은 호출한 시스템 호출이 반환한 값을 반환합니다.
시스템 호출이 실패하면 C<syscall> 은 C<-1> 을 반환하고, 
C<$!>(errno) 를 설정합니다.
시스템 호출이 정상으로 C<-1> 을 반환하는 경우가 있는 것에 주의해주세요.
그런 시스템 호출을 바르게 다루기 위해서는 C<$!=0;> 을 시스템 호출 전에 실행하고
syscall 이 C<-1> 을 반환한 때에는 C<$!> 의 값을 조사헤주세요.

=begin original

There's a problem with C<syscall(&SYS_pipe)>: it returns the file
number of the read end of the pipe it creates.  There is no way
to retrieve the file number of the other end.  You can avoid this
problem by using C<pipe> instead.

=end original

C<syscall(&SYS_pipe)> 에는 문제가 있습니다.
이것은 파이프의 읽는 쪽이 만든 파일번호를 반환합니다.
상대측의 파일번호를 얻는 방법이 없습니다.
이 문제를 피하기 위해서는 대신에 C<pipe> 를 사용해주세요.

=item sysopen FILEHANDLE,FILENAME,MODE
X<sysopen>

=item sysopen FILEHANDLE,FILENAME,MODE,PERMS

=begin original

Opens the file whose filename is given by FILENAME, and associates it
with FILEHANDLE.  If FILEHANDLE is an expression, its value is used as
the name of the real filehandle wanted.  This function calls the
underlying operating system's C<open> function with the parameters
FILENAME, MODE, PERMS.

=end original

FILENAME 으로 주어진 파일이름의 파일을 열고, FILEHANDLE 과 결부합니다.
FILEHANDLE 이 식일 경우, 그 값은 실제로 바라는 파일핸들의 이름으로 취급됩니다.
이 함수호출은 시스템의 C<open> 함수를 FILENAME, MODE, PERMS 의 
인수로 호출하는 것을 기초로하고 있습니다.

=begin original

The possible values and flag bits of the MODE parameter are
system-dependent; they are available via the standard module C<Fcntl>.
See the documentation of your operating system's C<open> to see which
values and flag bits are available.  You may combine several flags
using the C<|>-operator.

=end original

MODE 파라메터로 지정할 수 있는 플래그 비트와 값은 시스템 의존입니다;
이것은 표준모듈 C<Fcntl> 경유로 이용가능합니다.
어떤 플래그 비트와 값이 이용가능한 가에 대해서는 
OS 의 C<open> 에 관한 문서를 참조해주세요.
C<|> 연산자를 사용해서 복수의 플래그를 결합할 수 있습니다.

=begin original

Some of the most common values are C<O_RDONLY> for opening the file in
read-only mode, C<O_WRONLY> for opening the file in write-only mode,
and C<O_RDWR> for opening the file in read-write mode.
X<O_RDONLY> X<O_RDWR> X<O_WRONLY>

=end original

제일 자주 쓰이는 값은 파일을 읽기전용으로 여는 C<O_RDONLY>, 
파일을 쓰기 전용으로 여는 C<O_WRONLY>, 
파일을 읽기쓰기 양쪽으로 여는 C<O_RDWR> 입니다.
X<O_RDONLY> X<O_RDWR> X<O_WRONLY>

=begin original

For historical reasons, some values work on almost every system
supported by perl: zero means read-only, one means write-only, and two
means read/write.  We know that these values do I<not> work under
OS/390 & VM/ESA Unix and on the Macintosh; you probably don't want to
use them in new code.

=end original

역사적인 이유에 따라 perl 이 지원하고 있는 대부분의 시스템에서 사용할 수 있는
값이 있습니다.
0 은 읽기 전용, 1 은 쓰기 전용, 2는 읽기쓰기 병용을 의미합니다.
OS/390 & VM/ESA Unix 와 Macintosh 에서는 동작 I<하지 않는> 것을 알고 있습니다;
새롭게 쓰는 코드에서는 이것들은 사용하지 않는 것이 좋을 겁니다.

=begin original

If the file named by FILENAME does not exist and the C<open> call creates
it (typically because MODE includes the C<O_CREAT> flag), then the value of
PERMS specifies the permissions of the newly created file.  If you omit
the PERMS argument to C<sysopen>, Perl uses the octal value C<0666>.
These permission values need to be in octal, and are modified by your
process's current C<umask>.
X<O_CREAT>

=end original

FILENAME 이라는 이름의 파일이 존재하지 않고, (전형적으로는 MODE 가 
C<O_CREAT> 플래그를 포함하기 위해) C<open> 호출이 그것을 만드는 경우, 
PERMS 의 값은 새롭게 만들어진 파일의 권한을 지정합니다.
C<sysopen> 의 PERMS 인수를 생략한 경우, Perl 은 8진수 C<0666> 을 사용합니다.
이것들의 권한은 8진수일 필요가 있고, 프로세스의 현재 C<umask> 에서 수정됩니다.

=begin original

In many systems the C<O_EXCL> flag is available for opening files in
exclusive mode.  This is B<not> locking: exclusiveness means here that
if the file already exists, sysopen() fails.  C<O_EXCL> may not work
on network filesystems, and has no effect unless the C<O_CREAT> flag
is set as well.  Setting C<O_CREAT|O_EXCL> prevents the file from
being opened if it is a symbolic link.  It does not protect against
symbolic links in the file's path.
X<O_EXCL>

=end original

많은 시스템에서는 파일을 배타모드에서 열기 위해서는 C<O_EXCL> 을 
이용할 수 있습니.
이것은 락 B<이 아닙니다>: 배타성이라는 것은 이미 파일이 존재한 경우,
sysopen() 이 실패하는 것을 의미합니다.
C<O_EXECL> 은 네트워크 파일시스템에서는 동작하지 않고,
또는 C<O_CREAT> 플래그도 유효하지 않은 한은 효과가 없습니다.
C<O_CREAT|O_EXCL> 을 설정하면, 이것이 심볼릭링크인 경우는 
파일을 여는 것을 방지합니다.
이것은 파일 패스 안의 심볼릭 링크는 지킬 수 없습니다.
X<O_EXCL>

=begin original

Sometimes you may want to truncate an already-existing file.  This
can be done using the C<O_TRUNC> flag.  The behavior of
C<O_TRUNC> with C<O_RDONLY> is undefined.
X<O_TRUNC>

=end original

이미 존재하는 파일을 잘르고 싶은 경우도 있을지 모르겠습니다.
이것은 C<O_TRUNC> 플래그를 사용하는 것으로 수행할 수 있습니다.
C<O_RDONLY> 와 C<O_TRUNC> 를 동시에 지정한 때의 행동은 미정의입니다.
X<O_TRUNC>

=begin original

You should seldom if ever use C<0644> as argument to C<sysopen>, because
that takes away the user's option to have a more permissive umask.
Better to omit it.  See the perlfunc(1) entry on C<umask> for more
on this.

=end original

쓸데없는 일에서는 C<sysopen> 의 인수로 C<0644> 를 지정해야하는 것은 아니겠죠:
유저가 보다 큰 umask 를 지정하는 선택지를 빼앗기 때문입니다.
생략하는 편이 좋습니다.
이것에 관한 자한 정보에 대해서는 perlfunc(1) 의 C<umask> 를 참조해주세요.

=begin original

Note that C<sysopen> depends on the fdopen() C library function.
On many UNIX systems, fdopen() is known to fail when file descriptors
exceed a certain value, typically 255. If you need more file
descriptors than that, consider rebuilding Perl to use the C<sfio>
library, or perhaps using the POSIX::open() function.

=end original

C<sysopen> 은 C 의 fdopen() 라이브러리 함수에 의존하고 있는 것에 주의해주세요.
많은 UNIX 시스템에서는 fdopen() 은 파일 기술자가 있는 값(예를들면 255) 를 
넘으면 실패하는 것을 알고 있습니다.
이것보다 많은 파일 기술자가 필요한 경우는, Perl 을 C<sfio> 라이브러리를 
사용해서 빌드하거나 POSIX::open() 함수를 사용하는 것은 어떨까요?

=begin original

See L<perlopentut> for a kinder, gentler explanation of opening files.

=end original

파일 조작에 관한 보다 친절한 설명에 대해서는 L<perlopentut> 를 참조하세요.

=item sysread FILEHANDLE,SCALAR,LENGTH,OFFSET
X<sysread>

=item sysread FILEHANDLE,SCALAR,LENGTH

=begin original

Attempts to read LENGTH bytes of data into variable SCALAR from the
specified FILEHANDLE, using the system call read(2).  It bypasses
buffered IO, so mixing this with other kinds of reads, C<print>,
C<write>, C<seek>, C<tell>, or C<eof> can cause confusion because the
perlio or stdio layers usually buffers data.  Returns the number of
bytes actually read, C<0> at end of file, or undef if there was an
error (in the latter case C<$!> is also set).  SCALAR will be grown or
shrunk so that the last byte actually read is the last byte of the
scalar after the read.

=end original

시스템 호출 read(2) 를 사용해서 지정한 FILEHANDLE 에서 
변수 SCALAR 로, LENGTH 바이트의 데이터의 읽기를 시험합니다.
이것은 버퍼붙은 IO 루틴을 통하지 않기 때문에, 
다른 입력함수, C<print>, C<write>, C<seek>, C<tell>, C<eof> 와 
섞어서 쓰면, 입력이 이상해질지도 모릅니다.
perlio 층이나 stdio 층은 보통 데이터를 버퍼링하기 때문입니다.
파일의 마지막에서는 C<0> 이나, 에러시에는 undef 가 
그 이외에서는 실제로 읽혀진 데이터의 길이가 반환됩니다
(후자의 경우는 C<$!> 도 설정됩니다).
실제로 읽은 최후의 바이트가 read 한 뒤의 마지막의 바이트가 되기대문에,
SCALAR 는 들쭉날쭉합니다.

=begin original

An OFFSET may be specified to place the read data at some place in the
string other than the beginning.  A negative OFFSET specifies
placement at that many characters counting backwards from the end of
the string.  A positive OFFSET greater than the length of SCALAR
results in the string being padded to the required size with C<"\0">
bytes before the result of the read is appended.

=end original

OFFSET 을 지정하면, SCALAR 의 맨앞 이외의 장소에서 읽기를 수행할 수가
있습니다.
OFFSET 에 음수를 지정하면 문자열의 마지막에서 역방향으로 몇 문자째인가로 
위치를 지정합니다.
OFFSET 에 정수로 SCALAR 의 길이보다도 큰 경우, 필요한 사이즈가 될때까지
C<"\0"> 으로 패딩되어, 그 뒤에 일긱 결과가 추가됩니다.

=begin original

There is no syseof() function, which is ok, since eof() doesn't work
very well on device files (like ttys) anyway.  Use sysread() and check
for a return value for 0 to decide whether you're done.

=end original

syseof() 함수는 없지만, 문제없습니다.
어느 쪽도, eof() 는(tty 같은) 디바이스 파일에 대해서는 
잘 동작하지 않기때문입니다.
sysread() 를 사용해서, 반환값이 0 인지 어떤지로 마지막까지 읽었는지를
판단해주세요.

=begin original

Note that if the filehandle has been marked as C<:utf8> Unicode
characters are read instead of bytes (the LENGTH, OFFSET, and the
return value of sysread() are in Unicode characters).
The C<:encoding(...)> layer implicitly introduces the C<:utf8> layer.
See L</binmode>, L</open>, and the C<open> pragma, L<open>.

=end original

파일핸들이 C<:utf8> 이라고 마크가 붙여지면 바이트가 아닌 Unicode 문자가
읽혀집니다(sysread() 의 LENGTH, OFFSET 및 반환값은 
Unicode 문자가 됩니다).
C<:encoding(...)> 층은 암묵적으로 C<:utf8> 층이 도입됩니다.
L</binmode>, L</open>, C<open> 프라그마, L<open> 을 참조하세요.

=item sysseek FILEHANDLE,POSITION,WHENCE
X<sysseek> X<lseek>

=begin original

Sets FILEHANDLE's system position in bytes using the system call
lseek(2).  FILEHANDLE may be an expression whose value gives the name
of the filehandle.  The values for WHENCE are C<0> to set the new
position to POSITION, C<1> to set the it to the current position plus
POSITION, and C<2> to set it to EOF plus POSITION (typically
negative).

=end original

FILEHANDLE 의 시스템 위치를 바이트 단위로 lseek(2) 시스템 호출을 사용해서
설정합니다.
FILEHANDLE 은 식이라도 상관없습니다.
그 경우는 그 값이 파일핸들의 이름이 됩니다.
WHENCE 의 값이 C<0> 라면 새로운 위치를 POSITION 의 위치로 C<1> 이면 
현재위치에서 POSITION 붙은 위치로, C<2> 라면 EOF 에서 POSITION 만
(보통은 음수입니다) 더한 위치로, 새로운 위치를 설정합니다.

=begin original

Note the I<in bytes>: even if the filehandle has been set to operate
on characters (for example by using the C<:encoding(utf8)> I/O layer),
tell() will return byte offsets, not character offsets (because
implementing that would render sysseek() very slow).

=end original

I<바이트단위> 에 관한 주의: 문자단위로 취급하도록 파일핸들이 
설정되어 있는 경우(C<:encoding(utf8)> I/O 층을 사용하고 있는 경우등)에서도
tell() 은 문자의 오프셋이 아닌 바이트 오프셋을 반환합니다
(왜냐면 이것을 구성하면 sysseek() 가 매우 느리기 때문입니다).

=begin original

sysseek() bypasses normal buffered IO, so mixing this with reads (other
than C<sysread>, for example C<< <> >> or read()) C<print>, C<write>,
C<seek>, C<tell>, or C<eof> may cause confusion.

=end original

sysseek() 는 보통의 버퍼 붙은 IO 를 바이패스하기 때문에,
(C<sysread> 이외의 예를들어 C<< <> >> 나 read() 의) 읽기,
C<print>, C<write>, C<seek>, C<tell>, C<eof> 와 섞어서 사용하면 
혼란을 일으킵니다.

=begin original

For WHENCE, you may also use the constants C<SEEK_SET>, C<SEEK_CUR>,
and C<SEEK_END> (start of the file, current position, end of the file)
from the Fcntl module.  Use of the constants is also more portable
than relying on 0, 1, and 2.  For example to define a "systell" function:

=end original

이 값에는 Fcntl 모듈로 사용된 C<SEEK_SET>, C<SEEK_CUR>, C<SEEK_END>
(파일의 맨 앞, 현재 위치, 파일의 끝)이라는 정수를 사용할 수 있습니다.

	use Fcntl 'SEEK_CUR';
	sub systell { sysseek($_[0], 0, SEEK_CUR) }

=begin original

Returns the new position, or the undefined value on failure.  A position
of zero is returned as the string C<"0 but true">; thus C<sysseek> returns
true on success and false on failure, yet you can still easily determine
the new position.

=end original

새로운 위치ㄹ 반환합니다.
실패한 때는 미정의값을 반환합니다.
위치가 제로인 경우는 C<"0 이지만 참"> 의 문자열로 반환됩니다.
따라서 C<sysseek> 는 성공시에는 참을 반환하고 실패시에는 거짓을 
반환하지만, 간단히 새로운 위치를 판정할 수 있습니다.

=item system LIST
X<system> X<shell>

=item system PROGRAM LIST

=begin original

Does exactly the same thing as C<exec LIST>, except that a fork is
done first, and the parent process waits for the child process to
complete.  Note that argument processing varies depending on the
number of arguments.  If there is more than one argument in LIST,
or if LIST is an array with more than one value, starts the program
given by the first element of the list with arguments given by the
rest of the list.  If there is only one scalar argument, the argument
is checked for shell metacharacters, and if there are any, the
entire argument is passed to the system's command shell for parsing
(this is C</bin/sh -c> on Unix platforms, but varies on other
platforms).  If there are no shell metacharacters in the argument,
it is split into words and passed directly to C<execvp>, which is
more efficient.

=end original

C<exec LIST> 와 거의 같지만, 우선 fork 를 수행하고, 
부모 프로세스에서는 자식 프로세스가 종료하는 것을 wait 합니다.
exec 의 항에서 기술한것 처럼, 인수의 처리는 인수의 수에 따라 다른
것에 주의해주세요.
LIST 에 복수의 인수가 있는 경우, 또는 LIST 가 복수의 요소에서 비롯된
배열인 경우, 리스트의 최초의 요소로 주어진 프로그램을 리스트의 남은 요를 인수로
기동합니다.
스칼라의 인수가 하나뿐인 경우, 인수는 셸의 메타캐릭터를 체크,
만약 있다면 파싱을 위해 인수전체가 시스템커맨드셸
(이것은 Unix 플랫폼에서는 C</bin/sh -c> 이지만, 다른 플랫폼에서는 
다릅니다)로 건네집니다. 
셸 메타 캐릭터가 없는 경우, 인수는 단어로 분해된 직후 C<execvp> 에 
건네집니다.
이 편이 보다 효율적입니다.

=begin original

Beginning with v5.6.0, Perl will attempt to flush all files opened for
output before any operation that may do a fork, but this may not be
supported on some platforms (see L<perlport>).  To be safe, you may need
to set C<$|> ($AUTOFLUSH in English) or call the C<autoflush()> method
of C<IO::Handle> on any open handles.

=end original

v5.6.0 부터 Perl 은 fork 를 수행하는 일련의 동작 이전에 출력용으로 오픈한
모든 파일을 플러쉬하려고 합니다.
그러나 이것을 지원하지 않는 플랫폼도 있습니다(L<perlport> 참조).
안전을 위해서는 C<$|>(English 모듈을 사용한다면 $AUTOFLUSH) 를 
설정하거나, 일련의 오픈이 끝난 핸들에 대해 C<IO::Handle> 의 
C<autoflush()> 메소드가 필요할지도 모르겠습니다.

=begin original

The return value is the exit status of the program as returned by the
C<wait> call.  To get the actual exit value, shift right by eight (see
below). See also L</exec>.  This is I<not> what you want to use to capture
the output from a command, for that you should use merely backticks or
C<qx//>, as described in L<perlop/"`STRING`">.  Return value of -1
indicates a failure to start the program or an error of the wait(2) system
call (inspect $! for the reason).

=end original

반환값은 C<wait> 가 반환하는 프로그램의 exit 상태입니다.
실제 exit 값을 얻기위해 오른쪽에 8비트 시프트해주세요(후술).
L</exec> 도 참조해주세요.
이것은 커맨드에서의 출력을 보호하기 위해 사용하는 것I<이 아닙니다>.
그런 용도로는 L<perlop/" STRING "> 에 기술되어 있는 
역따옴표 C<qw//> 를 사용해주세요.
-1 의 반환값은 프로그램을 개시시키는 것에 실패했거나, wait(2) 
시스템 호출이 에러를 낸 것을 나타냅니다.
(이유는 $! 를 조사해주세요).

=begin original

Like C<exec>, C<system> allows you to lie to a program about its name if
you use the C<system PROGRAM LIST> syntax.  Again, see L</exec>.

=end original

C<exec> 와 마찬가지로 C<system> 에서 C<system PROGRAM LIST> 의 문법을 
사용하는 것으로 프로그램에 대해서 그 이름을 거짓으로 만들 수 있습니다.
다시 L</exec> 를 참조해주세요.

=begin original

Since C<SIGINT> and C<SIGQUIT> are ignored during the execution of
C<system>, if you expect your program to terminate on receipt of these
signals you will need to arrange to do so yourself based on the return
value.

=end original

C<SIGINT> 와 C<SIGQUIT> 는 C<system> 의 실행중은 무시되기에, 
이 시그널들을 수신해서 종료시키는 것을 상정한 프록램의 경우
반환값을 이용하도록 변경할 필요가 있습니다.

    @args = ("command", "arg1", "arg2");
    system(@args) == 0
	 or die "system @args failed: $?"

=begin original

You can check all the failure possibilities by inspecting
C<$?> like this:

=end original

아래처럼 C<$?> 를 조사하는 것으로 모든 실패의 가능성을 
체크할 수 있습니다:

    if ($? == -1) {
	print "failed to execute: $!\n";
    }
    elsif ($? & 127) {
	printf "child died with signal %d, %s coredump\n",
	    ($? & 127),  ($? & 128) ? 'with' : 'without';
    }
    else {
	printf "child exited with value %d\n", $? >> 8;
    }

=begin original

Alternatively you might inspect the value of C<${^CHILD_ERROR_NATIVE}>
with the W*() calls of the POSIX extension.

=end original

또는 POSIX 확장의 W*() 호출을 사용해서 C<{^CHILD_ERROR_NATIVE}> 의 
값을 조사할 수도 있습니다.

=begin original

When the arguments get executed via the system shell, results
and return codes will be subject to its quirks and capabilities.
See L<perlop/"`STRING`"> and L</exec> for details.

=end original

인수가 시스템 셸 경유로 실행된 경우, 
결과와 반환값은 셸의 버릇과 능력에 따라 변경될 수 있습니다.
자세한 내용에 대해서는 L<perlop/" STRING "> 과 L</exec> 를 참조해주세요.

=item syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET
X<syswrite>

=item syswrite FILEHANDLE,SCALAR,LENGTH

=item syswrite FILEHANDLE,SCALAR

=begin original

Attempts to write LENGTH bytes of data from variable SCALAR to the
specified FILEHANDLE, using the system call write(2).  If LENGTH is
not specified, writes whole SCALAR.  It bypasses buffered IO, so
mixing this with reads (other than C<sysread())>, C<print>, C<write>,
C<seek>, C<tell>, or C<eof> may cause confusion because the perlio and
stdio layers usually buffers data.  Returns the number of bytes
actually written, or C<undef> if there was an error (in this case the
errno variable C<$!> is also set).  If the LENGTH is greater than the
available data in the SCALAR after the OFFSET, only as much data as is
available will be written.

=end original

write(2) 시스템 호출을 사용해서 설정한 FILEHANDLE 로 
변수 SCALAR 에서 LENGTH 바이트의 데이터의 쓰기를 시험합니다.
LENGTH 가 지정되지 않은 경우, SCALAR 전체를 씁니다.
이것은 버퍼붙은 IO 루틴을 통하지 않기 때문에 
다른 입력함수(C<sysread() 이외), C<print>, C<write>, C<seek>, 
C<tell>, 또는 C<eof> 와 섞어서 사용하면 출력이 이상해질지도 모릅니다.
perlio 층과 stdio 층은 보통 데이터를 버퍼링하기 때문입니다.
실제로 읽어들인 데이터의 길이나 에러시에는 c<undef> 가 반환됩니다
(이 경우 에러 변수 C<$!> 도 설정됩니다).
LENGTH 가 OFFSET 이후의 SCALAR 의 이용가능한 데이터보다 큰 경우 
이용가능한 데이터만이 써집니다.

=begin original

An OFFSET may be specified to write the data from some part of the
string other than the beginning.  A negative OFFSET specifies writing
that many characters counting backwards from the end of the string.
In the case the SCALAR is empty you can use OFFSET but only zero offset.

=end original

OFFSET 을 설정하면, SCALAR 의 맨앞이외의 장소에서 데이터를 뽑아내서,
쓰기를 수행할 수 있습니다.
OFFSET 에 음수를 지정하면 문자열의 끝에서 역방향으로 세서, 
몇바이트째에서 썼는 가를 나타냅니다.
SCALAR 가 빈 경우, OFFSET 은 제로만 이용가능합니다.

=begin original

Note that if the filehandle has been marked as C<:utf8>, Unicode
characters are written instead of bytes (the LENGTH, OFFSET, and the
return value of syswrite() are in UTF-8 encoded Unicode characters).
The C<:encoding(...)> layer implicitly introduces the C<:utf8> layer.
See L</binmode>, L</open>, and the C<open> pragma, L<open>.

=end original

파일핸들이 C<:utf8> 이라고 마크가 붙으면, 바이트가 아닌 
Unicode 문자가 읽혀집니다 (syswrite() 의 LENGTH, OFFSET 및 반환값은 
Unicode 문자가 됩니다).
C<:encoding(...)> 층은 암묵적으로 C<:utf8> 층이 도입됩니다.
L</binmode>, L</open>, C<open> 프라그마, L<open> 을 참조해주세요.

=item tell FILEHANDLE
X<tell>

=item tell

=begin original

Returns the current position I<in bytes> for FILEHANDLE, or -1 on
error.  FILEHANDLE may be an expression whose value gives the name of
the actual filehandle.  If FILEHANDLE is omitted, assumes the file
last read.

=end original

FILEHANDLE 의 현재의 위치를 I<바이트 수로> 지정합니다.
에러인 경우는 -1 을 반환합니다.
FILEHANDLE 은 실제 파일핸들 이름을 나타내는 식이어도 상관없습니다.
FILEHANDLE 이 생략된 경우에는 마지막으로 읽기를 수행한 파일에 
대해서 조사합니다.

=begin original

Note the I<in bytes>: even if the filehandle has been set to
operate on characters (for example by using the C<:encoding(utf8)> open
layer), tell() will return byte offsets, not character offsets (because
that would render seek() and tell() rather slow).

=end original

I<바이트 단위> 에 관한 주의: 파일핸들 (예를 들면
C<:encoding(utf8)> 층을 사용해서)
문자를 조작하도록 설정되어 있다고 해도, tell() 은 문자의 
오프셋이 아닌 바이트의 오프셋을 반환하는 것에 주의해주세요
(왜냐면 이것은 seek() 와 tell() 이 느려지기 때문입니다).

=begin original

The return value of tell() for the standard streams like the STDIN
depends on the operating system: it may return -1 or something else.
tell() on pipes, fifos, and sockets usually returns -1.

=end original

STDIN 같은 표준 스트림에 대해서 tell() 의 반환값은 OS 에 의존합니다.
-1 이나 그 외의 값이 반환될지도 모릅니다.
파이프, FIFO, 소켓에 대해서 tell() 을 사용하면, 보통은 -1 이 반환됩니다.

=begin original

There is no C<systell> function.  Use C<sysseek(FH, 0, 1)> for that.

=end original

C<systell> 함수는 없습니다.
대신에 C<sysseek(FH, 0, 1)> 을 사용해주세요.

=begin original

Do not use tell() (or other buffered I/O operations) on a file handle
that has been manipulated by sysread(), syswrite() or sysseek().
Those functions ignore the buffering, while tell() does not.

=end original

sysread(), syswrite(), sysseek() 로 조작된 파일핸들에 tell() 
(똔느 그 밖의 버퍼링 I/O 조작) 을 수행하지 말아주세요.
이런 함수들은 버퍼링을 무시하지만, tell() 은 다릅니다.

=item telldir DIRHANDLE
X<telldir>

=begin original

Returns the current position of the C<readdir> routines on DIRHANDLE.
Value may be given to C<seekdir> to access a particular location in a
directory.  C<telldir> has the same caveats about possible directory
compaction as the corresponding system library routine.

=end original

DIRHANDLE 상의 C<readdir> 루틴에 대해서 현재위치를 반환합니다.
C<seekdir> 에 넘길 수 있습니다.
C<telldir> 은 같은 이름의 시스템 라이브러리 루틴과 마찬가지로
디렉토리 축소시의 문제를 생각할 수 있습니다.

=item tie VARIABLE,CLASSNAME,LIST
X<tie>

=begin original

This function binds a variable to a package class that will provide the
implementation for the variable.  VARIABLE is the name of the variable
to be enchanted.  CLASSNAME is the name of a class implementing objects
of correct type.  Any additional arguments are passed to the C<new>
method of the class (meaning C<TIESCALAR>, C<TIEHANDLE>, C<TIEARRAY>,
or C<TIEHASH>).  Typically these are arguments such as might be passed
to the C<dbm_open()> function of C.  The object returned by the C<new>
method is also returned by the C<tie> function, which would be useful
if you want to access other methods in CLASSNAME.

=end original

이 함수는 변수를 그 변수의 구성을 수행하는 클래스와 결부합니다.
VARIABLE 은, 마법을 거는 변수의 이름입니다.
CLASSNAME 은 바른 형태의 오브젝트를 구성하는 클래스의 이름입니다.
다른 인수가 있다면, 그 클래스의 C<new> 메소드에 건네집니다
(즉 C<TIESCALAR>, C<TIEHANDLE>, C<TIEARRAY>, C<TIEHASH>).
보통, 이것들은 C 의 C<dbm_open> 등의 함수에 넘기는 인수가 됩니다.
C<new> 메소드로 반환되는 오브젝트 또는 C<tie> 함수에서도 반환됩니다.
이것은 CLASSNAME 의 다른 메소드에 접근하고 싶을 때에 편리합니다.

=begin original

Note that functions such as C<keys> and C<values> may return huge lists
when used on large objects, like DBM files.  You may prefer to use the
C<each> function to iterate over such.  Example:

=end original

DBM 파일같은 큰 오브젝트에서는 C<keys> 나 C<values> 같은 
함수는 큰 리스트를 반환할 가능성이 있습니다.
그런 경우에서는 C<each> 함수를 사용해서 반환을 수행한 편이 좋을지도 
모르겠습니다.
예제:

    # print out history file offsets
    use NDBM_File;
    tie(%HIST, 'NDBM_File', '/usr/lib/news/history', 1, 0);
    while (($key,$val) = each %HIST) {
	print $key, ' = ', unpack('L',$val), "\n";
    }
    untie(%HIST);

=begin original

A class implementing a hash should have the following methods:

=end original

해쉬를 구성하는 클래스에서는 다음같은 메소드를 준비하고 있습니다:

    TIEHASH classname, LIST
    FETCH this, key
    STORE this, key, value
    DELETE this, key
    CLEAR this
    EXISTS this, key
    FIRSTKEY this
    NEXTKEY this, lastkey
    SCALAR this
    DESTROY this
    UNTIE this

=begin original

A class implementing an ordinary array should have the following methods:

=end original

통상의 배열을 구성하는 클래스에서는 다음과 같은 메소드를 준비하고 있습니다:

    TIEARRAY classname, LIST
    FETCH this, key
    STORE this, key, value
    FETCHSIZE this
    STORESIZE this, count
    CLEAR this
    PUSH this, LIST
    POP this
    SHIFT this
    UNSHIFT this, LIST
    SPLICE this, offset, length, LIST
    EXTEND this, count
    DESTROY this
    UNTIE this

=begin original

A class implementing a file handle should have the following methods:

=end original

파일핸들을 구성하는 클래스에서는 다음과 같은 메소드를 준비하고 있습니다:

    TIEHANDLE classname, LIST
    READ this, scalar, length, offset
    READLINE this
    GETC this
    WRITE this, scalar, length, offset
    PRINT this, LIST
    PRINTF this, format, LIST
    BINMODE this
    EOF this
    FILENO this
    SEEK this, position, whence
    TELL this
    OPEN this, mode, LIST
    CLOSE this
    DESTROY this
    UNTIE this

=begin original

A class implementing a scalar should have the following methods:

=end original

스칼라 변수를 구성하는 클래스에서는 다음과 같은 메소드를 준비하고 있습니다:

    TIESCALAR classname, LIST
    FETCH this,
    STORE this, value
    DESTROY this
    UNTIE this

=begin original

Not all methods indicated above need be implemented.  See L<perltie>,
L<Tie::Hash>, L<Tie::Array>, L<Tie::Scalar>, and L<Tie::Handle>.

=end original

위의 모든 메소드를 구성할 필요는 없습니다.
L<perltie>, L<Tie::Hash>, L<Tie::Array>, L<Tie::Scalar>,
L<Tie::Handle> 을 참조해주세요.

=begin original

Unlike C<dbmopen>, the C<tie> function will not use or require a module
for you--you need to do that explicitly yourself.  See L<DB_File>
or the F<Config> module for interesting C<tie> implementations.

=end original

C<dbmopen> 과는 달리, C<tie> 함수는 모듈을 use 하거나 require 하지는 
않습니다 -- 자신이 명시적으로 수행할 필요가 있습니다.
C<tie> 의 흥미 깊은 구성에 대해서는 L<DB_File> 이나 F<Config> 모듈을
참조해주세요.

=begin original

For further details see L<perltie>, L<"tied VARIABLE">.

=end original

보다 자세한 내용에 대해서는 L<perltie> 나 L<"tied VARIABLE"> 을 참조해주세요.

=item tied VARIABLE
X<tied>

=begin original

Returns a reference to the object underlying VARIABLE (the same value
that was originally returned by the C<tie> call that bound the variable
to a package.)  Returns the undefined value if VARIABLE isn't tied to a
package.

=end original

VARIABLE 의 기반이 되는 오브젝트로의 리퍼런스를 반환합니다
(변수를 패키지에 연결하기 위해서는 C<tie> 호출을 한 때의 
반환값과 같은 것입니다).
VARIABLE 이 패키지와 연결되지 않은 경우는 미정의값을 반환합니다.

=item time
X<time> X<epoch>

=begin original

Returns the number of non-leap seconds since whatever time the system
considers to be the epoch, suitable for feeding to C<gmtime> and
C<localtime>. On most systems the epoch is 00:00:00 UTC, January 1, 1970;
a prominent exception being Mac OS Classic which uses 00:00:00, January 1,
1904 in the current local time zone for its epoch.

=end original

c<gmtime> 이나 c<localtime> 으로의 입력형식에 맞는, 
시스템ㅣ 기원이 되는 시점에서의 연속초수를 반환합니다.
대부분의 시스템에서는 기원은 UTC 1970년 1월 1일 00:00:00 입니다:
특징적인 예외로서는 낡은 Mac OS 에서는 로컬타임존의 
1904 년 1월 1일 00:00:00 을 기원으로 사용하고 있습니다.

=begin original

For measuring time in better granularity than one second,
you may use either the L<Time::HiRes> module (from CPAN, and starting from
Perl 5.8 part of the standard distribution), or if you have
gettimeofday(2), you may be able to use the C<syscall> interface of Perl.
See L<perlfaq8> for details.

=end original

1초 보다도 자세한 시간을 계측하기 위해서는 L<Time::HiRes> 모듈(CPAN 에서
또는 Perl 5.8 에서는 표준모듈의 일부입니다)를 사용하거나 
gettimeofday(2) 가 있다면, Perl 의 C<syscall> 인터페이스를 사용하는 
편이 좋겠죠.
자세한 것은 L<perlfaq8> 을 참조해주세요.

=begin original

For date and time processing look at the many related modules on CPAN.
For a comprehensive date and time representation look at the
L<DateTime> module.

=end original

날짜와 시각의 처리에 관한 모듈은 CPAN 에 많이 있습니다.
포괄적인 날짜와 시각의 표현에 대해서는 CPAN 의 L<DateTime> 모듈을 
참조해주세요.

=item times
X<times>

=begin original

Returns a four-element list giving the user and system times, in
seconds, for this process and the children of this process.

=end original

현재의 프로세스 및 그 자식 프로세스에 대해서 유저시간과 시스템 시간을
초로 나타낸 4 요소의 리스트 값을 반환합니다.

    ($user,$system,$cuser,$csystem) = times;

=begin original

In scalar context, C<times> returns C<$user>.

=end original

스칼라 컨텍스트에서는 C<times> 는 C<$user> 를 반환합니다.

=begin original

Note that times for children are included only after they terminate.

=end original

자식 프로세스에 대해 times 는 그것들이 종료한 뒤에 포함되는 것에 
주의해주세요.

=item tr///

=begin original

The transliteration operator.  Same as C<y///>.  See L<perlop>.

=end original

변환연산자.
C<y///> 와 같습니다.
L<perlop> 를 참조해주세요.

=item truncate FILEHANDLE,LENGTH
X<truncate>

=item truncate EXPR,LENGTH

=begin original

Truncates the file opened on FILEHANDLE, or named by EXPR, to the
specified length.  Produces a fatal error if truncate isn't implemented
on your system.  Returns true if successful, the undefined value
otherwise.

=end original

FILEHANDLE 상에 오픈된 파일이나 EXPR 로 이름을 나타낸 파일을 
지정한 길이로 자릅니다.
시스템 상에 truncate 가 구성되어 있지 않다면 치명적인 에러가 됩니다.
성공하면 참을, 그렇지 않으면 미정의값을 반환합니다.

=begin original

The behavior is undefined if LENGTH is greater than the length of the
file.

=end original

LENGTH 가 파일의 길이보다 큰 경우의 행동은 미정의입니다.

=begin original

The position in the file of FILEHANDLE is left unchanged.  You may want to
call L<seek> before writing to the file.

=end original

FILEHANDLE 의 파일의 위치를 바꾸지 않습니다.
파일에 쓰기전에 L<seek> 를 호출하고 싶을 지도 모르겠네요.

=item uc EXPR
X<uc> X<uppercase> X<toupper>

=item uc

=begin original

Returns an uppercased version of EXPR.  This is the internal function
implementing the C<\U> escape in double-quoted strings.  Respects
current LC_CTYPE locale if C<use locale> in force.  See L<perllocale>
and L<perlunicode> for more details about locale and Unicode support.
It does not attempt to do titlecase mapping on initial letters.  See
C<ucfirst> for that.

=end original

EXPR 을 대문자로 변환한 것을 반환합니다.
이것은 쌍따옴표 문자열에서의 C<\U> 이스케이프를 구성하는 내부함수입니다.
C<use locale> 이 유효한 경우는 현재의 LC_CTYPE 로케일을 참조합니다.
로케일과 Unicode 대응에 관한 자세한 내용에 대해서는 L<perllocale> 과 
L<perlunicode> 를 참조해주세요.
원래의 문자의 titlecase 매핑을 시험하지 않습니다.
이를 위해 C<ucfirst> 를 참조해주세요.

=begin original

If EXPR is omitted, uses C<$_>.

=end original

EXPR 이 생략되면 C<$_> 를 사용합니다.

=item ucfirst EXPR
X<ucfirst> X<uppercase>

=item ucfirst

=begin original

Returns the value of EXPR with the first character in uppercase
(titlecase in Unicode).  This is the internal function implementing
the C<\u> escape in double-quoted strings.  Respects current LC_CTYPE
locale if C<use locale> in force.  See L<perllocale> and L<perlunicode>
for more details about locale and Unicode support.

=end original

최초의 문자만을 대문자로 한, EXPR 을 반환합니다(Unicode 에서는 
titlecase).
이것은 쌍따옴표 문자열에서 C<\u> 이스케이프를 구성하는 내부함수입니다.
C<use locale> 이 유효한 경우는 현재의 LC_CTYPE 로케일을 참조합니다.
로케일과 Unicode 대응에 관한 자세한 내용에 대해서는 L<perllocale> 과 
L<perlunicode> 를 참조해주세요.

=begin original

If EXPR is omitted, uses C<$_>.

=end original

EXPR 이 생략되면, C<$_> 를 사용합니다.

=item umask EXPR
X<umask>

=item umask

=begin original

Sets the umask for the process to EXPR and returns the previous value.
If EXPR is omitted, merely returns the current umask.

=end original

현재의 프로세스의 umask 를 EXPR 에 설정해서 이전의 값을 반환합니다.
EXPR 이 생략되면, 단순히 그 시점의 umask 의 값을 반환합니다.

=begin original

The Unix permission C<rwxr-x---> is represented as three sets of three
bits, or three octal digits: C<0750> (the leading 0 indicates octal
and isn't one of the digits).  The C<umask> value is such a number
representing disabled permissions bits.  The permission (or "mode")
values you pass C<mkdir> or C<sysopen> are modified by your umask, so
even if you tell C<sysopen> to create a file with permissions C<0777>,
if your umask is C<0022> then the file will actually be created with
permissions C<0755>.  If your C<umask> were C<0027> (group can't
write; others can't read, write, or execute), then passing
C<sysopen> C<0666> would create a file with mode C<0640> (C<0666 &~
027> is C<0640>).

=end original

Unix 퍼미션 C<rwxr-x---> 는 3비트의 3개의 쌍, 또는 세자리의 8진수로
표현됩니다:
C<0750> (맨앞의 0는 8진수를 의미하고, 실제의 값은 아닙니다).
C<umask> 의 값은 무효로 하는 퍼미션비트의 이런 수치표현입니다.
C<mkdir> 이나 C<sysopen> 으로 건네진 퍼미션(또는 "모드") 의 값은 
umask 로 수정되어, 예를들어 C<sysopen> 에서 C<0777> 의 퍼미션에서 
파일을 만들도록 지정해도 umask 가 C<0022> 라면, 
결과로 파일은 C<0755> 의 퍼미션에서 작성됩니다.
C<umask> 가 C<0027> (그룹은 쓸 수 없습니다; 그외는 읽기, 쓰기, 
실행 할 수 없습니다) 일 때, C<sysopen> 에 C<0666> 을 넘기면 
파일모드 C<0640> (C<0666 &~ 027> 은 C<0640>) 으로 작성됩니다.

=begin original

Here's some advice: supply a creation mode of C<0666> for regular
files (in C<sysopen>) and one of C<0777> for directories (in
C<mkdir>) and executable files.  This gives users the freedom of
choice: if they want protected files, they might choose process umasks
of C<022>, C<027>, or even the particularly antisocial mask of C<077>.
Programs should rarely if ever make policy decisions better left to
the user.  The exception to this is when writing files that should be
kept private: mail files, web browser cookies, I<.rhosts> files, and
so on.

=end original

여기에 조언이 있습니다: 작성모드로 (C<sysopen> 에 의한) 통상 파일에서는
C<0666> 을 (C<mkdir> 에 의한) 디렉토리 에서는 C<0777> 를 지정합시다.
이에 의해 유저에게 선택의 자유를 줍니다: 만약 파일을 지키고 싶다면, 
프로세스의 umask 로 C<022>, C<027>, 또는 특히 비사교적인 C<077> 을 
선택할 수 있습니다.
프로그램이 유저보다 적절한 정책 선택이 가능하다는 것은 희망사항입니다.
예외는 프라이베이트로 가져야할 파일(메일, 웹브라우저 쿠키, I<.rhosts>
파일등)을 쓰는 경우입니다.

=begin original

If umask(2) is not implemented on your system and you are trying to
restrict access for I<yourself> (i.e., (EXPR & 0700) > 0), produces a
fatal error at run time.  If umask(2) is not implemented and you are
not trying to restrict access for yourself, returns C<undef>.

=end original

umask(2) 가 실행되지 않는 시스템에서 I<자기자신> 으로 접근을 
제한하도록 한 (즉 (EXPR && 0700) > 0) 경우, 싱행시에 치명적인 에러가 
발생합니다.
umask(2) 가 구성되지 않은 시스템에서 자기자신으로의 접근은 
제한하도록 하지 않은 경우, C<undef> 를 반환합니다.

=begin original

Remember that a umask is a number, usually given in octal; it is I<not> a
string of octal digits.  See also L</oct>, if all you have is a string.

=end original

umask 는 통상 8진수로 주어진 수치인 것을 잊지 말아주세요.
8진수의 문자열 I<이 아닙니다>.
문자열밖에 없는 경우, L</oct> 도 참조해주세요.

=item undef EXPR
X<undef> X<undefine>

=item undef

=begin original

Undefines the value of EXPR, which must be an lvalue.  Use only on a
scalar value, an array (using C<@>), a hash (using C<%>), a subroutine
(using C<&>), or a typeglob (using C<*>).  (Saying C<undef $hash{$key}>
will probably not do what you expect on most predefined variables or
DBM list values, so don't do that; see L<delete>.)  Always returns the
undefined value.  You can omit the EXPR, in which case nothing is
undefined, but you still get an undefined value that you could, for
instance, return from a subroutine, assign to a variable or pass as a
parameter.  Examples:

=end original

좌변치인 EXPR 의 값을 미정의로 합니다.
스칼라값, (C<@> 를 사용한) 배열, (C<%> 를 사용한) 해쉬, (C<&> 를 사용한)
서브루틴, (C<*> 를 사용한) 형태 glob에게만 사용합니다.
(특수변수나 DBM 리스트 값에 C<undef $hash{$key}> 같은 것을 해도 
아마도 기대한 결과가 되지 않기때문에, 하지 말아주세요.
L</delete> 를 참조해주세요.)
항상 미정의값을 반환합니다.
EXPR 은 생략한 것이 되고, 그 경우에는 아무것도 미정의 되지 않지만, 
미정의값은 반환되기 때문에, 그것을 예를들어, 서브루틴의 반환값 
변수로의 할당, 인수등으로 사용할 수 있습니다.
예제:

    undef $foo;
    undef $bar{'blurfl'};      # Compare to: delete $bar{'blurfl'};
    undef @ary;
    undef %hash;
    undef &mysub;
    undef *xyz;       # destroys $xyz, @xyz, %xyz, &xyz, etc.
    return (wantarray ? (undef, $errmsg) : undef) if $they_blew_it;
    select undef, undef, undef, 0.25;
    ($a, $b, undef, $c) = &foo;       # Ignore third value returned

=begin original

Note that this is a unary operator, not a list operator.

=end original

이것은 리스트 연산자가 아닌 단항연산자인 것에 주의해주세요.

=item unlink LIST
X<unlink> X<delete> X<remove> X<rm> X<del>

=item unlink

=begin original

Deletes a list of files.  Returns the number of files successfully
deleted.

=end original

LIST 에 포함된 파일을 삭제합니다.
삭제에 성공한 파일의 수를 반환합니다.

    $cnt = unlink 'a', 'b', 'c';
    unlink @goners;
    unlink <*.bak>;

=begin original

Note: C<unlink> will not attempt to delete directories unless you are superuser
and the B<-U> flag is supplied to Perl.  Even if these conditions are
met, be warned that unlinking a directory can inflict damage on your
filesystem.  Finally, using C<unlink> on directories is not supported on 
many operating systems.  Use C<rmdir> instead.

=end original

주: 수퍼유저 권한으로 Perl 에 -U 를 붙여서 실행한 경우가 아니라면, 
C<unlink> 는 디렉토리를 삭제하려고 하는 것은 아닙니다.
이 조건에 맞는 경우에도 디렉토리의 삭제는 파일 시스템에 
크고 많은 손해해를 줄 가능성이 있습니다.
마지막에 C<unlink> 를 디렉토리에 사용하는 것은 대부분의 OS에서는 
지원하지 않습니다.
대신에 C<rmdir> 을 사용해주세요.

=begin original

If LIST is omitted, uses C<$_>.

=end original

LIST 가 생략되면 C<$_> 를 사용합니다.

=item unpack TEMPLATE,EXPR
X<unpack>

=item unpack TEMPLATE

=begin original

C<unpack> does the reverse of C<pack>: it takes a string
and expands it out into a list of values.
(In scalar context, it returns merely the first value produced.)

=end original

C<unpack> 은 C<pack> 의 반대를 수행합니다: 구조체를 표현하는 문자열을 
얻고, 리스트 값을 전개해 그 배열값을 반환합니다.
(스칼라 컨텍스트에서는 단순히 최초의 값을 반환합니다)

=begin original

If EXPR is omitted, unpacks the C<$_> string.

=end original

EXPr 이 생략되면 C<$_> 의 문열을 unpack 합니다.

=begin original

The string is broken into chunks described by the TEMPLATE.  Each chunk
is converted separately to a value.  Typically, either the string is a result
of C<pack>, or the characters of the string represent a C structure of some
kind.

=end original

문자열은 TEMPLATE 로 표현한 덩어리로 분할됩니다.
각각의 덩어리는 별개의 값으로 변환됩니다.
전형적으로는 문자열은 C<pack> 의 결과 혹은 어떤 종류의 C 의 구조체의 
문자열 표현의 문자열입니다.

=begin original

The TEMPLATE has the same format as in the C<pack> function.
Here's a subroutine that does substring:

=end original

TEMPLATE 는 C<pack> 함수와 같은 포맷을 사용합니다.
부분 문자열을 뽑아내는 서브루틴의 예제가 있습니다.

    sub substr {
	my($what,$where,$howmuch) = @_;
	unpack("x$where a$howmuch", $what);
    }

=begin original

and then there's

=end original

이것도 그렇습니다.

    sub ordinal { unpack("W",$_[0]); } # same as ord()

=begin original

In addition to fields allowed in pack(), you may prefix a field with
a %<number> to indicate that
you want a <number>-bit checksum of the items instead of the items
themselves.  Default is a 16-bit checksum.  Checksum is calculated by
summing numeric values of expanded values (for string fields the sum of
C<ord($char)> is taken, for bit fields the sum of zeroes and ones).

=end original

pack() 으로 이용가능한 필드 이외에 
필드의 앞에 %<수치> 라는 것을 붙이면, 
항목 자신을 대신해 그 항목의 <수치> 비트 체크섬을 
계산시키는 것이 가능합니다.
기본값은 16-비트 체크섬입니다.
체크섬은 전개된 값의 수치로 값의 합계
(문자열 필드의 경우는 C<ord($char)> 의 합계, 
비트 필드의 경우는 0 과 1 의 합계) 가 사용됩니다.

=begin original

For example, the following
computes the same number as the System V sum program:

=end original

예를들어 아래의 코드는 
System V 의 sub 프로그램처럼 값을 계산합니다.

    $checksum = do {
	local $/;  # slurp!
	unpack("%32W*",<>) % 65535;
    };

=begin original

The following efficiently counts the number of set bits in a bit vector:

=end original

아래는 효율적으로 비트 벡터가 설정된 비트를 세는 것입니다.

    $setbits = unpack("%32b*", $selectmask);

=begin original

The C<p> and C<P> formats should be used with care.  Since Perl
has no way of checking whether the value passed to C<unpack()>
corresponds to a valid memory location, passing a pointer value that's
not known to be valid is likely to have disastrous consequences.

=end original

C<p> 과 C<P> 는 주의 깊게 사용해야 됩니다.
Perl 은 C<unpack()> 에 넘겨진 값이 유효한 메모리 위치를 지정했는 지,
확인하는 방법이 없기 때문에, 유효현지 어떤지 모르는 포인터 값을 넘기면 
비참한 결과를 발생시킬지도 모릅니다.

=begin original

If there are more pack codes or if the repeat count of a field or a group
is larger than what the remainder of the input string allows, the result
is not well defined: in some cases, the repeat count is decreased, or
C<unpack()> will produce null strings or zeroes, or terminate with an
error. If the input string is longer than one described by the TEMPLATE,
the rest is ignored.

=end original

많은 pack 코드가 있는 경우나, 필드나 그룹의 반복횟수가 입력문자열의 
남은 것보다 더 큰 경우, 결과ㄴ 미정의입니다.
반복횟수가 줄어드는 경우도 있고, C<unpack()> 이 빈문자열이나 0 을 
반환하는 것도 있고, 에러로 종료하는 경우도 있습니다.
만약 입력문자열이 TEMPLATE 로 표현된 것보다 큰 경우, 남은 것은 
무시됩니다.

=begin original

See L</pack> for more examples and notes.

=end original

더 자세한 예제와 주의에 대해서는 L</pack> 을 참조해주세요.

=item untie VARIABLE
X<untie>

=begin original

Breaks the binding between a variable and a package.  (See C<tie>.)
Has no effect if the variable is not tied.

=end original

변수와 패키지의 사이의 결합을 해방합니다.
(L<tie> 를 참조해주세요)
결합되지 않은 경우는 아무것도 발생하지 않습니다.

=item unshift ARRAY,LIST
X<unshift>

=begin original

Does the opposite of a C<shift>.  Or the opposite of a C<push>,
depending on how you look at it.  Prepends list to the front of the
array, and returns the new number of elements in the array.

=end original

C<shift> 의 역조작을 수행합니다.
관점을 바꾸면, C<push> 의 역조작도 생각할 수 있습니다.
LIST 를 ARRAY 의 맨 앞에 넣고, 새롭게 생긴 배열의 요소의 수를 
반환합니다.

    unshift(@ARGV, '-e') unless $ARGV[0] =~ /^-/;

=begin original

Note the LIST is prepended whole, not one element at a time, so the
prepended elements stay in the same order.  Use C<reverse> to do the
reverse.

=end original

LIST 는 한번에 등록되기에 순서는 그대로입니다.
역순으로 등록하기에는 C<reverse> 를 사용해주세요.

=item use Module VERSION LIST
X<use> X<module> X<import>

=item use Module VERSION

=item use Module LIST

=item use Module

=item use VERSION

=begin original

Imports some semantics into the current package from the named module,
generally by aliasing certain subroutine or variable names into your
package.  It is exactly equivalent to

=end original

지정한 모듈에서 현재에서 현재의 패키지로 여러 내용을 임포트합니다.
많은 패키지의 서브루틴 이름이나 변수이름에 별명을 붙이는 것으로
표현될 수 있습니다. 이것은:

    BEGIN { require Module; Module->import( LIST ); }

=begin original

except that Module I<must> be a bareword.

=end original

Module 이 I<단순히 단어가 아니면 안되는> 것을 빼면 같습니다.

=begin original

In the peculiar C<use VERSION> form, VERSION may be either a numeric
argument such as 5.006, which will be compared to C<$]>, or a literal of
the form v5.6.1, which will be compared to C<$^V> (aka $PERL_VERSION).  A
fatal error is produced if VERSION is greater than the version of the
current Perl interpreter; Perl will not attempt to parse the rest of the
file.  Compare with L</require>, which can do a similar check at run time.
Symmetrically, C<no VERSION> allows you to specify that you want a version
of perl older than the specified one.

=end original

특히 C<use VERSION> 의 형식에서는 VERSION 은 5.006 처럼 
수치(C<$[> 와 비교됩니다)나 v.5.6.1 의 형식(C<$^V> (또는 이름을 
$PERL_VERSION) 과 비교됩니다)으로 지정합니다.
VERSION 이 Perl 의 표현의 버젼보다 크면 치명적 에러가 발생합니다;
Perl dㅡㄴ 파일의 남은 부분을 읽지 않습니다.
L</require> 와 비슷하지만, 이것은 실행시에 체크됩니다.
대칭적으로 C<no VERSION> 은 지정된 버젼보다 낡은 버젼의 Perl 로 
동작시키고 싶다는 것을 의미합니다.

=begin original

Specifying VERSION as a literal of the form v5.6.1 should generally be
avoided, because it leads to misleading error messages under earlier
versions of Perl that do not support this syntax.  The equivalent numeric
version should be used instead.

=end original

VERSION 에 v5.6.1 형식의 리터럴을 지정하는 것은 일반적으로는 피해야 합니다;
왜냐면 이 문법을 지원하지 않는 Perl 의 초기 버젼에서는 오해할 수 있는 
에러메시지가 나오기 때문입니다.
대신에 같은 행동을 하는 수치표현을 사용해야 합니다.

=begin original

Alternatively, you can use a numeric version C<use 5.006> followed by a
v-string version like C<use v5.10.1>, to avoid the unintuitive C<use
5.010_001>. (older perl versions fail gracefully at the first C<use>,
later perl versions understand the v-string syntax in the second).

=end original

혹은 직감적이지 않은 C<use 5.010_001> 을 피하기 위해 수치의 버젼
C<use 5.006> 을 쓰고나서 v 문자버젼 C<use v.5.10.1> 을 쓰는 방법도 
있습니다.
(낡은 버젼의 Perl 에서는 최초의 C<use> 에서 안전하게 실패하고, 
보다 새로운 버젼의 Perl 에서는 2번째의 v 문자의 문법을 이해합니다).

    use v5.6.1;		# compile time version check
    use 5.6.1;		# ditto
    use 5.006_001;	# ditto; preferred for backwards compatibility
    use 5.006; use 5.6.1;	# ditto, for compatibility and readability

=begin original

This is often useful if you need to check the current Perl version before
C<use>ing library modules that have changed in incompatible ways from
older versions of Perl.  (We try not to do this more than we have to.)

=end original

이것은 낡은 버젼의 Perl 에서 호환성 없는 형식으로 변경된 라이브리 
모듈(우리는 필요한 경우 이외에 그런 것이 없도록 노력하고 있습니다만)을 
C<use> 하기 전에 현재의 Perl 버젼을 조사하고 싶은 경우에 유용합니다.

=begin original

Also, if the specified perl version is greater than or equal to 5.9.5,
C<use VERSION> will also load the C<feature> pragma and enable all
features available in the requested version.  See L<feature>.

=end original

또, 지정된 perl 의 버ㄴ이 5.9.5 이상인 경우 C<use VERSION> 은 
C<feature> 프라그마도 읽고, 요구된 버젼에서 이요가능한 모든 기능을 
유효화합니다.
L<feature> 를 참조해주세요.

=begin original

The C<BEGIN> forces the C<require> and C<import> to happen at compile time.  The
C<require> makes sure the module is loaded into memory if it hasn't been
yet.  The C<import> is not a builtin--it's just an ordinary static method
call into the C<Module> package to tell the module to import the list of
features back into the current package.  The module can implement its
C<import> method any way it likes, though most modules just choose to
derive their C<import> method via inheritance from the C<Exporter> class that
is defined in the C<Exporter> module.  See L<Exporter>.  If no C<import>
method can be found then the call is skipped, even if there is an AUTOLOAD
method.

=end original

C<BEGIN> 에 의해 C<require> 나 C<import> 는 컴파일 시에 실행되는 것이 됩니다.
C<reuiqre> 는 모듈이 아직 메모리에 로드 되지 않았으면, 로드합니다.
C<import> 는 내장 함수가 아닌 여러 기능을 현재의 패키지에 임포트하도록 
C<Module> 패키지에 전달하기 위해 호출되는 일반적인 정적 메소드입니다.
모듈 측에서는 C<import> 메소드를 어떻게라도 구성하는 것이 가능하지만, 
많은 모듈에서는 C<Exporter> 모듈로 정의된 C<Exporter> 클래스에서의 
계승에 의해 C<import> 메소드를 수행하도록 하고 있습니다.
L<Exporter> 모듈을 참조해주세요.
C<import> 메소드가 발견되지 않은 경우, AUTOLOAD 메소드가 있다고 해도 
호출은 스킵됩니다.

=begin original

If you do not want to call the package's C<import> method (for instance,
to stop your namespace from being altered), explicitly supply the empty list:

=end original

패키지의 C<import> 메소드를 호출하고 싶지 않은 경우(예를들면, 이름공간을 
변경하고 싶지 않은 경우라든가)는 명시적으로 빈 리스트를 지정해주세요:

    use Module ();

=begin original

That is exactly equivalent to

=end original

이것은 아래와 완전히 같습니다:

    BEGIN { require Module }

=begin original

If the VERSION argument is present between Module and LIST, then the
C<use> will call the VERSION method in class Module with the given
version as an argument.  The default VERSION method, inherited from
the UNIVERSAL class, croaks if the given version is larger than the
value of the variable C<$Module::VERSION>.

=end original

Module 과 LIST 사이 VERSION 인수가 있는 경우, C<use> 는 Module 클래스의 
VERSION 메소드를 주어진 버젼을 인수로 호출합니다.
기본값의 VERSION 메소드는 UNIVERSAL 클래스에서 계승한 것으로 
주어진 버젼이 변수 C<$Module::VERSION> 의 값보다 큰 경우에 
경고를 냅니다.

=begin original

Again, there is a distinction between omitting LIST (C<import> called
with no arguments) and an explicit empty LIST C<()> (C<import> not
called).  Note that there is no comma after VERSION!

=end original

반복하면, LIST 를 생략하는(C<import> 가 인수없이 호출되는) 것과 
명시적으로 빈 리스트 C<()> 를 지정하는 (C<import> 는 호출되지 않음) 것은
다릅니다.
VERSION 의 뒤에 컴마가 불필요하는 것에 주의하세요.

=begin original

Because this is a wide-open interface, pragmas (compiler directives)
are also implemented this way.  Currently implemented pragmas are:

=end original

이것은 널리 공개된 인터페이스이기에, 프라그마(컴파일 디렉토리)도 
이 방법에으로 구성되어 있습니다.
현재 구성되어 있는 프라그마에는 아래와 같은 것이 있습니다.

    use constant;
    use diagnostics;
    use integer;
    use sigtrap  qw(SEGV BUS);
    use strict   qw(subs vars refs);
    use subs     qw(afunc blurfl);
    use warnings qw(all);
    use sort     qw(stable _quicksort _mergesort);

=begin original

Some of these pseudo-modules import semantics into the current
block scope (like C<strict> or C<integer>, unlike ordinary modules,
which import symbols into the current package (which are effective
through the end of the file).

=end original

통상의 모듈이 현재의 패키지에 심볼을 임포트하는 (이것은 파일의 끝까지
유효합니다) 것에 대해서 이 유소모듈들의 일부(C<strict>) 나 
C<interger> 등)는 현재의 블록 영역에 임포트를 수행합니다.

=begin original

There's a corresponding C<no> command that unimports meanings imported
by C<use>, i.e., it calls C<unimport Module LIST> instead of C<import>.
It behaves exactly as C<import> does with respect to VERSION, an
omitted LIST, empty LIST, or no unimport method being found.

=end original

이것에 대해서 C<no> 커맨드라는 C<use> 에 의해 임포트 되는 것을 
임포트되지 않는 것으로 하는 것이 있습니다.
즉, C<import> 대신에 c<unimport Module LIST> 를 호출합니다.
이것은 VERSION, 생략된 LIST, 빈 LIST, unimport 메소드가 발견되지 않은
경우 등의 관점에서는 정확하게 C<import> 처럼 행동합니다.

    no integer;
    no strict 'refs';
    no warnings;

=begin original

See L<perlmodlib> for a list of standard modules and pragmas.  See L<perlrun>
for the C<-M> and C<-m> command-line options to perl that give C<use>
functionality from the command-line.

=end original

표준모듈이 프라그마의 일람은 L<perlmodlib> 을 참조해주세요.
커맨드라인에서 C<use> 기능을 지정하기 위한 C<-M> 과 C<-m> 의 
커맨드라인옵션에 대해서는 L<perlrun> 을 참조하세요.

=item utime LIST
X<utime>

=begin original

Changes the access and modification times on each file of a list of
files.  The first two elements of the list must be the NUMERICAL access
and modification times, in that order.  Returns the number of files
successfully changed.  The inode change time of each file is set
to the current time.  For example, this code has the same effect as the
Unix touch(1) command when the files I<already exist> and belong to
the user running the program:

=end original

파일의 접근 시각과 수정(modification) 시각을 변경합니다.
LIST 의 최초의 2가지 요소에 숫자값으로 나타난 접근시각과 수정시각을 
순서대로 지정합니다.
LIST 의 남은 요소가 변경 대상이 되는 파일입니다.
변경에 성공한 파일의 수를 반환합니다.
각 파일의 inode 변경(change) 시각에는 그 시점의 시각이 설정됩니다.
예를 들면, 이 코드는 파일이 I<이미 존재하고> 있고, 유저가 
실행하고 있는 프로그램에 따르고 있다면, 
Unix 의 touch(1) 커맨드와 같은 효과가 있습니다.

    #!/usr/bin/perl
    $atime = $mtime = time;
    utime $atime, $mtime, @ARGV;

=begin original

Since perl 5.7.2, if the first two elements of the list are C<undef>, then
the utime(2) function in the C library will be called with a null second
argument. On most systems, this will set the file's access and
modification times to the current time (i.e. equivalent to the example
above) and will even work on other users' files where you have write
permission:

=end original

perl 5.7.2 부터 리스트의 최초의 두개의 요소가 C<undef> 인 경우, 
C 라이브러리의 utime(2) 함수를 초의 인수를 null 로 호출합니다.
대부분의 시스템에서는 이ㅅ에 의해 파일의 접근시각과 수정시각을 
현재의 시각으로 설정하고(즉, 위의 예제와 같습니다), 
쓰기 권한이 있으면 다른 유저의 파일에 대해서도 동작합니다.

    utime undef, undef, @ARGV;

=begin original

Under NFS this will use the time of the NFS server, not the time of
the local machine.  If there is a time synchronization problem, the
NFS server and local machine will have different times.  The Unix
touch(1) command will in fact normally use this form instead of the
one shown in the first example.

=end original

NFS 에서는 이것은 로컬머신의 시각이 아닌, NFS 서버의 시각이 
사용됩니다. 시각동기에 문제가 있는 경우, NFS 서버와 로컬머신에서 
다른 시각이 된 경우가 있습니다.
실제, Unix 의 touch(1) 커맨드는 보통 최초의 예가 아닌 
이 형태를 사용합니다.

=begin original

Note that only passing one of the first two elements as C<undef> will
be equivalent of passing it as 0 and will not have the same effect as
described when they are both C<undef>.  This case will also trigger an
uninitialized warning.

=end original

최초의 두개의 요소 중에 하나만 C<undef> 를 건네면 , 그 요소는 0 을 
넘기는 것과 같고, 위에 기술한 양쪽에 C<undef> 를 넘길 때와 같은 
효과가 아니라는 것에 주의해주세요.
이 경우는 미초기화의 경고가 나옵니다.

=begin original

On systems that support futimes, you might pass file handles among the
files.  On systems that don't support futimes, passing file handles
produces a fatal error at run time.  The file handles must be passed
as globs or references to be recognized.  Barewords are considered
file names.

=end original

futimes 를 지원하는 시스템에서는 파일핸들을 인수로 넘깁니다.
futimes 를 지원하지 않는 시스템에서는 파일핸들을 넘기ㄴ 실행시에 
치명적 에러가 됩니다.
파일핸들을 인식시키기 위해서는 glob 혹은 리퍼런스로 건네지 않으면 
안됩니다.
bareword 는 파일이름으로 취급됩니다.

=item values HASH
X<values>

=begin original

Returns a list consisting of all the values of the named hash.
(In a scalar context, returns the number of values.)

=end original

지정한 해쉬의 모든 value 에서 리스를 반환합니다.
(스칼라 컨텍스트에서는 value 의 수를 반환합니다)

=begin original

The values are returned in an apparently random order.  The actual
random order is subject to change in future versions of perl, but it
is guaranteed to be the same order as either the C<keys> or C<each>
function would produce on the same (unmodified) hash.  Since Perl
5.8.1 the ordering is different even between different runs of Perl
for security reasons (see L<perlsec/"Algorithmic Complexity Attacks">).

=end original

반환되는 value 의 순서는 보기에는 엉망진장입니다.
실제 랜덤한 순서는 앞으로의 버젼의 perl dㅔ서는 바뀔 가능성이 있지만,
같은(변경되지 않은) 해쉬에 대해서 C<keys> 함수나 함수가 반환하는 것과 
같은 순서인 것은 보증됩니다.
Perl 5.8.1 이후에서는 보안상의 이유에 의해 실행되는 때에 순서는 바뀝니다.
(L<perlsec/"Algorithmic Complexity Attacks"> 를 참조해주세요)。

=begin original

As a side effect, calling values() resets the HASH's internal iterator,
see L</each>. (In particular, calling values() in void context resets
the iterator with no other overhead.)

=end original

부작용으로서 values() 를 호출하면 HASH 의 내부 반복자를 리셋합니다:
C</each> 를 참조해주세요.
(특히, values() 를 무효 컨텍스트에서 호출하면 그 외의 오버헤드없이 
반복자를 리셋합니다).

=begin original

Note that the values are not copied, which means modifying them will
modify the contents of the hash:

=end original

값은 복사되지 않기에 반환된 리스트를 변경하면 해쉬의 내용이 변경되는 
것에 주의해주세요.

    for (values %hash) 	    { s/foo/bar/g }   # modifies %hash values
    for (@hash{keys %hash}) { s/foo/bar/g }   # same

=begin original

See also C<keys>, C<each>, and C<sort>.

=end original

C<keys>, C<each>, C<sort> 도 참조해주세요.

=item vec EXPR,OFFSET,BITS
X<vec> X<bit> X<bit vector>

=begin original

Treats the string in EXPR as a bit vector made up of elements of
width BITS, and returns the value of the element specified by OFFSET
as an unsigned integer.  BITS therefore specifies the number of bits
that are reserved for each element in the bit vector.  This must
be a power of two from 1 to 32 (or 64, if your platform supports
that).

=end original

문자열 EXPR 을 BITS 폭의 요소로부터 비트벡터로 취급하고, 
OFFSET 에서 지정된 요소의 값을 반환합니다.
OFFSET 에서 지정한 요소를 부호없는 정수로 반환합니다.
따라서 BITS 는 비트벡터의 안의 각요에 대해서 예약되는 비트수입니다.
BIT 는 1에서 32까지(플랫폼이 지원하면 64까지) 2승이 아니면 안됩니다.

=begin original

If BITS is 8, "elements" coincide with bytes of the input string.

=end original

BITS 가 8인 경우 "요소"는 입력문자열의 각 바이트와 일치합니다.

=begin original

If BITS is 16 or more, bytes of the input string are grouped into chunks
of size BITS/8, and each group is converted to a number as with
pack()/unpack() with big-endian formats C<n>/C<N> (and analogously
for BITS==64).  See L<"pack"> for details.

=end original

BITS 가 16 이상인 경우, 입력의 바이트열은 BITS/8 의 사이즈의 덩어로 
그룹화되고, 각 그룹은 pack()/unpack() 의 빅엔디안 포맷 C<n>/C<N> 을 
사용해 (BITS == 64 의 유사치로) 수치로 변환되니다.
자세한 내용은 L<"pack"> 을 참조해주세요.

=begin original

If bits is 4 or less, the string is broken into bytes, then the bits
of each byte are broken into 8/BITS groups.  Bits of a byte are
numbered in a little-endian-ish way, as in C<0x01>, C<0x02>,
C<0x04>, C<0x08>, C<0x10>, C<0x20>, C<0x40>, C<0x80>.  For example,
breaking the single input byte C<chr(0x36)> into two groups gives a list
C<(0x6, 0x3)>; breaking it into 4 groups gives C<(0x2, 0x1, 0x3, 0x0)>.

=end original

BITS 가 4 이하인 경우, 문자열은 바이트로 분해되고, 바이트의 각 비트는 
8/BITS 개의 그룹으로 분할됩니다.
비트는 리틀 엔디안 풍에 C<0x01>, C<0x02>, C<0x04>, C<0x08>, C<0x10>, 
C<0x20>, C<0x40>, C<0x80> 의 순서가 됩니다.
예를들면, 입력 바이트 C<chr(0x36)> 을 2개의 그룹으로 분할하면 
C<0x6, 03)> 이 됩니다.
4개로 분할하면 C<0x2, 0x1, 0x3, 0x0)> 가 됩니다.

=begin original

C<vec> may also be assigned to, in which case parentheses are needed
to give the expression the correct precedence as in

=end original

좌변값으로 대입의 대상으로 할 수도 있습니다.
이 경우, 식을 바로 선행시키기 위해 아래처럼 괄호가 필요합니다.

    vec($image, $max_x * $x + $y, 8) = 3;

=begin original

If the selected element is outside the string, the value 0 is returned.
If an element off the end of the string is written to, Perl will first
extend the string with sufficiently many zero bytes.   It is an error
to try to write off the beginning of the string (i.e. negative OFFSET).

=end original

선택된 요소가 문자열의 바깥쪽인 경우, 값 0가 반환됩니다.
문자열의 최후보다도 뒤의 요소에 쓸려고한 경우, 
Perl 은 우선 문자열을 필요한 분만큼 0의 바이트로 확장합니다.
문자열의 맨앞보다 앞에 쓸려고 한(즉 OFFSET 이 음수인) 
경우는 에러가 됩니다.

=begin original

If the string happens to be encoded as UTF-8 internally (and thus has
the UTF8 flag set), this is ignored by C<vec>, and it operates on the
internal byte string, not the conceptual character string, even if you
only have characters with values less than 256. 

=end original

문자열이 왠지모르게 내부에서 UTF-8 으로 인코드되는 경우( 따라서 UTF8 플래그가
설정되어 있는 경우), 이것은 C<vec> 에서는 무시되고, 설령 값이 246 미만의 
문자만이이었다고 해도 개념적인 문자열이 아닌 내부바이트 문자열로 조작됩니다.

=begin original

Strings created with C<vec> can also be manipulated with the logical
operators C<|>, C<&>, C<^>, and C<~>.  These operators will assume a bit
vector operation is desired when both operands are strings.
See L<perlop/"Bitwise String Operators">.

=end original

vec() 으로 조작된 문열은 논리연산자 C<|>, C<&>, C<^> 로 취급할 수도 있습니다.
이 연산자들은 양쪽의 피연산자로 문자열을 사용하면, 비트벡터 연산을 수행합니다.

=begin original

The following code will build up an ASCII string saying C<'PerlPerlPerl'>.
The comments show the string after each step.  Note that this code works
in the same way on big-endian or little-endian machines.

=end original

다음의 코드는 C<'PerlPerlPerl'> 이라는 ASCII 문자열을 작성합니다.
코멘트는 각 행의 실행수의 문자열을 표시합니다.
이 코드는 빅엔디안에서도 리틀엔디안에서도 마찬가지로 동작하는 것에 
주의하세요.

    my $foo = '';
    vec($foo,  0, 32) = 0x5065726C;	# 'Perl'

    # $foo eq "Perl" eq "\x50\x65\x72\x6C", 32 bits
    print vec($foo, 0, 8);		# prints 80 == 0x50 == ord('P')

    vec($foo,  2, 16) = 0x5065;		# 'PerlPe'
    vec($foo,  3, 16) = 0x726C;		# 'PerlPerl'
    vec($foo,  8,  8) = 0x50;		# 'PerlPerlP'
    vec($foo,  9,  8) = 0x65;		# 'PerlPerlPe'
    vec($foo, 20,  4) = 2;		# 'PerlPerlPe'   . "\x02"
    vec($foo, 21,  4) = 7;		# 'PerlPerlPer'
                                        # 'r' is "\x72"
    vec($foo, 45,  2) = 3;		# 'PerlPerlPer'  . "\x0c"
    vec($foo, 93,  1) = 1;		# 'PerlPerlPer'  . "\x2c"
    vec($foo, 94,  1) = 1;		# 'PerlPerlPerl'
                                        # 'l' is "\x6c"

=begin original

To transform a bit vector into a string or list of 0's and 1's, use these:

=end original

비트벡터를 0과 1 의 문자열이나 배열로 변환하려면 아래처럼 합니다.

    $bits = unpack("b*", $vector);
    @bits = split(//, unpack("b*", $vector));

=begin original

If you know the exact length in bits, it can be used in place of the C<*>.

=end original

비트길이를 알고 있다면 *  대신에 그 길이를 사용할 수 있습니다.

=begin original

Here is an example to illustrate how the bits actually fall in place:

=end original

이것은 비트가 실제 어떤 위치에 들어가는 가를 표시하는 예제입니다.

    #!/usr/bin/perl -wl

    print <<'EOT';
                                      0         1         2         3
                       unpack("V",$_) 01234567890123456789012345678901
    ------------------------------------------------------------------
    EOT

    for $w (0..3) {
        $width = 2**$w;
        for ($shift=0; $shift < $width; ++$shift) {
            for ($off=0; $off < 32/$width; ++$off) {
                $str = pack("B*", "0"x32);
                $bits = (1<<$shift);
                vec($str, $off, $width) = $bits;
                $res = unpack("b*",$str);
                $val = unpack("V", $str);
                write;
            }
        }
    }

    format STDOUT =
    vec($_,@#,@#) = @<< == @######### @>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    $off, $width, $bits, $val, $res
    .
    __END__

=begin original

Regardless of the machine architecture on which it is run, the above
example should print the following table:

=end original

실행하는 머신의 아키텍쳐에 상관없이 위의 예제는 아래의 표를 출력합니다.

                                      0         1         2         3
                       unpack("V",$_) 01234567890123456789012345678901
    ------------------------------------------------------------------
    vec($_, 0, 1) = 1   ==          1 10000000000000000000000000000000
    vec($_, 1, 1) = 1   ==          2 01000000000000000000000000000000
    vec($_, 2, 1) = 1   ==          4 00100000000000000000000000000000
    vec($_, 3, 1) = 1   ==          8 00010000000000000000000000000000
    vec($_, 4, 1) = 1   ==         16 00001000000000000000000000000000
    vec($_, 5, 1) = 1   ==         32 00000100000000000000000000000000
    vec($_, 6, 1) = 1   ==         64 00000010000000000000000000000000
    vec($_, 7, 1) = 1   ==        128 00000001000000000000000000000000
    vec($_, 8, 1) = 1   ==        256 00000000100000000000000000000000
    vec($_, 9, 1) = 1   ==        512 00000000010000000000000000000000
    vec($_,10, 1) = 1   ==       1024 00000000001000000000000000000000
    vec($_,11, 1) = 1   ==       2048 00000000000100000000000000000000
    vec($_,12, 1) = 1   ==       4096 00000000000010000000000000000000
    vec($_,13, 1) = 1   ==       8192 00000000000001000000000000000000
    vec($_,14, 1) = 1   ==      16384 00000000000000100000000000000000
    vec($_,15, 1) = 1   ==      32768 00000000000000010000000000000000
    vec($_,16, 1) = 1   ==      65536 00000000000000001000000000000000
    vec($_,17, 1) = 1   ==     131072 00000000000000000100000000000000
    vec($_,18, 1) = 1   ==     262144 00000000000000000010000000000000
    vec($_,19, 1) = 1   ==     524288 00000000000000000001000000000000
    vec($_,20, 1) = 1   ==    1048576 00000000000000000000100000000000
    vec($_,21, 1) = 1   ==    2097152 00000000000000000000010000000000
    vec($_,22, 1) = 1   ==    4194304 00000000000000000000001000000000
    vec($_,23, 1) = 1   ==    8388608 00000000000000000000000100000000
    vec($_,24, 1) = 1   ==   16777216 00000000000000000000000010000000
    vec($_,25, 1) = 1   ==   33554432 00000000000000000000000001000000
    vec($_,26, 1) = 1   ==   67108864 00000000000000000000000000100000
    vec($_,27, 1) = 1   ==  134217728 00000000000000000000000000010000
    vec($_,28, 1) = 1   ==  268435456 00000000000000000000000000001000
    vec($_,29, 1) = 1   ==  536870912 00000000000000000000000000000100
    vec($_,30, 1) = 1   == 1073741824 00000000000000000000000000000010
    vec($_,31, 1) = 1   == 2147483648 00000000000000000000000000000001
    vec($_, 0, 2) = 1   ==          1 10000000000000000000000000000000
    vec($_, 1, 2) = 1   ==          4 00100000000000000000000000000000
    vec($_, 2, 2) = 1   ==         16 00001000000000000000000000000000
    vec($_, 3, 2) = 1   ==         64 00000010000000000000000000000000
    vec($_, 4, 2) = 1   ==        256 00000000100000000000000000000000
    vec($_, 5, 2) = 1   ==       1024 00000000001000000000000000000000
    vec($_, 6, 2) = 1   ==       4096 00000000000010000000000000000000
    vec($_, 7, 2) = 1   ==      16384 00000000000000100000000000000000
    vec($_, 8, 2) = 1   ==      65536 00000000000000001000000000000000
    vec($_, 9, 2) = 1   ==     262144 00000000000000000010000000000000
    vec($_,10, 2) = 1   ==    1048576 00000000000000000000100000000000
    vec($_,11, 2) = 1   ==    4194304 00000000000000000000001000000000
    vec($_,12, 2) = 1   ==   16777216 00000000000000000000000010000000
    vec($_,13, 2) = 1   ==   67108864 00000000000000000000000000100000
    vec($_,14, 2) = 1   ==  268435456 00000000000000000000000000001000
    vec($_,15, 2) = 1   == 1073741824 00000000000000000000000000000010
    vec($_, 0, 2) = 2   ==          2 01000000000000000000000000000000
    vec($_, 1, 2) = 2   ==          8 00010000000000000000000000000000
    vec($_, 2, 2) = 2   ==         32 00000100000000000000000000000000
    vec($_, 3, 2) = 2   ==        128 00000001000000000000000000000000
    vec($_, 4, 2) = 2   ==        512 00000000010000000000000000000000
    vec($_, 5, 2) = 2   ==       2048 00000000000100000000000000000000
    vec($_, 6, 2) = 2   ==       8192 00000000000001000000000000000000
    vec($_, 7, 2) = 2   ==      32768 00000000000000010000000000000000
    vec($_, 8, 2) = 2   ==     131072 00000000000000000100000000000000
    vec($_, 9, 2) = 2   ==     524288 00000000000000000001000000000000
    vec($_,10, 2) = 2   ==    2097152 00000000000000000000010000000000
    vec($_,11, 2) = 2   ==    8388608 00000000000000000000000100000000
    vec($_,12, 2) = 2   ==   33554432 00000000000000000000000001000000
    vec($_,13, 2) = 2   ==  134217728 00000000000000000000000000010000
    vec($_,14, 2) = 2   ==  536870912 00000000000000000000000000000100
    vec($_,15, 2) = 2   == 2147483648 00000000000000000000000000000001
    vec($_, 0, 4) = 1   ==          1 10000000000000000000000000000000
    vec($_, 1, 4) = 1   ==         16 00001000000000000000000000000000
    vec($_, 2, 4) = 1   ==        256 00000000100000000000000000000000
    vec($_, 3, 4) = 1   ==       4096 00000000000010000000000000000000
    vec($_, 4, 4) = 1   ==      65536 00000000000000001000000000000000
    vec($_, 5, 4) = 1   ==    1048576 00000000000000000000100000000000
    vec($_, 6, 4) = 1   ==   16777216 00000000000000000000000010000000
    vec($_, 7, 4) = 1   ==  268435456 00000000000000000000000000001000
    vec($_, 0, 4) = 2   ==          2 01000000000000000000000000000000
    vec($_, 1, 4) = 2   ==         32 00000100000000000000000000000000
    vec($_, 2, 4) = 2   ==        512 00000000010000000000000000000000
    vec($_, 3, 4) = 2   ==       8192 00000000000001000000000000000000
    vec($_, 4, 4) = 2   ==     131072 00000000000000000100000000000000
    vec($_, 5, 4) = 2   ==    2097152 00000000000000000000010000000000
    vec($_, 6, 4) = 2   ==   33554432 00000000000000000000000001000000
    vec($_, 7, 4) = 2   ==  536870912 00000000000000000000000000000100
    vec($_, 0, 4) = 4   ==          4 00100000000000000000000000000000
    vec($_, 1, 4) = 4   ==         64 00000010000000000000000000000000
    vec($_, 2, 4) = 4   ==       1024 00000000001000000000000000000000
    vec($_, 3, 4) = 4   ==      16384 00000000000000100000000000000000
    vec($_, 4, 4) = 4   ==     262144 00000000000000000010000000000000
    vec($_, 5, 4) = 4   ==    4194304 00000000000000000000001000000000
    vec($_, 6, 4) = 4   ==   67108864 00000000000000000000000000100000
    vec($_, 7, 4) = 4   == 1073741824 00000000000000000000000000000010
    vec($_, 0, 4) = 8   ==          8 00010000000000000000000000000000
    vec($_, 1, 4) = 8   ==        128 00000001000000000000000000000000
    vec($_, 2, 4) = 8   ==       2048 00000000000100000000000000000000
    vec($_, 3, 4) = 8   ==      32768 00000000000000010000000000000000
    vec($_, 4, 4) = 8   ==     524288 00000000000000000001000000000000
    vec($_, 5, 4) = 8   ==    8388608 00000000000000000000000100000000
    vec($_, 6, 4) = 8   ==  134217728 00000000000000000000000000010000
    vec($_, 7, 4) = 8   == 2147483648 00000000000000000000000000000001
    vec($_, 0, 8) = 1   ==          1 10000000000000000000000000000000
    vec($_, 1, 8) = 1   ==        256 00000000100000000000000000000000
    vec($_, 2, 8) = 1   ==      65536 00000000000000001000000000000000
    vec($_, 3, 8) = 1   ==   16777216 00000000000000000000000010000000
    vec($_, 0, 8) = 2   ==          2 01000000000000000000000000000000
    vec($_, 1, 8) = 2   ==        512 00000000010000000000000000000000
    vec($_, 2, 8) = 2   ==     131072 00000000000000000100000000000000
    vec($_, 3, 8) = 2   ==   33554432 00000000000000000000000001000000
    vec($_, 0, 8) = 4   ==          4 00100000000000000000000000000000
    vec($_, 1, 8) = 4   ==       1024 00000000001000000000000000000000
    vec($_, 2, 8) = 4   ==     262144 00000000000000000010000000000000
    vec($_, 3, 8) = 4   ==   67108864 00000000000000000000000000100000
    vec($_, 0, 8) = 8   ==          8 00010000000000000000000000000000
    vec($_, 1, 8) = 8   ==       2048 00000000000100000000000000000000
    vec($_, 2, 8) = 8   ==     524288 00000000000000000001000000000000
    vec($_, 3, 8) = 8   ==  134217728 00000000000000000000000000010000
    vec($_, 0, 8) = 16  ==         16 00001000000000000000000000000000
    vec($_, 1, 8) = 16  ==       4096 00000000000010000000000000000000
    vec($_, 2, 8) = 16  ==    1048576 00000000000000000000100000000000
    vec($_, 3, 8) = 16  ==  268435456 00000000000000000000000000001000
    vec($_, 0, 8) = 32  ==         32 00000100000000000000000000000000
    vec($_, 1, 8) = 32  ==       8192 00000000000001000000000000000000
    vec($_, 2, 8) = 32  ==    2097152 00000000000000000000010000000000
    vec($_, 3, 8) = 32  ==  536870912 00000000000000000000000000000100
    vec($_, 0, 8) = 64  ==         64 00000010000000000000000000000000
    vec($_, 1, 8) = 64  ==      16384 00000000000000100000000000000000
    vec($_, 2, 8) = 64  ==    4194304 00000000000000000000001000000000
    vec($_, 3, 8) = 64  == 1073741824 00000000000000000000000000000010
    vec($_, 0, 8) = 128 ==        128 00000001000000000000000000000000
    vec($_, 1, 8) = 128 ==      32768 00000000000000010000000000000000
    vec($_, 2, 8) = 128 ==    8388608 00000000000000000000000100000000
    vec($_, 3, 8) = 128 == 2147483648 00000000000000000000000000000001

=item wait
X<wait>

=begin original

Behaves like the wait(2) system call on your system: it waits for a child
process to terminate and returns the pid of the deceased process, or
C<-1> if there are no child processes.  The status is returned in C<$?>
and C<{^CHILD_ERROR_NATIVE}>.
Note that a return value of C<-1> could mean that child processes are
being automatically reaped, as described in L<perlipc>.

=end original

wait(2) 시스템 호출과 마찬가지로 행동합니다.
자식 프로세스가 종료하는 것을 기다리고, 소멸한 프로세스의 pid 를 반환합니다.
자식 프로세스가 존재하지 않은 때에는 C<-1> 을 반환합니다.
상태는 C<$?> 와 C<{^CHILD_ERROR_NATIVE}> 로 반환됩니다.
L<perlpc> 에 쓰여져 있듯, 반환값이 C<-1> 인 경우는 자식 프로세스가 
자동적으로 없어진 것을 의미할 지도 모르는 것에 주의하세요.

=item waitpid PID,FLAGS
X<waitpid>

=begin original

Waits for a particular child process to terminate and returns the pid of
the deceased process, or C<-1> if there is no such child process.  On some
systems, a value of 0 indicates that there are processes still running.
The status is returned in C<$?> and C<{^CHILD_ERROR_NATIVE}>.  If you say

=end original

특정의 자식프로세스가 종료하는 것을 기다리고, 소멸ㄴ 프로세스의 pid 를 
반환합니다.
지정한 자식프로세스가 존재하지 않을 때에는 C<-1> 을 반환합니다.
값 0 이 프로세스가 아직 실행중인 것을 나타내는 시스템도 있습니다.
상태는 C<$?> 와 C<{^CHILD_ERROR_NATIVE}> 로 반환됩니다.

    use POSIX ":sys_wait_h";
    #...
    do {
	$kid = waitpid(-1, WNOHANG);
    } while $kid > 0;

=begin original

then you can do a non-blocking wait for all pending zombie processes.
Non-blocking wait is available on machines supporting either the
waitpid(2) or wait4(2) system calls.  However, waiting for a particular
pid with FLAGS of C<0> is implemented everywhere.  (Perl emulates the
system call by remembering the status values of processes that have
exited but have not been harvested by the Perl script yet.)

=end original

라고 하면, 블록이 발생되지 않도록 해서, 모든 대기중 좀비 프로세스를 wait
합니다. 블록 없는 wait 는 시스템 호출 wait_pid(2) 나, 시스템 호출 wait4(2)를
지원하는 머신에서 이용가능합니다.
그렇지만, 특정의 pid 를 C<0> 의 FLAGS 에서의 wait 는 어디에서든 
구성됩니다.
(exit 한 프로세스의 상태값을 기억해두고, Perl 이 시스템호출을 에뮬레이트
하지만, Perl 스크립트에는 들어가지 않습니다)

=begin original

Note that on some systems, a return value of C<-1> could mean that child
processes are being automatically reaped.  See L<perlipc> for details,
and for other examples.

=end original

시스템에 따라서는 반환값이 C<-1> 인 경우는 자식프로세스가 자동적으로 
없어진 것을 의미할지도 모릅니다.
자세한 내용이나 그외의 예제에 대해서는 L<perlipc> 를 참조해주세요.

=item wantarray
X<wantarray> X<context>

=begin original

Returns true if the context of the currently executing subroutine or
C<eval> is looking for a list value.  Returns false if the context is
looking for a scalar.  Returns the undefined value if the context is
looking for no value (void context).

=end original

현재 실행중인 서브루틴이나 eval() 블록의 컨텍스트가 리스트값을 
요구하는 것이면 참을 반환합니다.
스칼라를 요구하는 컨텍스트라면 거짓을 반환합니다.
아무런 값을 요구하지 않는(무효 컨텍트) 경우는 미정의값을 반환합니다.

    return unless defined wantarray;	# don't bother doing more
    my @a = complex_calculation();
    return wantarray ? @a : "@a";

=begin original

C<wantarray()>'s result is unspecified in the top level of a file,
in a C<BEGIN>, C<UNITCHECK>, C<CHECK>, C<INIT> or C<END> block, or
in a C<DESTROY> method.

=end original

파일의 톱 레벨, C<BEGIN>, C<UNITCHECK>, C<CHECK>, C<INIT>, C<END>
불록 안, C<DESTROY> 메소드 안에서는 C<wantarray()> 의 결과는 미정의입니다.

=begin original

This function should have been named wantlist() instead.

=end original

이 함수는 wantlist() 라는 이름으로 해야했었습니다.

=item warn LIST
X<warn> X<warning> X<STDERR>

=begin original

Prints the value of LIST to STDERR.  If the last element of LIST does
not end in a newline, it appends the same file/line number text as C<die>
does.

=end original

LIST 의 값을 STDERR 로 출력합니다.
LIST 의 마지막의 요소가 개행으로 끝나지 않으면, C<die> 가 수행하는 것과 
마찬가지로 파일/행번호의 텍스트가 추가됩니다.

=begin original

If LIST is empty and C<$@> already contains a value (typically from a
previous eval) that value is used after appending C<"\t...caught">
to C<$@>.  This is useful for staying almost, but not entirely similar to
C<die>.

=end original

LIST 가 비었거나, (전형적으로는 이전의 eval 에 의해) C<$@> 에 이미 값이 
들어있는 경우, C<$@> 에 C<"\t...caught"> 을 추가한 값이 사용됩니다.
이것은 대부분 그대로 하는 때에 편리하지만, C<die> 와 전체적으로 비슷하지는
않습니다.

=begin original

If C<$@> is empty then the string C<"Warning: Something's wrong"> is used.

=end original

C<$@> 가 빈 경우는 C<"Warning: Something's wrong"> 이라는 문자열이 사용됩니다.

=begin original

No message is printed if there is a C<$SIG{__WARN__}> handler
installed.  It is the handler's responsibility to deal with the message
as it sees fit (like, for instance, converting it into a C<die>).  Most
handlers must therefore make arrangements to actually display the
warnings that they are not prepared to deal with, by calling C<warn>
again in the handler.  Note that this is quite safe and will not
produce an endless loop, since C<__WARN__> hooks are not called from
inside one.

=end original

C<$SIG{__WARN__}> 핸들러가 설정된 경우는 어떤 메시지도 표시되지 않습니다.
메시지를 어떻게 취급하는 가(예를 들어 C<die> 로 변환하는가)는 핸들러의 
책임이라는 겁니다.
따라서 대부분의 핸들러는 다루려면 준비되지 않은 경고를 표시하기 때문에 
핸들러 안에서 C<warn> 을 다시 호출합니다.
C<__WARN__> 후크는 핸들러 안에서는 호출되지 않기에, 이것은 충분히 안전하고,
무한 루프를 일으키는 일은 없다는 것을 주의하세요.

=begin original

You will find this behavior is slightly different from that of
C<$SIG{__DIE__}> handlers (which don't suppress the error text, but can
instead call C<die> again to change it).

=end original

이 행위는 C<$SIG{__DIE__}> 핸들러(에러 텍스트는 삭제하지않지만, 
대신에 C<die> 를 한번 더 호출하는 것으로 변경할 수 있습니다) 와는 
조금 다르다는 것을 눈치챌 겁니다.

=begin original

Using a C<__WARN__> handler provides a powerful way to silence all
warnings (even the so-called mandatory ones).  An example:

=end original

C<__WARN__> 핸들러를 사용하면, (일련의 필수사항을 포함한) 모든 
경고를 내지않게하는 강력한 수단이 됩니다.
예제:

    # wipe out *all* compile-time warnings
    BEGIN { $SIG{'__WARN__'} = sub { warn $_[0] if $DOWARN } }
    my $foo = 10;
    my $foo = 20;          # no warning about duplicate my $foo,
                           # but hey, you asked for it!
    # no compile-time or run-time warnings before here
    $DOWARN = 1;

    # run-time warnings enabled after here
    warn "\$foo is alive and $foo!";     # does show up

=begin original

See L<perlvar> for details on setting C<%SIG> entries, and for more
examples.  See the Carp module for other kinds of warnings using its
carp() and cluck() functions.

=end original

C<%SIG> 엔트리의 세트에 관한 자세한 내용과 예제에 관해서는 
L<perlvar> 를 참조해주세요.
carp() 함수와 cluck() 함수를 사용한 경고 방법에 대해서는 
Carp 모듈을 참조해주세요.

=item write FILEHANDLE
X<write>

=item write EXPR

=item write

=begin original

Writes a formatted record (possibly multi-line) to the specified FILEHANDLE,
using the format associated with that file.  By default the format for
a file is the one having the same name as the filehandle, but the
format for the current output channel (see the C<select> function) may be set
explicitly by assigning the name of the format to the C<$~> variable.

=end original

지정된 FILEHADNLE 에 대해서 그 파일을 지원하는 포맷을 사용해서 (복수행의 
경우도 있습니다) 고친 레코드를 써냅니다.
기본값ㅂ에서는 파일을 지원하는 포맷은 파일핸들과 같은 이름이지만, 
그 시점의 출력 채널 (C<select> 함수의 항을 참조해주세요) 의 포맷은 
그 이름을 명시적으로 변수 C<$~> 에 대입하는 것으로 이용가능합니다.

=begin original

Top of form processing is handled automatically:  if there is
insufficient room on the current page for the formatted record, the
page is advanced by writing a form feed, a special top-of-page format
is used to format the new page header, and then the record is written.
By default the top-of-page format is the name of the filehandle with
"_TOP" appended, but it may be dynamically set to the format of your
choice by assigning the name to the C<$^> variable while the filehandle is
selected.  The number of lines remaining on the current page is in
variable C<$->, which can be set to C<0> to force a new page.

=end original

페이지의 맨앞의 처리는 자동적으로 수행됩니다.
현재의 페이지에 정형된 레코드를 출력하는 것만큼의 스페이스가 없는 경우에는 
페이지 넘김을 수행해서 페이지를 진행하고, 새로운 페이지 헤더를 정형하기 위해,
페이지 맨앞 포맷이 사용되어, 그 뒤에 레코드가 써집니다.
기본값에서는 페이지 선두 포맷은 파일핸들의 이름에 
"_TOP" 을 붙인 것이지만, 파일핸들이 선택되어 있는 사이에, 
변수 C<$^A> 에 이름을 설정하면, 동적으로 포맷을 변경할 수 있습니다.
그 페이지의 남은 행수는 변수 C<$-> 에 들어 있고, 그 변수를 0 으로 설정하는 
것으로, 강제적으로 페이지넘김을 수행할 수 있습니다.

=begin original

If FILEHANDLE is unspecified, output goes to the current default output
channel, which starts out as STDOUT but may be changed by the
C<select> operator.  If the FILEHANDLE is an EXPR, then the expression
is evaluated and the resulting string is used to look up the name of
the FILEHANDLE at run time.  For more on formats, see L<perlform>.

=end original

FILEHANDLE 을 지정하지 않으면 출력은 그 시점의 기본값 출력 채널에 대해서 
수행됩니다. 이것은 스크립트의 개시시점에서는 STDOUT 입니다만, seelct() 연산자
에서 변경할 수 있습니다.
FILEHANDLE 이 EXPR 이라면 식이 평가되어 그 결과의 문자열이 실행시에 
FILEHANDLE 의 이름으로 보입니다.
포맷에 대한 자세한 내용은 L<perlform> 을 참조해주세요.

=begin original

Note that write is I<not> the opposite of C<read>.  Unfortunately.

=end original

아쉽게도 write 는 C<read> 의 반대되는 일을 하는 것이 I<아닙니다>.

=item y///

=begin original

The transliteration operator.  Same as C<tr///>.  See L<perlop>.

=end original

문자변환연산자입니다.
C<tr///> 과 같습니다.
L<perlop> 를 참조하세요.

=back
