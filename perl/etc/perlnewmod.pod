=head1 이름

perlnewmod - 새로운 모듈을 배포하기 위해 

=head1 설명

이 문서는 Perl 모듈을 써서, 배포하는 준비를 하고, CPAN을 통해서 
얻을 수 있도록 하기 위한 어드바이스입니다.

Perl 이 실제로 이렇게 강력한 이유의 하나로써는 Perl 해커들이 자신들이 
직면한 문제의 해결법을 공유하려고 하는 것이라고 할 수 있겠죠.
그래서, 모두가 같은 문제에 고민할 필요는 없다는 것입니다.

이것이 실현되는 것은 많은 경우의 솔루션을 추상화해서 
Perl 모듈에 하고 있는 것입니다. 만약 이것이 무엇인지 모르겠다면,
이 문서의 남은 부분은 그다지 도움이 되지 않을 것이고, 지금까지 
많은 편리한 코드를 보고 헤매고 있을 것입니다. L<perlmod>, 
L<perlmodlib>, L<perlmodinstall> 을 잘 읽고 다시 와주세요.

만약, 당신이 해야하는 것에 관한 모듈이 존재지 않고, 자신이 코드를 
쓰지 않으면 안될 때에는 그 솔루션을 모듈에 넣고 CPAN에 업로드하는 것을 
검토해주세요. 그렇게 하면 다른 모든 이에게 이익이 될겁니다.

=head2 경고

여기에서는 주로 Pure Perl 의 모듈에 대해서 설명하고, XS 모듈에 대해서는
건드리지 않습니다. XS 모듈은 일반적으로는 약간 다른 목적으로 이용되기에 
배포할 때에는 별도의 문제에 대해서 고려할 필요가 있습니다. 즉, glue의
대상이 되는 라이브러리의 인기, 다른 OS로의 포터빌리티 등입니다.
그러나 모듈의 준비나 패키징, 배포의 설명은 XS 모둘에도 똑같이 적용될겁니다.

=head2 무엇을 모듈로 하면 좋은가?

다른 사람에게 편리한 것이라면 어떤 코드라도 모듈로 해야합니다.
모두가 사용하고 있는 라이브러리에 부족한 것을 넣고, 거기에 다른 사람이 자신의
프로램에 직접 집어넣는 것이라면 뭐든지 OK입니다. 당신의 코드에 
단독으로 날아서 다른 것에 넣을 것이 있다면 그것은 모듈의 후보가 될 것입니다.

예제를 보겠습니다. 로컬의 포맷에서 데이터를 읽어들여, Perl 의 
해쉬리퍼런스의 해쉬로 해서, 트리 구조로 해서, 트리를 조작해서 
각각의 노드를 Acme Transmogrifier Server 에 파이프한다고 합시다.

그럼 Acme Transmogrifier 를 가지고 있는 사람은 그다지 없을 겁니다.
그렇기에 그 프로토콜을 이야기하는 코드를 스크래치에서 쓰지 않으면 
안되겠죠. 그럴 때, 그것을 모듈로 하고 싶을 겁니다. 어떤 레벨에서 
조작하는 가는 당신이 하기 나름ㅣㅂ니다. L<Net::SMTP> 같은 프로토콜 레벨의
모듈에서 L<Mail::Send> 같은 높은 레벨에서 조작하는 모듈까지. 결정하는 것은
당신입니다만, 서버 프로토콜에 특화한 모듈을 만들고 싶겠죠?

당신의 로컬 데이터 포맷에 흥미가 있는 사람은 없습니다. 그래서 그것은 
무시하겠습니다. 단, 그 안의 데이터는 어떻게 할까요? Perl 변수에서 
트리구조를 만들어서 그것을 트라버스 하는 것은 종종 있는 일입니다.
거기에 만약 그런 모듈을 누군가 쓰지 않았다면, 그 코드를 다시 
모듈화하고 싶을 겁니다.

그럼, 어떤 것을 모듈화하면 좋을까, 조금은 알게 되셨을겁니다.
이제부터 그것을 어떻게 해서 하는 것인지 보도록 하죠.

=head2 Step-by-step: 지면의 정비

코드를 쓰기 시작하기 전에, 해둬야할 것이 몇 개 있습니다.

=over 3

=item 찾아보기

많은 모듈을 보고, 어떤 식으로 쓰여져있는 가 보도록 합시다.
L<Text::Tabs> 는 표준 라이브러리에서 깨끗하게 쓰여져 있어서 매우 심플하기에
이것부터 시작하는 것이 좋을 겁니다. 다음에 L<Time::Zone> 이나 
L<File::Copy> 그것에도 오브젝트 지향의 코드를 사용하려고 한다면, 
C<Mail::*> 중에 몇 개를 봐두는 것도 좋을 겁니다.

그렇게 하면, 모듈이 어떻게 레이아웃되고, 쓰여지는 지 대강 알 수 있을 겁니다.

=item 새로운 것인지 어떤 지를 체크

CPAN 에는 많은 모듈이 있기때문에, 당신이 컨트리뷰트하려고 하는 모듈과 
닮은 것이 있어도 지나쳐버릴 지도 모릅니다. 모듈리스트나 F<by-module> 디렉토리를
잘 보고, 차바퀴의 재발명을 하고 있지 않은지를 확인합시다!

=item 필요성을 의논

당신은 그것을 맘에 들어할 겁니다. 다른 모두도 그것을 필요로 한다고 생각하겠죠.
하지만 실제로는 그렇게 유용한 것이 아닐지도 모릅니다. 자신의 모듈이 어느 정도
유용한 것인지 불안하다면 C<comp.lang.perl.modules> 에 글을 올려봅시다.
그래도 안된다면, C<modules@perl.org> 의 모듈 메일링리스트를 열도 둡시다.
이 메일링리스트는 Closed하고 대기 시간도 긴 것에 주의해주세요.
답변이 오기까지에는 잠깐 기다릴 필요가 있을 지도 모르겠습니.

=item 이름을 결정 

CPAN 에 포함된 Perl 모듈에는 네이밍계층이 있어, 그것에 맞출 필요가 있습니다.
이것이 어떻게 정리되고 있는지의 상세한 내용은 L<perlmodlib>을 봐 주세요.
또, CPAN 이나 모듈리스트를 돌아보고, 어떤 것을 만져보세요. 적어도 이것만은 
기억해두세요: 모듈이름은 대문자로 시작한다(This::That 처럼), 카테고리에 
적합한다, 그리고 목적을 간결하게 설명한다.

=item 다시 한번 체크

그렇게 하고 있는 사이 쓰려고 하는 모듈과 비슷한 모듈을 정말 보지못하고 
지나치지는 않았나 확인해주세요.
정리해두고, 그 모듈은 필요로 하고 있고 아직 존재하지 않는다고 확신하면 
코드를 쓰기 시작합시다.

=back

=head2 Step-by-step: 모듈을 만들기

=over 3

=item F<h2xs> 로 시작

L<h2xs>는 우너래 C 헤더파일을 XS 모듈로 하기위한 유틸리티였지만, 
Pure Perl 모듈용의 스켈레톤을 만드는 유틸리티로써도 편리합니다.
만약 L<Autoloader> (큰 모듈을 작은 루틴으로 분할하는 모듈)가 
필요하지 않다면, 아래처럼 실행해주세요.

    h2xs -AX -n Net::Acme

C<-A> 는 Autoloader 를 생략하고, C<-X> 는 XS를 생략합니다. C<-n>로 
모듈의 이름을 지정합니다.

=item Use L<strict> and L<warnings>

모듈의 코드는 warnings 와 strict 클린하지 않으면 안됩니다.
어떤 상황에서 그 모듈이 이용되는지 알 수 없기 때문이죠. 거기에 
warnig 이나 strict 클린하지 않은 코드같은 건 배포하고 싶지도 않겠죠?

=item Use L<Carp>

L<Carp> 모듈을 사용하면, 에러메시지를 호출하는 측의 시점에서 출력할 수 
있습니다. 그 모듈이 아니고, 호출하는 측의 문제인 것을 나타내는 것입니다.
예를 들면, 이렇게 하면:

    warn "No hostname given";

유저는 이런 메시지를 보게 됩니다.

    No hostname given at /usr/local/lib/perl5/site_perl/5.6.0/Net/Acme.pm
    line 123.

이것으로는 당신의 모듈이 뭔가 틀린 일을 하고 있는 것처럼 보입니다.
대신에 유저에게 책임을 없게하는 것입니다. 이처럼 출력합니다:

    No hostname given at bad_code, line 10.

이렇게 하면, L<Carp>를 사용해서 C<warn> 을 C<carp> 로 바꿉니다.
만약 C<die> 할 필요가 있다면, C<croak> 를 사용합시다. 단지 진정으로 
당신의 모듈의 책임에 따라 체크할 경우는 C<warn> 이나 C<die> 대로 
둡시다.

=item Use L<Exporter> - 현명하게!

C<h2xs> 는 L<Exporter> 의 일부분을 제공하고 있습니다.
이에 의해, 심볼이나 서브루틴을 모듈에서 호출하는 측의 이름공간에 Export 하는
표준적인 방법을 알게 될겁니다. 예를 들면, C<use Net::Acme qw(&frob)> 라고 
쓰면 C<frob> 서브루틴을 Import 합니다.

패키지 변수의 C<@EXPORT> 에 의해 호출하는 측이 단순히 C<use Net::Acme> 라고 
쓴 때에, 어떤 심볼이 Export 되는 것인가 결정됩니다. 대부분의 경우는 여기에는
아무것도 넣고 싶지 않겠죠. 한편 C<@EXPORT_OK> 를 사용하면, 어떤 변수를
Export 해도 좋은지를 지정할 수 있습니다. 많은 심볼을 Export 하고 싶은 경우, 
C<%EXPORT_TAGS> 를 사용해서, Export 설정을 정의합시다. 자세한 것은 
L<Exporter> 를 봐주세요.

=item plain old documentation 를 사용

일은 Paper Work 가 끝나기 까지는 끝나지 않습니다. 모듈의 문서를 
쓰기 위한 시간이 필요합니다. C<h2xs> 를 이용하면, template 를 
만들어 주기때문에, 그것을 넣으면 됩니다. 포맷을 잘 모르겠다면, 
우선은 L<perlpod>를 봐주세요. 모듈을 어떻게 사용하는 가하는 자세한 개요, 
그리고 신택스의 설명이나 각각의 서브루틴이나 메소드의 기능설명을 
제공해주세요. 개발자의 노트로써 Perl 의 코멘트를 이용하고, 
엔드유저로의 노드에는 POD를 사용해주세요.

=item 테스트 쓰기

반드시 유닛 테스트 코드를 만들고, 당신의 모듈이 여러 플랫폼위의
Perl 에서 의도한대로 잘 움직이는 것을 확인합시다.
CPAN 에 모듈을 업로드하려면, 많은 테스터가 모듈을 빌드해서 
테스트의 결과를 당신에게 보내줄 겁니다. 여기에서도 또, 
C<h2x2> 를 사용하면, 나중에 확장가능한 테스트프레임워가 제공됩니다. 
단순히 컴파일이 통하는 가하는 것만 아니라 여러가지를 테스트합시다.

=item README 를 쓰기

CPAN 에 업로드할 때는 README 파일이 자동으로 유출되고, 당신의 
CPAN 디렉토에 놓여집니다. 또, 모듈리스트에 실린 경우에는 
F<by-module> 이나 F<by-category> 의 메인디렉토리에도 배치됩니다.
이 파일에 그 모듈이 하는 것의 상세한 내용이나 이전의 릴리즈에서의 
변경점을 적어두면 좋겠죠?

=back

=head2 Step-by-step: 모듈을 배포하기

=over 3

=item CPAN 유저 ID 취득하기

CPAN 에서 모듈을 배포하기에는, CPAN ID 가 필요합니다. 어떻게 해서 
얻을 까는 C<http://www.cpan.org/modules/04pause.html>(혹은 그 미러)
의 지시를 읽어 주세요.

=item C<perl Makefile.PL; make test; make dist>

여기에서도 C<h2x2> 는 모든 것을 해줍니다. 모듈을 인스톨할 때에 자주 보는 
표준적인 C<Makefile.PL> 이 생깁니다. 이것이 생성하는 Makefile 에 
C<dist> 타겟이 있습니다.

모듈이 테스트를 패스한 것을 확인하면 (언제라도 확인하는 것은 좋은 겁니다)
C<make dist> 를 실행하면, Makefile 은 업로드 준비를 마친 
tarball 파일을 생성해줍니다.

=item tarball 을 업로드하기 

CPAN ID 를 얻었을 때 도착하는 email 에 PAUSE( the Perl Authors Upload SErver)
로의 로그인 방법이 적혀있습니다. 메뉴에서 선택해서 모듈을 CPAN에 업로드 
할 수 있습니다.

=item 모듈 리스트에 알리기 

업로드 하면, 당신의 디렉토리에 있는 것만으로는 다른 사람들의 시선을 끌 수 없죠.
남은 CPAN 모듈처럼 싣고 싶다면, 모듈 리스트에 그 것을 전달합니다. 
제일 좋은 방법은 모듈리스트와 같은 스타일로 Email 을 이렇게 쓰는 겁니다.

  Net::Acme bdpOP   Interface to Acme Frobnicator servers      FOOBAR
  ^         ^^^^^   ^                                          ^
  |         |||||   모듈의 설명                                당신의 Iㅇ
  |         ||||| 
  |         ||||\-라이센스: (p)standard Perl, (g)GPL, (b)BSD,
  |         ||||              (l)LGPL, (a)rtistic, (o)ther
  |         ||||
  |         |||\- 인터페이스: (O)OP, (r)eferences, (h)ybrid, (f)unctions
  |         |||
  |         ||\-- 언어: (p)ure Perl, C(+)+, (h)ybrid, (C), (o)ther
  |         ||
  Module    |\--- 서포트: (d)eveloper, (m)ailing list, (u)senet, (n)one
  Name      |
            \---- 개발상황: (i)dea, (c)onstructions, (a)lpha, (b)eta,
                            (R)eleased, (M)ature, (S)tandard


그리고 모듈의 설명과 이것은 리스트에 포함되어야 할 이유를 기술합니다.
무엇도 답이 오지 않으면, 다음 갱신에서 모듈리스트에 실릴 겁니다.
C<modules@perl.org> 에 subscribe 하려고 하지 않도록 해주세요.
이것은 메일링 리스트가 아닙니다. 

=item clpa 에 알리기 

릴리즈한 것을 전세계에 알리고 싶다는 야망이 있다면, 모데레이터된 
C<comp.lang.perl.announce> 뉴스그룹에 알립니다.

=item 버그를 고치기

유저가 모여들면 버그리포트를 보내옵니다. 운이 좋으면 패치를 보내올 겁니다.
소프트웨어 프로젝트의 유지보수라는 것은 기쁨이 기다리고 있는 겁니다.

=back

=head1 AUTHOR

Simon Cozens, C<simon@cpan.org>

=head1 SEE ALSO

L<perlmod>, L<perlmodlib>, L<perlmodinstall>, L<h2xs>, L<strict>,
L<Carp>, L<Exporter>, L<perlpod>, L<Test>, L<ExtUtils::MakeMaker>,
http://www.cpan.org/,  Ken Williams' tutorial on building your own
module at http://mathforum.org/~ken/perl_modules.html
